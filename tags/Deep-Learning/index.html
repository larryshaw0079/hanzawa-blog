<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: Deep Learning - Hanzawa の 部屋</title><meta property="og:type" content="blog"><meta property="og:title" content="Hanzawa の 部屋"><meta property="og:url" content="http://qfxiao.me/"><meta property="og:site_name" content="Hanzawa の 部屋"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Hanzawa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://qfxiao.me/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://qfxiao.me"},"headline":"Hanzawa の 部屋","image":["http://qfxiao.me/img/og_image.png"],"author":{"@type":"Person","name":"Hanzawa"},"description":null}</script><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hanzawa の 部屋" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Deep Learning</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/03/01/Discovering-Physical-Concepts-with-Neural-Networks/"><img class="thumbnail" src="http://qfxiao.me/img/image-20200301230011495.png" alt="Discovering Physical Concepts with Neural Networks"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-01T14:55:02.000Z" title="2020-03-01T14:55:02.000Z">2020-03-01</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Misc/">Misc</a></span><span class="level-item">13 分钟 读完 (大约 2019 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/01/Discovering-Physical-Concepts-with-Neural-Networks/">Discovering Physical Concepts with Neural Networks</a></h1><div class="content"><h1 id="introduction">Introduction</h1>
<p>如题目所示，本文的目的是利用神经网络来发掘物理概念。其思路是从实验数据学到表示，然后用学到的表示来回答物理问题，由此物理概念可以从学到的表示来提取出。作者进行了4个实验：</p>
<ol type="1">
<li>在阻尼振动实验中，模型学到了相关的物理参数；</li>
<li>在角动量守恒实验中，模型预测了质点的运动；</li>
<li>给定量子系统的观测数据，模型正确的识别出了量子状态的自由度；</li>
<li>给定从地球观测的太阳和火星的位置时间序列数据，模型发现了日心说模型。</li>
</ol>
<h1 id="preliminaries">Preliminaries</h1>
<p>作者在附录中对神经网络的基础知识进行了介绍，这里不再赘述，只截取了一些相对前沿的内容。</p>
<p><img src="http://qfxiao.me/img/image-20200301230151518.png" style="zoom:67%;" /></p>
<h2 id="variational-autoencoders">Variational Autoencoders</h2>
<p>本文用到的模型基础是VAE：</p>
<p><img src="http://qfxiao.me/img/image-20200301230200451.png" style="zoom:67%;" /></p>
<h3 id="representation-learning">Representation Learning</h3>
<p><em>Representation learning</em>的主要目标是将数据映射到一个隐向量 (encoder)，为了保证隐向量包含了所有相关信息， 那么应该能够从隐向量还原原数据 (decoder)。传统的Autoencoder是这个思想的最简单实现，而VAE则将AE和<em>Variational Inference</em>结合了起来，是一种经典的生成式模型。现在很多研究关注<em>Disentangled Representation Learning</em>，也就是说我们希望模型能够无监督地学习数据，从中学到有意义的表示。</p>
<h3 id="boldsymbol-beta-vae"><span class="math inline">\(\boldsymbol \beta\)</span>-VAE</h3>
<p><span class="math inline">\(\beta\)</span>-VAE是一种特殊的VAE，也是一个经典的<em>Disentangled Representation Learning</em>模型，它和VAE主要的区别是对KL散度一项加上了权重<span class="math inline">\(\beta\)</span>进行调节： <span class="math display">\[
C_\beta(x)=-\left[\mathbb{E}_{z\sim p_\phi(z|x)}\log p_\theta(x|z)\right] + \beta D_\text{KL}\left[p_\phi(z|x)\parallel h(z)\right]
\]</span> 如果假设<span class="math inline">\(p_\phi(z|x)=\mathcal{N}(\mu,\sigma)\)</span>，那么损失函数可以进行简化： <span class="math display">\[
C_\beta(x)=\parallel \hat{x} - x \parallel^2_2-\frac{\beta}{2}\left(\sum\limits_i\log(\sigma_i^2)-\mu_i^2-\sigma_i^2\right)+C
\]</span></p>
<h1 id="network-structure">Network Structure</h1>
<h2 id="network-structure-scinet">Network Structure: <em>SciNet</em></h2>
<p>模仿物理学家建模物理问题的过程，作者提出了<em>SciNet</em>，如下图所示：</p>
<p><img src="http://qfxiao.me/img/image-20200301225708559.png" style="zoom:67%;" /></p>
<p>物理学家在建模物理问题的时候，往往是从一些实验数据出发，根据物理常识提取更加精练的表示，然后用学到的表示来回答物理问题。</p>
<p>对于单纯的输入输出问题，<em>SciNet</em>可以看作是一个映射，<span class="math inline">\(F:\mathcal{O}\times\mathcal{Q}\rightarrow\mathcal{A}\)</span>。<span class="math inline">\(\mathcal{O}\)</span>是可能的实验数据集合，<span class="math inline">\(\mathcal{Q}\)</span>是可能的问题集合，<span class="math inline">\(\mathcal{A}\)</span>是可能的答案集合。可以将其分为两个步骤：编码过程<span class="math inline">\(E:\mathcal{O}\rightarrow\mathcal{R}\)</span>从实验数据学到表示，解码过程<span class="math inline">\(D:\mathcal{R}\times \mathcal{Q}\rightarrow \mathcal{A}\)</span>根据给定的问题从表示来回答问题。由此，<span class="math inline">\(F(o,q)=D(E(o),q)\)</span>。在实现方面，<em>SciNet</em>采用的是全连接网络。</p>
<h2 id="training-and-testing-scinet">Training and Testing <em>SciNet</em></h2>
<p>用来训练的数据形式为<span class="math inline">\((o,q,a_{cor}(o,q))\)</span>，观测<span class="math inline">\(o\)</span>和问题<span class="math inline">\(q\)</span>分别从观测集<span class="math inline">\(\mathcal{O}\)</span>和问题集<span class="math inline">\(\mathcal{Q}\)</span>选出，<span class="math inline">\(a_{cor}(o,q)\)</span>为对应的正确答案。在训练过程中，我们希望准确度尽量高，并且学到<em>minimal uncorrelated representations</em>。为此，作者采用<em>disentangling variational autoencoder</em>作为模型。</p>
<h1 id="results">Results</h1>
<p>在文中，作者进行了4个实验来验证模型的有效性。</p>
<h2 id="damped-pendulum">Damped Pendulum</h2>
<p>阻尼振动实验：</p>
<ul>
<li><p>任务：预测一维阻尼振动在不同时间的位置。</p></li>
<li><p>物理模型：<span class="math inline">\(-kx-b\dot{x}=m\ddot{x}\)</span>，<span class="math inline">\(k\)</span>为弹性模量，<span class="math inline">\(b\)</span>为阻尼系数，通解为<span class="math inline">\(x(t)=A_0e^{-\frac{b}{2m}t}\cos(\omega t+\delta_0), \space \omega=\sqrt{\frac{k}{m}}\sqrt{1-\frac{b^2}{4mk}}\)</span></p></li>
<li>观测数据：位置时间序列数据<span class="math inline">\(o=[x(t_i)]_{i\in\{1,\cdots,50\}}\in\mathbb{R}^{50}\)</span>，时间间隔相等，质量<span class="math inline">\(m=1\text{kg}\)</span>，振幅<span class="math inline">\(A_0=1\text{m}\)</span>，相位<span class="math inline">\(\delta_0=0\)</span>，弹性模量<span class="math inline">\(k\in[5,10]\text{kg}/\text{s}^2\)</span>，阻尼系数<span class="math inline">\(b\in[0.5,1]\text{kg}/\text{s}\)</span>。</li>
<li><p>问题：预测<span class="math inline">\(q=t_\text{pred}\in\mathbb{R}\)</span></p></li>
</ul>
<p><img src="http://qfxiao.me/img/image-20200301225805576.png" /></p>
<p>隐变量大小设置为3，结果如下图所示：</p>
<p><img src="http://qfxiao.me/img/image-20200301225838353.png" style="zoom:67%;" /></p>
<p>(b)中的三幅图分别是学到的三个隐变量和我们感兴趣的参数<span class="math inline">\(k\)</span>和<span class="math inline">\(b\)</span>的关系图。第一幅图中变量<span class="math inline">\(1\)</span>与<span class="math inline">\(b\)</span>几乎完全线性相关，与<span class="math inline">\(k\)</span>基于线性无关，变量<span class="math inline">\(2\)</span>只和<span class="math inline">\(k\)</span>相关。变量<span class="math inline">\(3\)</span>几乎为一个常数，故不提供额外的信息。由此作者认为<em>SciNet</em>学到了我们关心的两个参数的知识。</p>
<h2 id="conservation-of-angular-momentum">Conservation of Angular Momentum</h2>
<p>角动量守恒实验：</p>
<ul>
<li>任务：预测一个由长度为<span class="math inline">\(r\)</span>的绳子捆绑着的旋转质点在位置<span class="math inline">\((0,r)\)</span>经一个自由质点撞击后的位置</li>
<li>物理模型：给定撞击之前的角动量，自由质点撞击之后的速度，旋转质点在撞击之后在时间<span class="math inline">\(t_\text{pred}^\prime\)</span>的位置可以由角动量守恒定律给出：</li>
</ul>
<p><span class="math display">\[
J=m_\text{rot}r^2\omega-rm_\text{free}(\mathbf{v}_\text{free})_x=m_\text{rot}r^2\omega^\prime-rm_\text{free}(\mathbf{v}^\prime_\text{free})_x=J^\prime
\]</span></p>
<ul>
<li>观测数据：在撞击之前两个质点的位置数据<span class="math inline">\(o=[(t_i^\text{rot},q_\text{rot}(t_i^\text{rot})),(t_i^\text{free},q_\text{free}(t_i^\text{free}))]_{i\in\{1,\cdots,5\}}\)</span>，质量为固定值，半径<span class="math inline">\(r\)</span>也为固定值。数据添加高斯噪声。</li>
<li>问题：预测撞击之后自由质点在时间<span class="math inline">\(t_\text{pred}^\prime\)</span>的位置</li>
</ul>
<p><img src="http://qfxiao.me/img/image-20200301225858626.png" /></p>
<p>实验室意图如下：</p>
<p><img src="http://qfxiao.me/img/image-20200301225917614.png" style="zoom:67%;" /></p>
<p>实验结果表明<em>SciNet</em>能够正确预测质点撞击之后的位置，同时对噪音鲁棒。根据(b)，隐变量和角动量存在线性相关关系，作者认为<em>SciNet</em>学到了守恒的动量这一概念。</p>
<h2 id="representation-of-qubits">Representation of Qubits</h2>
<p>量子比特实验：</p>
<ul>
<li>任务：预测在<span class="math inline">\(n=1,2\)</span>的纯<span class="math inline">\(n\)</span>量子位状态<span class="math inline">\(\psi\in\mathbb{C}^{2^n}\)</span>下任何二进制投影测量<span class="math inline">\(\omega\in\mathbb{C}^{2^n}\)</span>的测量概率。</li>
<li>物理模型：在执行测量<span class="math inline">\(\omega\in\mathbb{C}^{2^n}\)</span>的状态<span class="math inline">\(\psi\in\mathbb{C}^{2^n}\)</span>下测量0的概率<span class="math inline">\(p(\omega,\psi)\)</span>由<span class="math inline">\(p(\omega,\psi)=|\left&lt;\omega,\psi\right&gt;|^2\)</span>给定</li>
<li>观测数据：状态<span class="math inline">\(\psi: o=[p(\alpha_i,\psi)]_{i\in\{i,\cdots,n_1\}}\)</span>的操作参数化：表示一组固定的随机二元射影测量值<span class="math inline">\(\mathcal{M}_1=\{\alpha_1,\cdots,\alpha_{n_1}\}\)</span>（一个量子位<span class="math inline">\(n_1 = 10\)</span>，两个量子位<span class="math inline">\(n_1 = 30\)</span>）</li>
<li>问题：对于固定的一组随机二元射影测量<span class="math inline">\(\mathcal{M}_2=\{\beta_1,\cdots,\beta_{n_2}\}\)</span>，测量<span class="math inline">\(\omega:q=[p(\beta_i,\omega)]_{i\in\{1,\cdots,n_2\}}\)</span>的Operational参数化（一个量子位<span class="math inline">\(n_2 = 10\)</span>，两个量子位<span class="math inline">\(n_2 = 30\)</span>）</li>
</ul>
<p><img src="http://qfxiao.me/img/image-20200301225929696.png" /></p>
<p>实验结果如下：</p>
<p><img src="http://qfxiao.me/img/image-20200301225958663.png" style="zoom:67%;" /></p>
<p>通过实验发现，<em>SciNet</em>可以在不提供先验物理知识的条件下确定表述状态<span class="math inline">\(\psi\)</span>最小的参数数量。同时，<em>SciNet</em>还能分辨<em>tomographically complete</em>和<em>tomographically incomplete</em>。</p>
<h2 id="heliocentric-model-of-the-solar-system">Heliocentric Model of the Solar System</h2>
<p>日心说模型：</p>
<ul>
<li>问题：在给定初始条件下预测相对与地球的太阳和火星的角度<span class="math inline">\(\theta_M(t)\)</span>和<span class="math inline">\(\theta_S(t)\)</span></li>
<li>物理模型：地球和火星围绕太阳以一定角速度做近似圆周运动</li>
<li>观测数据：给定初始角度，随机选择周周期的哥白尼的观测数据</li>
</ul>
<p><img src="http://qfxiao.me/img/image-20200301230035141.png" /></p>
<p>模型的实现稍有变化，如下图所示：</p>
<p><img src="http://qfxiao.me/img/image-20200301230011495.png" style="zoom:67%;" /></p>
<p>这样，对于不同时间都对应一个隐变量<span class="math inline">\(r(t_i)\)</span>，而且隐变量是时间依赖的，对于一个隐变量<span class="math inline">\(r(t_i)\)</span>有一个解码器来输出答案。</p>
<p><img src="http://qfxiao.me/img/image-20200301230101709.png" style="zoom:67%;" /></p>
<p>实验结果表示，<em>SciNet</em>不仅正确预测了太阳和火星相对地球的角度，同时隐变量揭示了火星和地球相对太阳的角度。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/02/24/Deep-Anomaly-Detection-with-Deviation-Networks/"><img class="thumbnail" src="http://qfxiao.me/img/image-20200113104953902.png" alt="Deep Anomaly Detection with Deviation Networks"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-24T02:45:08.000Z" title="2020-02-24T02:45:08.000Z">2020-02-24</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></span><span class="level-item">15 分钟 读完 (大约 2216 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/24/Deep-Anomaly-Detection-with-Deviation-Networks/">Deep Anomaly Detection with Deviation Networks</a></h1><div class="content"><h1 id="introduction">Introduction</h1>
<p>本文关注<code>Deep Anomaly Detection</code>，也就是用深度学习的方法来进行异常检测。文中提到现有的<code>Deep Anomaly Detection</code>存在两个弊端：一个是采用深度学习方法来进行特征学习，然后通过下游任务得到<code>Anomaly Score</code>，相比文中End-to-End的<code>Anomaly Score</code>学习，存在优化不充分的风险；另一个是现有的方法主要是无监督学习，无法利用已知的信息（如少量标签）。为此，本文提出了一种端到端的异常检测框架，来解决上述问题。</p>
<p>本文的主要贡献如下：</p>
<ul>
<li>提出了一种端到端的异常检测框架，直接学习<code>Anomaly Score</code>并且可以利用已知信息；</li>
<li>基于提出的框架，文中提出了一种实例方法 (DevNet)。</li>
</ul>
<p><img src="http://qfxiao.me/img/image-20200113104938784.png" style="zoom:67%;" /></p>
<h1 id="proposed-model">Proposed Model</h1>
<h2 id="end-to-end-anomaly-score-learning">End-To-End Anomaly Score Learning</h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>为了区别于传统的两阶段异常检测（先学习特征表示，然后在学到的特征上定义一个<code>anomaly measure</code>来得到<code>anomaly score</code>），作者对端到端的异常检测问题重新进行形式化。</p>
<p>给定<span class="math inline">\(N+K\)</span>个样本<span class="math inline">\(\mathcal{X}=\{\boldsymbol x_1,\boldsymbol x_2,\cdots,\boldsymbol x_N,\boldsymbol x_{N+1},\cdots,\boldsymbol x_{N+K}\}\)</span>，其中<span class="math inline">\(\boldsymbol x_i\in\mathbb{R}^D\)</span>，无标签样本集<span class="math inline">\(\mathcal{U}=\{\boldsymbol x_1,\boldsymbol x_2,\cdots,\boldsymbol x_N\}\)</span>，有标签样本集<span class="math inline">\(\mathcal{K}=\{\boldsymbol x_{N+1},\cdots,\boldsymbol x_{N+K}\}\)</span>，且<span class="math inline">\(K\ll N\)</span>。异常检测的目标是学习一个<code>anomaly scoring function</code><span class="math inline">\(\phi:\mathcal{X}\mapsto\mathbb{R}\)</span>使得<span class="math inline">\(\phi(\boldsymbol x_i)&gt;\phi(\boldsymbol x_j)\)</span>，其中<span class="math inline">\(\boldsymbol x_i\)</span>为异常样本，<span class="math inline">\(\boldsymbol x_j\)</span>为正常样本。</p>
<h3 id="the-proposed-framework">The Proposed Framework</h3>
<p>为了解决这个问题，文中提出了一种通用异常检测框架，模型框架如下图所示：</p>
<p>模型框架如下图所示：</p>
<p><img src="http://qfxiao.me/img/image-20200113104953902.png" style="zoom:50%;" /></p>
<p>主要包含三个部分：</p>
<ol type="1">
<li><em>anomaly scoring network</em>. 图中左边的部分，一个函数<span class="math inline">\(\phi\)</span>，输入样本<span class="math inline">\(\mathbf{x}\)</span>，输出<code>anomaly score</code></li>
<li><em>reference score generator</em>. 图中右边的部分。只有一个<em>anomaly scoring network</em>并不能进行训练，需要训练的目标。为此加入<em>reference score generator</em>，输入为随机选择的<span class="math inline">\(l\)</span>个正常样本，输出<code>reference score</code>（这<span class="math inline">\(l\)</span>个正常样本<code>anomaly score</code>的均值，记为<span class="math inline">\(\mu_\mathcal{R}\)</span>）</li>
<li><em>deviation loss</em>. <span class="math inline">\(\phi(\mathbf{x})\)</span>，<span class="math inline">\(\mu_\mathcal{R}\)</span>及对应的标准差<span class="math inline">\(\sigma_\mathcal{R}\)</span>作为<code>deviation loss</code>函数的输入。因为<span class="math inline">\(\mu_\mathcal{R}\)</span>和<span class="math inline">\(\sigma_\mathcal{R}\)</span>对应正常样本集的均值和方差，那么异常样本的<code>anomaly score</code>应该和<span class="math inline">\(\mu_\mathcal{R}\)</span>差别比较大，而正常样本则应该接近<span class="math inline">\(\mu_\mathcal{R}\)</span>。</li>
</ol>
<h2 id="deviation-networks">Deviation Networks</h2>
<p>下面是上述三个部件的具体实现。</p>
<h3 id="end-to-end-anomaly-scoring-network">End-To-End Anomaly Scoring Network</h3>
<p>记<span class="math inline">\(\mathcal{Q}\in\mathbb{R}^M\)</span>为中间表示空间，<code>anomaly scoring network</code><span class="math inline">\(\phi(\cdot;\Theta):\mathcal{X}\mapsto\mathbb{R}\)</span>可以定义为数据表示学习<span class="math inline">\(\psi(\cdot;\Theta_t):\mathcal{X}\mapsto\mathcal{Q}\)</span>和异常分数学习<span class="math inline">\(\eta(\cdot;\Theta_s):\mathcal{Q}\mapsto\mathbb{R}\)</span>两阶段的组合，其中<span class="math inline">\(\Theta=\{\Theta_t,\Theta_s\}\)</span>。</p>
<p><span class="math inline">\(\psi(\cdot;\Theta_t)\)</span>可以用一个<span class="math inline">\(H\)</span>层神经网络来实现： <span class="math display">\[
\mathrm{q}=\psi(\mathbf{x};\Theta_t)
\]</span> 其中<span class="math inline">\(\mathbf{x}\in\mathcal{X}\)</span>，<span class="math inline">\(\mathrm{q}\in\mathcal{Q}\)</span>。</p>
<p><span class="math inline">\(\eta(\cdot;\Theta_s)\)</span>可以用一个单层的神经网络来实现： <span class="math display">\[
\eta(\mathrm q;\Theta_s)=\sum\limits_{i=1}^M w_i^oq_i+w_{M+1}^o
\]</span> 其中<span class="math inline">\(\mathrm q\in\mathcal Q\)</span>，<span class="math inline">\(\Theta_s=\{\mathbf{w}^o\}\)</span>。</p>
<p>所以有： <span class="math display">\[
\phi(\mathbf{x};\Theta)=\eta(\psi(\mathbf{x};\Theta_t);\Theta_s)
\]</span></p>
<h3 id="gaussian-prior-based-reference-scores">Gaussian Prior-based Reference Scores</h3>
<p>有两种方法来获得<span class="math inline">\(\mu_\mathcal{R}\)</span>，一种是data-driven，一种是prior-driven。如果是data-driven的话则采用另一个神经网络，文中表示为了更好的解释性和计算效率，所以采用的是prior-driven。 <span class="math display">\[
\begin{align}
r_1,r_2,\cdots,r_l\sim \mathcal{N}(\mu,\sigma^2),\\
\mu_\mathcal{R}=\frac{1}{l}\sum\limits_{i=1}^l r_i
\end{align}
\]</span> 在文中，采用的prior是标准高斯分布。</p>
<h2 id="z-score-based-deviation-loss">Z-Score Based Deviation Loss</h2>
<p><em>anomaly scoring network</em>的优化目标可以定义为Z-Score的方式： <span class="math display">\[
dev(\boldsymbol x)=\frac{\phi(\boldsymbol x;\Theta)-\mu_{\mathcal{R}}}{\sigma_{\mathcal{R}}}
\]</span> <span class="math inline">\(dev(\boldsymbol x)\)</span>可以看作是样本偏离标准的程度，而我们肯定希望异常样本偏离标准越大，正常样本越接近标准。文中采用的损失函数是<code>Contrastive Loss</code>： <span class="math display">\[
L(\phi(\boldsymbol x;\Theta),\mu_\mathcal{R},\sigma_\mathcal{R})=(1-y)|dev(\boldsymbol x)| + y \max(0, a - dev(\boldsymbol x))
\]</span> <code>Contrastive Loss</code>的直观解释可以看下图：</p>
<p><img src="http://qfxiao.me/img/contrastive_2020_2_24.png" style="zoom:50%;" /></p>
<p>对于负例（正常），优化过程将他们尽量向原点靠近，对于正例（异常），优化过程将他们拉向边界。</p>
<h2 id="the-devnet-algorithm">The DevNet Algorithm</h2>
<p><code>DevNet</code>的算法流程图如下：</p>
<p><img src="http://qfxiao.me/img/image-20200113105040134.png" /></p>
<h2 id="interpretability-of-anomaly-scores">Interpretability of Anomaly Scores</h2>
<p>因为<em>reference score generator</em>选择的是确定的高斯分布，于是可以用概率论给出一些解释性。作者给出了一个结论，</p>
<blockquote>
<p><strong>PROPOSITION</strong>： 设<span class="math inline">\(\boldsymbol x\in\mathcal{X}\)</span>，<span class="math inline">\(z_p\)</span>为<span class="math inline">\(\mathcal{N}(\mu,\sigma^2)\)</span>的分位数，那么<span class="math inline">\(\phi(\boldsymbol x)\)</span>在区间<span class="math inline">\(\mu\pm z_p\sigma\)</span>的概率为<span class="math inline">\(2(1-p)\)</span>。</p>
</blockquote>
<p>例如，假设<span class="math inline">\(p=0.95\)</span>，那么<span class="math inline">\(z_{0.95}=1.96\)</span>，表示异常分数高于1.96的样本将以0.95的置信度为异常。</p>
<h1 id="experiment">Experiment</h1>
<p>实验用到了9个数据集，4个Baseline (REPEN，DSVDD，FSNET，iForest)，以及ROC和PR曲线两种评测标准。</p>
<h2 id="effectiveness-in-real-world-data-sets">Effectiveness in Real-world Data Sets</h2>
<h3 id="experiment-settings">Experiment Settings</h3>
<p>这一个实验主要是为了验证算法在真实场景下的效果，即大量无标签数据和极少量标签数据。训练集包含两部分，一部分是无标签数据<span class="math inline">\(\mathcal{U}\)</span>,包含<span class="math inline">\(2\%\)</span>的异常样本，另一部分是有标签数据<span class="math inline">\(\mathcal{K}\)</span>，由随机采样<span class="math inline">\(0.005\%-1\%\)</span>的训练数据和<span class="math inline">\(0.08\%-6\%\)</span>的异常样本组成。</p>
<h3 id="findings">Findings</h3>
<p>实验结果如下表所示：</p>
<p><img src="http://qfxiao.me/img/image-20200113110000432.png" /></p>
<p>从结果上看来，本文提出的方法在所有数据集上都比Baseline好，说明<code>DevNet</code>端到端直接优化<code>Anomaly Score</code>的方式是有效的。</p>
<h2 id="data-efficiency">Data Efficiency</h2>
<h3 id="experiment-settings-1">Experiment Settings</h3>
<p>这一个实验主要是为了探究基于深度的异常检测方法的<em>data efficiency</em>。和上一个实验一样，无标签数据集包含<span class="math inline">\(2\%\)</span>的异常，而有标签的异常数量从<span class="math inline">\(5\)</span>到<span class="math inline">\(120\)</span>不等。本实验试图回答以下两个问题：</p>
<ul>
<li><code>DevNet</code>的<em>data efficiency</em>如何？</li>
<li>基于深度的方法在多大程度上能够利用标签信息？</li>
</ul>
<h3 id="findings-1">Findings</h3>
<p>在几个基于深度的Baseline中，<code>DevNet</code>的效果是最好的，同时在有标签异常非常有限的情况下，<code>DevNet</code>也能很好的利用标签信息，达到更好的效果。</p>
<p><img src="http://qfxiao.me/img/image-20200113110017195.png" /></p>
<h2 id="robustness-w.r.t.-anomaly-contamination">Robustness w.r.t. Anomaly Contamination</h2>
<h3 id="experiment-settings-2">Experiment Settings</h3>
<p>在第一个实验中，无标签数据集<span class="math inline">\(\mathcal{U}\)</span>包含的是固定的异常比例<span class="math inline">\(2\%\)</span>，而在这个实验中，作者测试了从<span class="math inline">\(0\%\)</span>到<span class="math inline">\(20\%\)</span>之间不同异常比例来测试算法的鲁棒性（即使<span class="math inline">\(\mathcal{U}\)</span>中包含异常，由于没有标签，在训练的时候仍然假设都为正常来进行训练）。本实验试图回答以下问题：</p>
<ul>
<li>基于深度的异常检测方法的鲁棒性如何？</li>
<li>当训练集中异常污染的比例较高的时候基于深度的方法能否打败无监督的方法？</li>
</ul>
<h3 id="findings-2">Findings</h3>
<p>下图为实验结果：</p>
<p><img src="http://qfxiao.me/img/image-20200113110035878.png" /></p>
<p>从结果上来看，<code>DevNet</code>比其他基于深度的方法鲁棒性更好，同时在高异常污染的情况下仍然比纯无监督方法效果要好。</p>
<h2 id="ablation-study">Ablation Study</h2>
<p>本实验设置了<code>DevNet</code>的三个变体（默认的<code>DevNet-Def</code>为单层隐层加上一个输出层）来进行消融实验，分别是：</p>
<ul>
<li><code>DevNet-Rep</code>，去掉了<em>anomaly scoring network</em>网络的输出层，对应<em>end-to-end learning of anomaly scores</em>和<em>deviation loss</em>；</li>
<li><code>DevNet-Linear</code>，去掉了网络中的非线性层，对应<em>learning of non-linear features</em>；</li>
<li><code>DevNet-3HL</code>，隐层数量为3层。</li>
</ul>
<p>对比结果如下：</p>
<p><img src="http://qfxiao.me/img/image-20200113110048598.png" /></p>
<p>通过实验可以发现，<code>DevNet-Rep</code>说明了<em>end-to-end learning of anomaly scores</em>和<em>deviation loss</em>的有效性，而<code>DevNet-Linear</code>说明了<em>learning of non-linear features</em>的重要性。<code>DevNet-3HL</code>说明了加深网络并不总能带来性能的提升。</p>
<h2 id="scalability-test">Scalability Test</h2>
<p>这一个实验使用合成的数据来测试算法对大规模数据的处理能力，分别从<em>Data Size</em>和<em>Data Dimensionality</em>两方面来测试。结果如下：</p>
<p><img src="http://qfxiao.me/img/image-20200113110113423.png" /></p>
<p>可以看出，<code>DevNet</code>对<em>Data Size</em>并不敏感，同时，面对高维数据，<code>DevNet</code>也没有表现出劣势。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/01/08/Time-Series-Anomaly-Detection-Paper-List/"><img class="thumbnail" src="http://qfxiao.me/img/1571569717718.png" alt="Time Series Anomaly Detection Paper List"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-08T02:27:58.000Z" title="2020-01-08T02:27:58.000Z">2020-01-08</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></span><span class="level-item">19 分钟 读完 (大约 2792 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/08/Time-Series-Anomaly-Detection-Paper-List/">Time Series Anomaly Detection Paper List</a></h1><div class="content"><h1 id="introduction">Introduction</h1>
<p>时间序列异常检测在很多领域例如运维、金融、交通都扮演者重要的角色，其定义如下：</p>
<blockquote>
<p>给定时间序列<span class="math inline">\(X=\{\mathbf{x}_1,\mathbf{x}_2,\cdots,\mathbf{x}_n\}\in\mathbb{R}^{m\times n}\)</span>，异常检测的任务是输出异常标签<span class="math inline">\(y=\{y_1,y_2,\cdots,y_n\}\in\mathbb{R}^n\)</span>，其中<span class="math inline">\(y_t=1\)</span>代表<span class="math inline">\(\mathbf{x}_t\)</span>为异常，<span class="math inline">\(y_t=0\)</span>代表<span class="math inline">\(\mathbf{x}_t\)</span>正常</p>
</blockquote>
<p>本文罗列了一些时间序列异常检测领域值得读的一些文章，Model一章主要按时间序列、通用和图的异常检测分类，Related主要是一些非异常检测、但是能够解决异常检测研究中的一些问题的文章。</p>
<p><img src="http://qfxiao.me/img/1571569717718.png" /></p>
<h1 id="model">Model</h1>
<h2 id="time-series">Time Series</h2>
<h3 id="statistical">Statistical</h3>
<p>主要包括偏向统计方法的模型：</p>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 8%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Temporal Anomaly Detection: Calibrating the Surprise</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1705.10085">📃Paper</a></td>
</tr>
<tr class="even">
<td>Non-Parametric Outliers Detection in Multiple Time Series A Case Study: Power Grid Data Analysis</td>
<td></td>
<td></td>
<td><a href="https://aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16315">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Anomaly Detection in Streams with Extreme Value Theory</td>
<td>KDD17</td>
<td>提出了以Extreme Value Theory为基础的时序异常检测和参数选择方法</td>
<td><a href="https://www.kdd.org/kdd2017/papers/view/anomaly-detection-in-streams-with-extreme-value-theory">📃Paper</a></td>
</tr>
<tr class="even">
<td>Semi-Markov Switching Vector Autoregressive Model-Based Anomaly Detection in Aviation Systems</td>
<td></td>
<td></td>
<td><a href="https://www.kdd.org/kdd2016/subtopic/view/semi-markov-switching-vector-autoregressive-model-based-anomaly-detection-i">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Stochastic Online Anomaly Analysis for Streaming Time Series</td>
<td></td>
<td></td>
<td><a href="https://www.ijcai.org/proceedings/2017/445">📃Paper</a></td>
</tr>
<tr class="even">
<td>Unsupervised Real-time Anomaly Detection for Streaming Data</td>
<td></td>
<td></td>
<td><a href="https://www.sciencedirect.com/science/article/pii/S0925231217309864">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Automatic Anomaly Detection in the Cloud Via Statistical Learning</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/abs/1704.07706">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="classic-machine-learning">Classic Machine Learning</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 9%" />
<col style="width: 20%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Semi-supervised Anomaly Detection with an Application to Water Analytics</td>
<td></td>
<td></td>
<td><a href="https://people.cs.kuleuven.be/~vincent.vercruyssen/publications/2018/ICDM_conference_manuscript.pdf">📃Paper</a></td>
</tr>
<tr class="even">
<td>DILOF: Effective and Memory Efficient Local Outlier Detection in Data Streams</td>
<td></td>
<td></td>
<td><a href="https://www.kdd.org/kdd2018/accepted-papers/view/dsilof-effective-and-memory-efficient-local-outlier-detection-in-data-strea">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Robust Random Cut Forest Based Anomaly Detection On Streams</td>
<td>ICML16</td>
<td>孤立森林的改进版本来做时序异常检测</td>
<td><a href="http://proceedings.mlr.press/v48/guha16.pdf">📃Paper</a> <a href="https://github.com/kLabUM/rrcf">📥Code</a></td>
</tr>
<tr class="even">
<td>Anomaly Detection for an E-commerce Pricing System</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1902.09566">📃Paper</a></td>
</tr>
<tr class="odd">
<td>An Adaptive Approach for Anomaly Detector Selection and Fine-Tuning in Time Series</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1907.07843">📃Paper</a></td>
</tr>
<tr class="even">
<td>Opprentice: Towards Practical and Automatic Anomaly Detection Through Machine Learning</td>
<td>IMC15</td>
<td>以随机森林为基础的时序异常检测</td>
<td><a href="http://netman.cs.tsinghua.edu.cn/wp-content/uploads/2015/11/liu_imc15_Opprentice.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Variational Inference for On-line Anomaly Detection in High-Dimensional Time Series</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1602.07109">📃Paper</a></td>
</tr>
<tr class="even">
<td>A Self-Learning and Online Algorithm for Time SeriesAnomaly Detection, with Application in CPU Manufacturing</td>
<td></td>
<td></td>
<td><a href="https://dl.acm.org/citation.cfm?id=2983344">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="vae">VAE</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 9%" />
<col style="width: 19%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications</td>
<td>WWW18</td>
<td>普通VAE</td>
<td><a href="https://arxiv.org/pdf/1802.03903">📃Paper</a> <a href="https://github.com/haowen-xu/donut">📥Code</a> <a href="http://qfxiao.me/2019/09/22/Unsupervised-Anomaly-Detection-via-Variational-Auto-Encoder-for-Seasonal-KPIs-in-Web-Applications/">✍Blog</a></td>
</tr>
<tr class="even">
<td>Robust and Unsupervised KPI Anomaly Detection Based on Conditional Variational Autoencoder</td>
<td>IPCCC18</td>
<td>条件VAE</td>
<td><a href="https://ieeexplore.ieee.org/document/8710885">📃Paper</a> <a href="https://github.com/yantijin/Buzz">📥Code</a></td>
</tr>
<tr class="odd">
<td>Unsupervised Anomaly Detection for Intricate KPIs via Adversarial Training of VAE</td>
<td>INFOCOM19</td>
<td>VAE加对抗训练</td>
<td><a href="https://ieeexplore.ieee.org/abstract/document/8737430/">📃Paper</a></td>
</tr>
<tr class="even">
<td>Multidimensional Time Series Anomaly Detection: A GRU-based Gaussian Mixture Variational Autoencoder Approach</td>
<td></td>
<td></td>
<td><a href="http://proceedings.mlr.press/v95/guo18a/guo18a.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Robust Anomaly Detection for Multivariate Time Series through Stochastic Recurrent Neural Network</td>
<td>KDD19</td>
<td>多变量基于VAE和RNN的时序异常检测</td>
<td><a href="https://www.kdd.org/kdd2019/accepted-papers/view/robust-anomaly-detection-for-multivariate-time-series-through-stochastic-re">📃Paper</a> <a href="https://github.com/smallcowbaby/OmniAnomaly">📥Code</a></td>
</tr>
<tr class="even">
<td>A Multimodal Anomaly Detector for Robot-Assisted Feeding Using an LSTM-based Variational Autoencoder</td>
<td></td>
<td></td>
<td><a href="http://ieeexplore.ieee.org/document/8279425/">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="rnn">RNN</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Detecting Spacecraft Anomalies Using LSTMs and Nonparametric Dynamic Thresholding</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1802.04431">📃Paper</a></td>
</tr>
<tr class="even">
<td>BINet: Multivariate Business Process Anomaly Detection Using Deep Learning</td>
<td></td>
<td></td>
<td><a href="https://link.springer.com/chapter/10.1007/978-3-319-98648-7_16">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Outlier Detection for Time Series with Recurrent Autoencoder Ensembles</td>
<td></td>
<td></td>
<td><a href="https://www.ijcai.org/proceedings/2019/0378.pdf">📃Paper</a></td>
</tr>
<tr class="even">
<td>LSTM-based Encoder-Decoder for Multi-sensor Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1607.00148">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Detecting Anomalies in Space using Multivariate Convolutional LSTM with Mixtures of Probabilistic PCA</td>
<td>KDD19</td>
<td></td>
<td><a href="https://dl.acm.org/doi/10.1145/3292500.3330776">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="gan">GAN</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 9%" />
<col style="width: 20%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anomaly Detection with Generative Adversarial Networks for Multivariate Time Series</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1809.04758">📃Paper</a> <a href="http://larryshaw0079.coding.me/blog/2019/09/22/Anomaly-Detection-with-Generative-Adversarial-Networks-for-Multivariate-Time-Series/">📥Blog</a></td>
</tr>
<tr class="even">
<td>MAD-GAN: Multivariate Anomaly Detection for Time Series Data with Generative Adversarial Networks</td>
<td>ICANN19</td>
<td>普通GAN做时序异常检测，没有编码结构</td>
<td><a href="https://arxiv.org/pdf/1901.04997">📃Paper</a> <a href="https://github.com/LiDan456/MAD-GANs">📥Code</a></td>
</tr>
<tr class="odd">
<td>BeatGAN: Anomalous Rhythm Detection using Adversarially Generated Time Series</td>
<td>IJCAI19</td>
<td>ECG异常检测，没有隐变量约束</td>
<td><a href="https://www.ijcai.org/proceedings/2019/616">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="miscellaneous">Miscellaneous</h3>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 16%" />
<col style="width: 22%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A Deep Neural Network for Unsupervised Anomaly Detection and Diagnosis in Multivariate Time Series Data</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1811.08055">📃Paper</a></td>
</tr>
<tr class="even">
<td>ALSR: An Adaptive Label Screening and Relearning Approach for Interval-Oriented Anomaly Detection</td>
<td>Expert Systems With Applications</td>
<td>有监督KPI异常检测，使用两阶段训练来提升性能</td>
<td><a href="https://www.sciencedirect.com/science/article/pii/S0957417419304282">📃Paper</a> <a href="http://larryshaw0079.coding.me/blog/2019/09/22/ALSR-An-adaptive-label-screening-and-relearning-approach-for-interval-oriented-anomaly-detection/">✍Blog</a></td>
</tr>
<tr class="odd">
<td>Time-Series Anomaly Detection Service at Microsoft</td>
<td>KDD19</td>
<td>将视觉异常检测中的谱残差应用到了时序异常检测</td>
<td><a href="https://arxiv.org/pdf/1906.03821">📃Paper</a> <a href="https://github.com/microsoft/anomalydetector">📥Code</a> <a href="http://larryshaw0079.coding.me/blog/2019/09/22/Time-Series-Anomaly-Detection-Service-at-Microsoft/">✍Blog</a></td>
</tr>
<tr class="even">
<td>Outlier Detection for Multidimensional Time Series using Deep Neural Networks</td>
<td></td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8411269">📃Paper</a></td>
</tr>
</tbody>
</table>
<h2 id="general">General</h2>
<h3 id="survey">Survey</h3>
<ul>
<li><em>Deep Learning for Anomaly Detection: A Survey</em> <a href="https://arxiv.org/abs/1901.03407">[Paper]</a></li>
</ul>
<h3 id="classic-machine-learning-1">Classic Machine Learning</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LOF: Identifying Density-Based Local Outliers</td>
<td></td>
<td></td>
<td><a href="https://dl.acm.org/citation.cfm?id=335388">📃Paper</a></td>
</tr>
<tr class="even">
<td>Isolation Forest</td>
<td></td>
<td></td>
<td><a href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Extended Isolation Forest</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1811.02141">📃Paper</a></td>
</tr>
<tr class="even">
<td>Hidden Markov Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="http://proceedings.mlr.press/v37/goernitz15.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Linear-Time Outlier Detection via Sensitivity</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1605.00519">📃Paper</a></td>
</tr>
<tr class="even">
<td>Reverse Nearest Neighbors in Unsupervised Distance-Based Outlier Detection</td>
<td></td>
<td></td>
<td><a href="http://ieeexplore.ieee.org/document/6948273">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Theoretical Foundations and Algorithms for Outlier Ensembles</td>
<td></td>
<td></td>
<td><a href="https://www.kdd.org/exploration_files/Article4.pdf">📃Paper</a></td>
</tr>
<tr class="even">
<td>R1SVM: A Randomised Nonlinear Approach to Large-Scale Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI15/paper/view/9343">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Random Gradient Descent Tree: A Combinatorial Approach for SVM with Outliers</td>
<td></td>
<td></td>
<td><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI15/paper/view/9477">📃Paper</a></td>
</tr>
<tr class="even">
<td>Sparse Gaussian Markov Random Field Mixtures for Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/7837932/">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Sequential Ensemble Learning for Outlier Detection: A Bias-Variance Perspective</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1609.05528">📃Paper</a></td>
</tr>
<tr class="even">
<td>Sparse Modeling-Based Sequential Ensemble Learning for Effective Outlier Detection in High-Dimensional Numeric Data</td>
<td></td>
<td></td>
<td><a href="https://aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16648">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Contextual Spatial Outlier Detection with Metric Learning</td>
<td></td>
<td></td>
<td><a href="https://www.kdd.org/kdd2017/papers/view/contextual-spatial-outlier-detection-with-metric-learning">📃Paper</a></td>
</tr>
<tr class="even">
<td>Human-Assisted Online Anomaly Detection with Normal Outlier Retraining</td>
<td></td>
<td></td>
<td><a href="https://www.andrew.cmu.edu/user/lakoglu/odd/accepted_papers/ODD_v50_paper_11.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Efficient Anomaly Detection via Matrix Sketching</td>
<td></td>
<td></td>
<td><a href="https://papers.nips.cc/paper/8030-efficient-anomaly-detection-via-matrix-sketching.pdf">📃Paper</a></td>
</tr>
<tr class="even">
<td>Dual-Regularized Multi-View Outlier Detection</td>
<td></td>
<td></td>
<td><a href="https://www.ijcai.org/Proceedings/15/Papers/572.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Deep Anomaly Detection Using Geometric Transformations</td>
<td></td>
<td></td>
<td><a href="https://papers.nips.cc/paper/8183-deep-anomaly-detection-using-geometric-transformations.pdf">📃Paper</a></td>
</tr>
<tr class="even">
<td>Multi-view Anomaly Detection via Robust Probabilistic Latent Variable Models</td>
<td></td>
<td></td>
<td><a href="https://papers.nips.cc/paper/6456-multi-view-anomaly-detection-via-robust-probabilistic-latent-variable-models.pdf">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Partial Multi-View Outlier Detection Based on Collective Learning</td>
<td></td>
<td></td>
<td><a href="https://aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/17166">📃Paper</a></td>
</tr>
<tr class="even">
<td>Multi-View Anomaly Detection: Neighborhood in Locality Matters</td>
<td></td>
<td></td>
<td><a href="https://www.aaai.org/ojs/index.php/AAAI/article/view/4418">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Latent Discriminant Subspace Representations for Multi-View Outlier Detection</td>
<td></td>
<td></td>
<td><a href="https://aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/17401">📃Paper</a></td>
</tr>
<tr class="even">
<td>Anomaly Detection with Partially Observed Anomalies</td>
<td></td>
<td></td>
<td><a href="https://dl.acm.org/citation.cfm?id=3184558.3186580">📃Paper</a></td>
</tr>
<tr class="odd">
<td>One-Class Active Learning for Outlier Detection with Multiple Subspaces</td>
<td></td>
<td></td>
<td><a href="https://dl.acm.org/citation.cfm?id=3357873">📃Paper</a></td>
</tr>
<tr class="even">
<td>Statistical Analysis of Nearest Neighbor Methods for Anomaly Detection</td>
<td>NIPS19</td>
<td></td>
<td><a href="http://papers.nips.cc/paper/9274-statistical-analysis-of-nearest-neighbor-methods-for-anomaly-detection">📃Paper</a></td>
</tr>
<tr class="odd">
<td>SNIPER: Few-shot Learning for Anomaly Detection to Minimize False-negative Rate with Ensured True-positive Rate</td>
<td>ICASSP19</td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8683667">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="aevae">AE/VAE</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Estimation of Dimensions Contributing to Detected Anomalies with Variational Autoencoders</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1811.04576">📃Paper</a></td>
</tr>
<tr class="even">
<td>Anomaly Detection with Robust Deep Autoencoders</td>
<td></td>
<td></td>
<td><a href="https://www.kdd.org/kdd2017/papers/view/anomaly-detection-with-robust-deep-auto-encoders">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Complementary Set Variational Autoencoder for Supervised Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8462181">📃Paper</a></td>
</tr>
<tr class="even">
<td>A Two-class Hyper-spherical Autoencoder for Supervised Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8683790">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="gan-1">GAN</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Adversarially Learned Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1812.02288">📃Paper</a></td>
</tr>
<tr class="even">
<td>AMAD: Adversarial Multiscale Anomaly Detection on High-Dimensional and Time-Evolving Categorical Data</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1907.06582">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Adversarially Learned One-Class Classifier for Novelty Detection</td>
<td></td>
<td></td>
<td><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Sabokrou_Adversarially_Learned_One-Class_CVPR_2018_paper.pdf">📃Paper</a> <a href="https://github.com/khalooei/ALOCC-CVPR2018">📥Code</a></td>
</tr>
<tr class="even">
<td>Generative Probabilistic Novelty Detection with Adversarial Autoencoders</td>
<td></td>
<td></td>
<td><a href="https://papers.nips.cc/paper/7915-generative-probabilistic-novelty-detection-with-adversarial-autoencoders.pdf">📃Paper</a> <a href="https://github.com/podgorskiy/GPND">📥Code</a></td>
</tr>
<tr class="odd">
<td>OCGAN: One-class Novelty Detection Using GANs with Constrained Latent Representations</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1903.08550">📃Paper</a></td>
</tr>
<tr class="even">
<td>Fence GAN: Towards Better Anomaly Detection</td>
<td>Arxiv</td>
<td></td>
<td><a href="https://arxiv.org/abs/1904.01209">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Anomaly Detection via Minimum Likelihood Generative Adversarial Networks</td>
<td>Arxiv</td>
<td></td>
<td><a href="https://arxiv.org/abs/1808.00200">📃Paper</a></td>
</tr>
<tr class="even">
<td>DOPING: Generative Data Augmentation for Unsupervised Anomaly Detection with GAN</td>
<td>ICDM18</td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8594955">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Learning Competitive and Discriminative Reconstructions for Anomaly Detection</td>
<td>AAAI19</td>
<td></td>
<td><a href="https://www.aaai.org/ojs/index.php/AAAI/article/view/4451">📃Paper</a></td>
</tr>
</tbody>
</table>
<h3 id="miscellaneous-1">Miscellaneous</h3>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Title</strong></th>
<th><strong>Conf/Journal</strong></th>
<th><strong>Description</strong></th>
<th><strong>Links</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Deep Structured Energy Based Models for Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1605.07717">📃Paper</a></td>
</tr>
<tr class="even">
<td>Anomaly Detection using One-Class Neural Networks</td>
<td></td>
<td></td>
<td><a href="https://arxiv.org/pdf/1802.06360">📃Paper</a> <a href="https://github.com/raghavchalapathy/oc-nn">📥Code</a></td>
</tr>
<tr class="odd">
<td>High-dimensional and large-scale anomaly detection using a linear one-class SVM with deep learning</td>
<td></td>
<td></td>
<td><a href="https://www.sciencedirect.com/science/article/pii/S0031320316300267">📃Paper</a></td>
</tr>
<tr class="even">
<td>Deep Autoencoding Gaussian Mixture Model for Unsupervised Anomaly Detection</td>
<td></td>
<td></td>
<td><a href="https://openreview.net/pdf?id=BJJLHbb0-">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Deep Anomaly Detection with Outlier Exposure</td>
<td></td>
<td></td>
<td><a href="https://openreview.net/forum?id=HyxCxhRcY7">📃Paper</a></td>
</tr>
<tr class="even">
<td>Are Generative Deep Models for Novelty Detection Truly Better?</td>
<td>KDD18 Workshop</td>
<td></td>
<td><a href="https://arxiv.org/abs/1807.05027">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Probabilistic-Mismatch Anomaly Detection: Do one's Medications Match with the Diagnoses?</td>
<td>ICDM16</td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/7837890">📃Paper</a></td>
</tr>
<tr class="even">
<td>Deep Anomaly Detection with Deviation Networks</td>
<td>KDD19</td>
<td></td>
<td><a href="https://dl.acm.org/doi/10.1145/3292500.3330871">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Weakly-supervised Deep Anomaly Detection with Pairwise Relation Learning</td>
<td>AAAI20</td>
<td></td>
<td><a href="https://arxiv.org/abs/1910.13601">📃Paper</a></td>
</tr>
<tr class="even">
<td>Transfer Anomaly Detection by Inferring Latent Domain Representations</td>
<td>NIPS19</td>
<td></td>
<td><a href="http://papers.nips.cc/paper/8517-transfer-anomaly-detection-by-inferring-latent-domain-representations">📃Paper</a></td>
</tr>
<tr class="odd">
<td>Multi-view Anomaly Detection via Robust Probabilistic Latent Variable Models</td>
<td>NIPS16</td>
<td></td>
<td><a href="http://papers.nips.cc/paper/6456-multi-view-anomaly-detection-via-robust-probabilistic-latent-variable-models">📃Paper</a></td>
</tr>
<tr class="even">
<td>Continual Learning for Anomaly Detection with Variational Autoencoder</td>
<td>ICASSP19</td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8682702">📃Paper</a></td>
</tr>
<tr class="odd">
<td>AdaFlow: Domain-adaptive Density Estimator with Application to Anomaly Detection and Unpaired Cross-domain Translation</td>
<td>ICASSP19</td>
<td></td>
<td><a href="https://ieeexplore.ieee.org/document/8683072">📃Paper</a></td>
</tr>
</tbody>
</table>
<h2 id="graph">Graph</h2>
<ul>
<li><em>AddGraph: Anomaly Detection in Dynamic Graph Using Attention-based Temporal GCN</em> <a href="https://www.ijcai.org/proceedings/2019/614">[Paper]</a></li>
<li><em>Outlier Detection in Graph Streams</em> <a href="https://ieeexplore.ieee.org/document/5767885">[Paper]</a></li>
<li><em>NetWalk: A Flexible Deep Embedding Approach for Anomaly Detection in Dynamic Networks</em> <a href="https://www.kdd.org/kdd2018/accepted-papers/view/netwalk-a-flexible-deep-embedding-approach-for-anomaly-detection-in-dynamic">[Paper]</a></li>
<li><em>Anomaly Detection in Dynamic Networks using Multi-view Time-Series Hypersphere Learning</em> <a href="https://dl.acm.org/citation.cfm?id=3132964">[Paper]</a></li>
</ul>
<h1 id="related">Related</h1>
<p>这一部分主要是一些非异常检测文章，但是可以用来解决异常检测中的问题的相关文章。</p>
<h2 id="infrastructure">Infrastructure</h2>
<h3 id="gan-2">GAN</h3>
<ul>
<li><em>Generative Adversarial Networks</em> <a href="https://arxiv.org/abs/1406.2661">[Paper]</a></li>
</ul>
<h4 id="vae-gan-combination">VAE &amp; GAN Combination</h4>
<ul>
<li><em>Variational Approaches for Auto-Encoding Generative Adversarial Networks</em> <a href="https://arxiv.org/abs/1706.04987">[Paper]</a></li>
<li><em>Adversarial Variational Bayes: Unifying Variational Autoencoders and Generative Adversarial Networks</em> <a href="https://arxiv.org/abs/1701.04722">[Paper]</a></li>
<li><em>On Unifying Deep Generative Models</em> <a href="https://arxiv.org/abs/1706.00550">[Paper]</a></li>
</ul>
<h4 id="bidirectional-gans">Bidirectional GANs</h4>
<ul>
<li><em>Adversarial Feature Learning</em> <a href="Adversarial%20Feature%20Learning">[Paper]</a></li>
<li><em>Adversarially Learned Inference</em> <a href="https://arxiv.org/abs/1606.00704">[Paper]</a></li>
<li><em>It Takes (Only) Two: Adversarial Generator-Encoder Networks</em> <a href="https://arxiv.org/abs/1704.02304">[Paper]</a></li>
</ul>
<h3 id="vae-1">VAE</h3>
<ul>
<li><em>Auto-Encoding Variational Bayes</em> <a href="https://arxiv.org/abs/1312.6114">[Paper]</a></li>
</ul>
<h2 id="class-imbalance">Class Imbalance</h2>
<ul>
<li><em>Focal Loss for Dense Object Detection</em> <a href="https://arxiv.org/abs/1708.02002">[Paper]</a></li>
<li><em>Gradient Harmonized Single-stage Detector</em> <a href="https://arxiv.org/abs/1811.05181">[Paper]</a></li>
</ul>
<h2 id="stochastic-temporal-modeling">Stochastic Temporal Modeling</h2>
<ul>
<li><em>Sequential Neural Models with Stochastic Layers</em> <a href="https://arxiv.org/abs/1605.07571">[Paper]</a></li>
<li><em>A Recurrent Latent Variable Model for Sequential Data</em> <a href="https://papers.nips.cc/paper/5653-a-recurrent-latent-variable-model-for-sequential-data">[Paper]</a></li>
<li><em>Deep State Space Models for Time Series Forecasting</em> <a href="https://papers.nips.cc/paper/8004-deep-state-space-models-for-time-series-forecasting">[Paper]</a></li>
<li><em>Bayesian Recurrent Neural Networks</em> <a href="https://arxiv.org/abs/1704.02798">[Paper]</a></li>
</ul>
<h2 id="detection-without-closed-form-likelihood">Detection without Closed-form Likelihood</h2>
<h3 id="reconstruction">Reconstruction</h3>
<ul>
<li><em>Adversarially Learned One-Class Classifier for Novelty Detection</em> <a href="https://arxiv.org/abs/1802.09088">[Paper]</a></li>
<li><em>Generative Adversarial Network Based Novelty Detection Using Minimized Reconstruction Error</em> <a href="https://link.springer.com/article/10.1631/FITEE.1700786">[Paper]</a></li>
<li><em>Learning Discriminative Reconstructions for Unsupervised Outlier Removal</em> <a href="https://ieeexplore.ieee.org/document/7410534">[Paper]</a></li>
</ul>
<h3 id="discriminator">Discriminator</h3>
<ul>
<li><em>A Lipschitz-constrained Anomaly Discriminator Framework</em> <a href="https://arxiv.org/abs/1905.10710">[Paper]</a></li>
</ul>
<h3 id="out-of-distribution">Out-of-distribution</h3>
<ul>
<li><em>Enhancing The Reliability of Out-of-distribution Image Detection in Neural Networks</em> <a href="https://arxiv.org/abs/1706.02690">[Paper]</a></li>
<li><em>Learning Confidence for Out-of-Distribution Detection in Neural Networks</em> <a href="https://arxiv.org/abs/1802.04865">[Paper]</a></li>
<li><em>A Baseline for Detecting Misclassified and Out-of-Distribution Examples in Neural Networks</em> <a href="https://arxiv.org/abs/1610.02136">[Paper]</a></li>
<li><em>A Simple Unified Framework for Detecting Out-of-Distribution Samples and Adversarial Attacks</em> <a href="https://arxiv.org/abs/1807.03888">[Paper]</a></li>
</ul>
<h2 id="gans-for-incomplete-data">GANs for Incomplete Data</h2>
<ul>
<li><em>AmbientGAN: Generative Models From Lossy Measurements</em> <a href="https://openreview.net/forum?id=Hy7fDog0b">[Paper]</a></li>
<li><em>MisGAN: Learning from Incomplete Data with Generative Adversarial Networks</em> <a href="https://openreview.net/forum?id=S1lDV3RcKm">[Paper]</a></li>
</ul>
<h1 id="dataset">Dataset</h1>
<p>详见http://qfxiao.me/2020/02/03/Datasets-for-Time-Series-Anomaly-Detection/。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/01/06/Unsupervised-Anomaly-Detection-for-Intricate-KPIs-via-Adversarial-Training-of-VAE/"><img class="thumbnail" src="http://qfxiao.me/img/image-20200106141915707.png" alt="Unsupervised Anomaly Detection for Intricate KPIs via Adversarial Training of VAE"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-06T05:09:32.000Z" title="2020-01-06T05:09:32.000Z">2020-01-06</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></span><span class="level-item">18 分钟 读完 (大约 2770 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/06/Unsupervised-Anomaly-Detection-for-Intricate-KPIs-via-Adversarial-Training-of-VAE/">Unsupervised Anomaly Detection for Intricate KPIs via Adversarial Training of VAE</a></h1><div class="content"><h1 id="introduction">Introduction</h1>
<p><a href="https://ieeexplore.ieee.org/abstract/document/8737430/">论文📃</a></p>
<p><a href="https://github.com/yantijin/Buzz">代码📥</a></p>
<p>本文介绍了一种利用对抗训练来进行时间序列异常检测的方法<em>Buzz</em>。作者认为在现实中复杂的KPI数据大量存在，这种数据通常带有非高斯分布的噪声，同时数据分布复杂，导致一般的生成式模型无法对数据进行很好的建模，所以作者提出了基于对抗训练的模型。在文中，作者的创新点主要有三个：</p>
<ol type="1">
<li>为了处理复杂数据，将数据空间分为多个子空间，在每个子空间上进行距离的度量；</li>
<li>采用<em>Wasserstein</em>距离度量模型建模的分布和真实分布之间的距离；</li>
<li>建立了基于对抗训练的<em>Buzz</em>的损失函数和VAE之间的关系。</li>
</ol>
<p><img src="http://qfxiao.me/img/image-20200106141915707.png" /></p>
<h1 id="background">Background</h1>
<h2 id="anomaly-detection">Anomaly Detection</h2>
<p>对于任意时间<span class="math inline">\(t\)</span>，给定历史观察值<span class="math inline">\(x_{t-T+1},\cdots,x_t\)</span>，确定异常是否发生(记为<span class="math inline">\(y_t=1\)</span>)。通常来收异常检测算法给出的是发生异常的可能性，如<span class="math inline">\(p(y_t=1|x_{t-T+1},\cdots,x_t)\)</span>。</p>
<h2 id="vae">VAE</h2>
<table>
<thead>
<tr class="header">
<th><strong>Model</strong></th>
<th><strong>Latent</strong></th>
<th><strong>Data</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><em>Auto-encoder (AE)</em></strong></td>
<td><code>None</code></td>
<td><code>L1Loss</code></td>
</tr>
<tr class="even">
<td><strong><em>Variational Auto-encoder (VAE)</em></strong></td>
<td><code>KL Divergence</code></td>
<td><code>Log Likelihood</code></td>
</tr>
<tr class="odd">
<td><strong><em>Adversarial Auto-encoder (AAE)</em></strong></td>
<td><code>Discriminator</code></td>
<td><code>L1Loss</code></td>
</tr>
<tr class="even">
<td><strong><em>Wasserstein Auto-encoder (WAE)</em></strong></td>
<td><code>MaxMeanDiscrepancy</code> or <code>Discriminator</code></td>
<td><code>L1Loss</code></td>
</tr>
<tr class="odd">
<td><strong><em>AlphaGAN</em></strong></td>
<td><code>Discriminator</code></td>
<td><code>Discriminator</code>+<code>L1Loss</code></td>
</tr>
</tbody>
</table>
<h2 id="gan-and-wgan-gp">GAN and WGAN-GP</h2>
<p>原始GAN等价于优化： <span class="math display">\[
\mathbb{E}_{x\sim P_r}\log{\frac{P_r(x)}{\frac{1}{2}\left[P_r(x)+P_g(x)\right]}}+\mathbb{E}_{x\sim P_g}\log{\frac{P_g(x)}{\frac{1}{2}\left[P_r(x)+P_g(x)\right]}}
\]</span> 根据KL散度和JS散度的定义： <span class="math display">\[
\text{KL}(P_1\parallel P_2)=\mathbb{E}_{x\sim P_1}\log{\frac{P_1}{P_2}}
\]</span></p>
<p><span class="math display">\[
\text{JS}(P_1\parallel P_2)=\frac{1}{2}\text{KL}(P_1\parallel \frac{P_1+P_2}{2})+\frac{1}{2}\text{KL}(P_2\parallel \frac{P_1+P_2}{2})
\]</span></p>
<p>可重写为： <span class="math display">\[
2\text{JS}(P_r\parallel P_g)-2\log 2
\]</span> 当<span class="math inline">\(P_r\)</span>与<span class="math inline">\(P_g\)</span>的支撑集（support）是高维空间中的低维流形（manifold）时，<span class="math inline">\(P_r\)</span>与<span class="math inline">\(P_g\)</span>重叠部分测度（measure）为0的概率为1。</p>
<ul>
<li>支撑集（support）其实就是函数的非零部分子集，比如<code>ReLU</code>函数的支撑集就是[公式]，一个概率分布的支撑集就是所有概率密度非零部分的集合。</li>
<li>流形（manifold）是高维空间中曲线、曲面概念的拓广，我们可以在低维上直观理解这个概念，比如我们说三维空间中的一个曲面是一个二维流形，因为它的本质维度（intrinsic dimension）只有2，一个点在这个二维流形上移动只有两个方向的自由度。同理，三维空间或者二维空间中的一条曲线都是一个一维流形。</li>
<li>测度（measure）是高维空间中长度、面积、体积概念的拓广，可以理解为“超体积”。</li>
</ul>
<p><em>Wasserstein</em>距离定义如下： <span class="math display">\[
W(P_r,P_g)=\inf\limits_{\gamma\sim\prod(P_r,P_g)}\mathbb{E}_{(x,y)\sim \gamma}\left[\parallel x-y\parallel\right]
\]</span> 下确界<span class="math inline">\(\inf\)</span>没法直接求解，不过根据相关定理其等价于： <span class="math display">\[
W(P_r,P_g)=\frac{1}{K}\sup\limits_{\parallel f\parallel_L\leq K}\mathbb{E}_{x\sim P_r}[f(x)]-\mathbb{E}_{x\sim P_g}[f(x)]
\]</span> <em>Lipschitz</em>连续是指存在一个常数<span class="math inline">\(K\geq 0\)</span>使得定义域内任意两个元素<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>都满足： <span class="math display">\[
|f(x_1)-f(x_2)|\leq K|x_1-x_2|
\]</span> WAN的损失函数： <span class="math display">\[
\mathcal{L}=\mathop{\mathbb{E}}\limits_{\mathbf{x}\sim\mathbb{P}_g}\left[D({\mathbf{x}})\right]-\mathop{\mathbb{E}}\limits_{\mathbf{x}\sim\mathbb{P}_r}\left[D(\mathbf{x})\right]
\]</span> WGAN-GP的损失函数为： <span class="math display">\[
\mathcal{L}=\mathop{\mathbb{E}}\limits_{\tilde{\mathbf{x}}\sim\mathbb{P}_g}\left[D(\tilde{\mathbf{x}})\right]-\mathop{\mathbb{E}}\limits_{\mathbf{x}\sim\mathbb{P}_r}\left[D(\mathbf{x})\right] + \lambda\mathop{\mathbb{E}}\limits_{\hat{\mathbf{x}}\sim\mathbb{P}_{\hat{\mathbf{x}}}}\left[(\parallel\nabla_{\hat{\mathbf{x}}}D(\hat{\mathbf{x}})\parallel_2-1)^2\right]
\]</span></p>
<h1 id="proposed-method">Proposed Method</h1>
<p>下图为<em>Buzz</em>的总体流程：</p>
<p><img src="http://qfxiao.me/img/image-20200106141958376.png" /></p>
<p>数据会首先进行一些预处理，之后进行训练。在检测阶段会根据异常分数来判定异常。</p>
<h2 id="motivation">Motivation</h2>
<p>在文中，最关键的两个创新点分别是<em>Wasserstein</em>距离和对数据分布进行分区的方法。</p>
<ul>
<li><p>在使用距离度量方面， 因为<em>Wasserstein</em>在WGAN中取得了很好的效果，是一种鲁棒的距离度量，所以作者在文中采用了<em>Wasserstein</em>距离来衡量生成的分布和真实的分布之间的距离，并由此引入了对抗训练；</p></li>
<li><p>在分区方法方面，作者认为原始数据过于复杂，所以将数据空间<span class="math inline">\(\mathcal{X}\)</span>进行划分，然后在每个子空间上使用<em>Wasserstein</em>度量距离，而总体的距离由每个分区的距离的期望求得。</p></li>
</ul>
<p>作者还发现，当划分地越来越细时，总体距离接近于特定形式的VAE的重构误差项。</p>
<p><img src="http://qfxiao.me/img/image-20200106142008894.png" /></p>
<h2 id="network-structure">Network Structure</h2>
<p>下图为模型的网络结构：</p>
<p><img src="http://qfxiao.me/img/image-20200106142018827.png" /></p>
<h2 id="training">Training</h2>
<h3 id="objective-function">Objective Function</h3>
<p>先定义一些符号：</p>
<ul>
<li><span class="math inline">\(b\)</span>和<span class="math inline">\(s\)</span>分别为Batch的大小和邻居的大小，数据集按<span class="math inline">\(s\)</span>进行切分，然后随机打乱，每个Batch包含<span class="math inline">\(b\)</span>个<span class="math inline">\(s\)</span>，之后<span class="math inline">\(s/=2,b*=2\)</span>；</li>
<li><span class="math inline">\(\mathcal{W}=\{w_1,w_2,\cdots,w_b\}\)</span>为一个Batch，且满足每个<span class="math inline">\(w_i\)</span>是<span class="math inline">\(s\)</span>的倍数；</li>
<li><span class="math inline">\(w\in\mathcal{W}\)</span>的邻域集(neighborhood set)为一个时间上的partition，记为<span class="math inline">\(\{w,w+1,\cdots,w+s-1\}\)</span></li>
<li><span class="math inline">\(\mathbf{x}^{(w)},\mathbf{x}^{(w+1)},\cdots,\mathbf{x}^{(w+s-1)}\)</span>为在空间<span class="math inline">\(\mathcal{X}\)</span>上的一个partition，记为<span class="math inline">\(S_w\)</span>，其中<span class="math inline">\(\mathbf{x}^{(w)}\)</span>表示以<span class="math inline">\(w\)</span>为结尾的时间窗口。</li>
</ul>
<p><em>Buzz</em>的损失函数和WGAN-GP类似，但做了一些改进，由下面四部分组成，下面分别解释。</p>
<p>第一个是每一个partition的<span class="math inline">\(\mathbf{z}\)</span>后验的KL散度： <span class="math display">\[
\mathcal{K} = \frac{1}{bs}\sum\limits_{w\in\mathcal{W}}\sum\limits_{i=1}^{s-1}\text{KL}\left[q_\phi(\mathbf{z}|\mathbf{x})\parallel\mathcal{N}(\mathbf{0},\mathbf{1})\right]
\]</span></p>
<p>第二个在训练时是一个常数： <span class="math display">\[
Z(\lambda) = \frac{\Gamma(W)}{\Gamma(\frac{W}{2})}2\pi^{\frac{W}{2}}\lambda^{-W}
\]</span></p>
<p>其中<span class="math inline">\(\Gamma\)</span>是<em>Gamma</em>函数。</p>
<p>第三个是<em>Wasserstein</em>距离： <span class="math display">\[
\mathcal{T}(F,w)=\frac{1}{bs}\sum\limits_{i=1}^{s-1}\mathbb{E}_{q_\phi(\mathbf{z}|\mathbf{x}^{w+i})}\left[F(\mathbf{x}^{(w+i)})-F(G(\mathbf{z}))\right]
\]</span></p>
<p>第四个是<em>Gradient Penalty</em>：</p>
<p><span class="math display">\[
\mathcal{R}(F,w)=\frac{1}{bs}\sum\limits_{i=1}^{s-1}\mathbb{E}_{q_\phi(\mathbf{z}|\mathbf{x}^{(w+i)})}\left[\mathbb{E}_{\varepsilon\sim[0,1]}(\parallel\nabla_{\hat{\mathbf{x}}}(\hat{\mathbf{x}})\parallel-\mathbf{1})^2\right]
\]</span></p>
<p>其中<span class="math inline">\(\hat{\mathbf{x}}=\varepsilon \mathbf{x}^{w+i}+(1-\varepsilon)G(\mathbf{z})\)</span>为生成数据与真实数据的插值。</p>
<blockquote>
<p>原始的WGAN-GP的损失函数为： <span class="math display">\[
L=\mathop{\mathbb{E}}\limits_{\tilde{\mathbf{x}}\sim\mathbb{P}_g}\left[D(\tilde{\mathbf{x}})\right]-\mathop{\mathbb{E}}\limits_{\mathbf{x}\sim\mathbb{P}_r}\left[D(\mathbf{x})\right] + \lambda\mathop{\mathbb{E}}\limits_{\hat{\mathbf{x}}\sim\mathbb{P}_{\hat{\mathbf{x}}}}\left[(\parallel\nabla_{\hat{\mathbf{x}}}D(\hat{\mathbf{x}})\parallel_2-1)^2\right]
\]</span> 其中<span class="math inline">\(\mathbb{P}_g\)</span>为生成器的分布，<span class="math inline">\(\mathbb{P}_r\)</span>为真实分布，<span class="math inline">\(\mathbb{P}_{\hat{\mathbf{x}}}\)</span>为真实数据和生成数据插值得到的分布。</p>
</blockquote>
<p><span class="math display">\[
\hat{\mathcal{L}}_{Buzz}=-\lambda\sup\limits_F\left[\sum\limits_{w\in\mathcal{W}}(\left|\mathcal{T}(F,w)\right|-\eta\mathcal{R}(F,w))\right]-\mathcal{K}-\log Z(\lambda)
\]</span></p>
<h3 id="training-procedure">Training Procedure</h3>
<p><em>Buzz</em>的训练过程与WGAN-GP类似，</p>
<h2 id="detection">Detection</h2>
<p>文中假设解码器的输出服从如下分布：</p>
<p><span class="math display">\[
p_\theta(\mathbf{x}|\mathbf{z})=\frac{1}{Z(\lambda)}\exp\{-\lambda\parallel\mathbf{x}-G(\mathbf{z})\parallel\}
\]</span></p>
<p>作者定义异常分数为： <span class="math display">\[
\mathcal{S}=\log p_\theta(\mathbf{x})-\log p_\theta(\bar{\mathbf{x}})
\]</span> 其中<span class="math inline">\(\bar{\mathbf{x}}\)</span>为经过MCMC填充后的样本。</p>
<p>异常分数也可以展开为： <span class="math display">\[
\log\frac{1}{L}\sum\limits_{l=1}^L\left[\frac{p_\theta(\mathbf{x}|\mathbf{z^{(l)}})p_\theta(\mathbf{z}^{(l)})}{q_\phi(\mathbf{z}^{(l)}|\bar{\mathbf{x}})}\right]-\log\frac{1}{L}\sum\limits_{l=1}^L\left[\frac{p_\theta(\bar{\mathbf{x}}|\mathbf{z}^{(l)})p_\theta(\mathbf{z}^{(l)})}{q_\phi(\mathbf{z}^{(l)}|\bar{\mathbf{x}})}\right]
\]</span></p>
<p>最终算法流程图为：</p>
<p><img src="http://qfxiao.me/img/image-20200106142053342.png" /></p>
<h2 id="theoretical-analysis">Theoretical Analysis</h2>
<p>在理论分析中，作者主要是想建立<span class="math inline">\(\mathcal{L}_{Buzz}\)</span>和VAE的损失函数<span class="math inline">\(\mathcal{L}_{vae}\)</span>之间的联系，损失函数<span class="math inline">\(\mathcal{\hat{L}}_{Buzz}\)</span>为：</p>
<p><span class="math display">\[
\hat{\mathcal{L}}_{Buzz}=-\lambda\sup\limits_F\left[\sum\limits_{w\in\mathcal{W}}(\left|\mathcal{T}(F,w)\right|-\eta\mathcal{R}(F,w))\right]-\mathcal{K}-\log Z(\lambda)
\]</span></p>
<p>为了便于分析，去掉<em>Gradient Penalty</em>的部分，公式可简化为：</p>
<p><span class="math display">\[
\mathcal{L}_{Buzz}=-\lambda\mathbb{E}_{p(w)}W^1\left[P(\mathbf{x}|w)\parallel P(\mathbf{y}|w)\right]-\mathcal{K}-\log Z(\lambda)
\]</span></p>
<p>实际上<span class="math inline">\(Z(\lambda)=\mathfrak{S}_W\Gamma(W)\lambda^{-W}\)</span>，其中<span class="math inline">\(\mathfrak{S}_W\)</span>为<span class="math inline">\(W\)</span>维单位球的表面积。</p>
<blockquote>
<p><span class="math inline">\(n\)</span>维空间单位球表面积公式： <span class="math display">\[
\omega_n=\frac{2\pi^{\frac{n}{2}}}{\Gamma(\frac{n}{2})}
\]</span></p>
</blockquote>
<p>而<span class="math inline">\(W^1\left[P(\mathbf{x}|w)\parallel P(\mathbf{y}|w)\right]\)</span>为<em>Wasserstein</em>距离： <span class="math display">\[
W^1\left[P(\mathbf{x}|w)\parallel P(\mathbf{y}|w)\right]=\sup\limits_{Lip(f)\leq 1}\left\{\int_\mathcal{X}f(\mathbf{x})p(\mathbf{x}|w)\mathrm{d}\mathbf{x}-\int_\mathcal{X}f(\mathbf{y})p(\mathbf{y}|w)\mathrm{d}\mathbf{y}\right\}
\]</span></p>
<h3 id="lemma-1">Lemma 1</h3>
<p>通过设定具体形式的后验分布，VAE的损失函数可以写为：</p>
<blockquote>
<p>设<span class="math inline">\(\mathbf{x}\)</span>的后验分布<span class="math inline">\(p(\mathbf{x}|\mathbf{z})=\frac{1}{Z(\lambda)}\exp\{-\lambda\parallel\mathbf{x}-G(\mathbf{z})\parallel\}\)</span>，那么VAE的损失函数为： <span class="math display">\[
\mathcal{L}_{vae}=\lambda\mathbb{E}_{p(w)}\left[\mathbb{E}_{p(\mathbf{x}|w)}\mathbb{E}_{p_G(\mathbf{y}|\mathbf{x})}-\parallel\mathbf{x}-\mathbf{y}\parallel\right]-\mathcal{K}-\log{Z(\lambda)}
\]</span></p>
</blockquote>
<p>后验分布实际上是一个Laplace分布：</p>
<blockquote>
<p><strong>Laplace Distribution</strong>: <span class="math display">\[
f(x|\theta,\lambda)=\frac{1}{2\lambda}\exp{\left(-\frac{|x-\theta|}{\lambda}\right)}
\]</span></p>
</blockquote>
<p>可以直接把后验分布带入VAE的损失函数就得到了。</p>
<h3 id="lemma-2">Lemma 2</h3>
<p><span class="math inline">\(S_w\)</span>定义为数据空间<span class="math inline">\(\mathcal{X}\)</span>的一个partition，而<span class="math inline">\(S=\{(\mathbf{x}_1,\mathbf{x}_2)|\exist w, \mathbf{x}_1\in S_w,\mathbf{x}_2\in S_w\}\)</span>。</p>
<blockquote>
<p>当<span class="math inline">\(G,\phi,\lambda\)</span>固定时，<span class="math inline">\(S\downarrow\)</span>有<span class="math inline">\(\mathcal{L}_{Buzz}\downarrow\)</span></p>
</blockquote>
<h3 id="lemma-3">Lemma 3</h3>
<blockquote>
<p><span class="math inline">\(\max\mathcal{L}_{Buzz}\geq\max{\mathcal{L}_{vae}}\)</span>，同时，当<span class="math inline">\(S\downarrow\text{diag}{\mathcal{X}}\)</span>时<span class="math inline">\(\max\mathcal{L}_{Buzz}\downarrow\max\mathcal{L}_{vae}\)</span></p>
</blockquote>
<p><img src="http://qfxiao.me/img/image-20200106183833975.png" /></p>
<h3 id="lemma-4">Lemma 4</h3>
<blockquote>
<p>令<span class="math inline">\(p^\prime_G(\mathbf{y}|\mathbf{x})\)</span>表示<span class="math inline">\(\mathbb{E}_{q_{\phi^\prime}}\left[p_G(\mathbf{y}|\mathbf{z})\right]\)</span>。如果<span class="math inline">\((G,\phi,\lambda)\)</span>是一个解，那么存在<span class="math inline">\((G,\phi^\prime,\lambda)\)</span>使得： <span class="math display">\[
\mathbb{E}_{p(\mathbf{x}|w)}\mathbb{E}_{p_G^\prime(\mathbf{y}|\mathbf{x})}\parallel\mathbf{x}-\mathbf{y}\parallel=W^1\left[P(\mathbf{x}|w)\parallel P_G(\mathbf{y}|w)\right]
\]</span> 此时<span class="math inline">\(\mathcal{L}_{Buzz}-\mathcal{L}_{vae}^\prime=\mathcal{K}^\prime-\mathcal{K}\)</span>，其中<span class="math inline">\(\mathcal{L}^\prime,\mathcal{K}^\prime\)</span>分别为<span class="math inline">\((G,\phi^\prime,\lambda)\)</span>时的<span class="math inline">\(\mathcal{L}\)</span>和<span class="math inline">\(\mathcal{K}\)</span>。</p>
</blockquote>
<p><span class="math display">\[
\mathcal{L}^\dagger_{Buzz}=\mathbb{E}_{p(\mathbf{x})}\left[\mathbb{E}_{q_{\phi^\prime}(\mathbf{z}|\mathbf{x})}\log_{p_\theta}(\mathbf{x}|\mathbf{z})\right]-\min\limits_{\bar{\phi}\sim\phi^\prime}\bar{\mathcal{K}}
\]</span></p>
<h3 id="lemma-5">Lemma 5</h3>
<p>这里主要是想证明</p>
<blockquote>
<p>对于固定的<span class="math inline">\(w\)</span>，令： <span class="math display">\[
\mathcal{F}=\{f|Lip(f)\leq 1\}, \space \mathcal{F}^*=\left\{f|_{S_w}\bigg|Lip(f|_{S_w})\leq 1\right\}
\]</span> 有<span class="math inline">\(\sup_{f\in\mathcal{F}}\mathcal{T}(f)=\sup_{f|_{S_w}\in\mathcal{F}^*}\mathcal{T}^*\left(f|_{S_w}\right)\)</span>。</p>
</blockquote>
<h3 id="theorem-6">Theorem 6</h3>
<blockquote>
<p><span class="math inline">\(\mathcal{L}_{Buzz}\)</span>的对偶形式为： <span class="math display">\[
\mathcal{L}_{Buzz}=-\lambda\sup\limits_{Lip(F;S)\leq 1}\mathbb{E}_{p(w)}\mathcal{T}^*(F)-\mathcal{K}-\log Z(\lambda)
\]</span></p>
</blockquote>
<p>近似的<span class="math inline">\(\mathcal{L}_{Buzz}\)</span>的对偶形式为： <span class="math display">\[
\bar{\mathcal{L}}_{Buzz}=-\lambda\sup\limits_{Lip(F;S)\leq 1}\mathbb{E}_{p(w)}\mathcal{T}(F)-\mathcal{K}-\log Z(\lambda)
\]</span></p>
<h1 id="experiment">Experiment</h1>
<p><img src="http://qfxiao.me/img/image-20200106142131500.png" /></p>
<p><img src="http://qfxiao.me/img/image-20200106142155978.png" /></p>
<p><img src="http://qfxiao.me/img/image-20200106142212110.png" /></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/11/02/Variational-Approaches-for-Auto-Encoding-Generative-Adversarial-Networks/"><img class="thumbnail" src="http://qfxiao.me/img/image-20191102233101258.png" alt="Variational Approaches for Auto-Encoding Generative Adversarial Networks"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-02T15:28:53.000Z" title="2019-11-02T15:28:53.000Z">2019-11-02</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/GAN/">GAN</a></span><span class="level-item">18 分钟 读完 (大约 2774 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/02/Variational-Approaches-for-Auto-Encoding-Generative-Adversarial-Networks/">Variational Approaches for Auto-Encoding Generative Adversarial Networks</a></h1><div class="content"><h1 id="abstract">Abstract</h1>
<p>本文揭示了对抗生成网络（Generative Adversarial Networks, GAN）和变分自编码器（Variational Auto-encoders, VAE）之间的联系，并据此提出了一种将两者结合的新模型。文中主要是将不可解的似然函数和未知的后验分布用一个非确定的分布（Immplicit Distribution）替代，并加入判别器来使得该分布逼近真实的分布。通过这个方法，作者将VAE中的损失函数进行了替换，变成了GAN中的“生成-判别”模式。</p>
<p><a href="https://arxiv.org/abs/1706.04987">原文</a></p>
<h1 id="contribution">Contribution</h1>
<p>本文有如下贡献：</p>
<ul>
<li>本文提出变分推断（Variational Inference）也能通过对非确定分布的估计应用在GAN中；</li>
<li>基于似然的模型（Likelihood-based Models）和非似然模型（Likelihood-free Models）能够通过对抗学习结合起来；</li>
<li>作者根据文中提出的新观点修改了VAE的损失函数，将其称之为Auto-encoding GAN (<span class="math inline">\(\alpha\)</span>-GAN)，并提出了对应的实用的改进；</li>
<li>本文与众多State-of-Art模型进行了对比</li>
</ul>
<h1 id="methodology">Methodology</h1>
<h2 id="overcoming-intractability-in-generative-models">Overcoming Intractability in Generative Models</h2>
<h3 id="latent-variable-models">Latent Variable Models</h3>
<p>隐变量模型通过隐变量的形式描述了数据的产生过程。最简单的形式是假设隐变量<span class="math inline">\(\mathbf{z}\)</span>服从一个先验分布<span class="math inline">\(\mathbf{z}\sim p(\mathbf{z})\)</span>，而数据<span class="math inline">\(\mathbf{x}\)</span>从条件分布<span class="math inline">\(p(\mathbf{x}|\mathbf{z})\)</span>抽样产生。通常来说描述<span class="math inline">\(p(\mathbf{x}|\mathbf{z})\)</span>的模型称为生成器<span class="math inline">\(\mathcal{G}_\theta(\mathbf{z})\)</span>，带有可优化的参数<span class="math inline">\(\theta\)</span>，而<span class="math inline">\(\mathbf{z}\)</span>通常假设为正态分布<span class="math inline">\(\mathbf{z}\sim\mathcal{N}(\mathbf{0},\mathbf{I})\)</span>。</p>
<p>文中区分了两种隐变量模型，一种是<em>Implicit Latent Variable Models</em>，一种是<em>Prescribed Latent Variable Models</em>。文中的描述不太清楚，个人认为两者的区别是前者图模型中的<span class="math inline">\(\mathbf{x}\)</span>不是一个随机变量，在优化的时候需要用一个刻画生成的<span class="math inline">\(\mathbf{x}\)</span>和真实的<span class="math inline">\(\mathbf{x}\)</span>的差别的函数<span class="math inline">\(\delta(\mathbf{x}-\mathcal{G}_\theta(\mathbf{z}))\)</span>，而后者图模型中<span class="math inline">\(\mathbf{x}\)</span>是一个随机变量，这样可以写出似然函数用极大似然估计。</p>
<p>无论是GAN还是VAE都需要通过边缘分布<span class="math inline">\(p_\theta(\mathbf{x})\)</span>来刻画建模的好坏，比如说根据<span class="math inline">\(p_\theta(\mathbf{x})\)</span>与真实分布<span class="math inline">\(p^*_\theta(\mathbf{x})\)</span>之间的KL散度<span class="math inline">\(\text{KL}\left[p_\theta(\mathbf{x})\parallel p_\theta^*(\mathbf{x})\right]\)</span>。但通常情况下<span class="math inline">\(p_\theta(\mathbf{x})\)</span>都是不可解的，而GAN和VAE通过不同的途径解决了这个问题。</p>
<h3 id="generative-adversarial-networks">Generative Adversarial Networks</h3>
<p>GAN没有直接计算<span class="math inline">\(p_\theta(\mathbf{x})\)</span>，而是使用了一个判别器来判别样本是从<span class="math inline">\(p_\theta(\mathbf{x})\)</span>还是<span class="math inline">\(p_\theta^*(\mathbf{x})\)</span>采样得到的，如果判别器无法进行区分，那我们认为此时<span class="math inline">\(p_\theta(\mathbf{x})\approx p_\theta^*(\mathbf{x})\)</span>。</p>
<p>令随机变量<span class="math inline">\(y\in\{0,1\}\)</span>，<span class="math inline">\(y=1\)</span>表示样本<span class="math inline">\(\mathbf{x}\)</span>来自真实分布，<span class="math inline">\(y=0\)</span>表示样本<span class="math inline">\(\mathbf{x}\)</span>来自生成分布，而判别器的输出为<span class="math inline">\(\mathbf{x}\)</span>来自真实分布的概率<span class="math inline">\(\mathcal{D}_\phi(\mathbf{x})=p(y=1|\mathbf{x})\)</span>。GAN通过对来自真实分布和生成分布的样本求二元交叉熵来作为判别器损失函数： <span class="math display">\[
\textbf{Discriminator Loss: }\mathbb{E}_{p^*(\mathbf{x})}[-\log\mathcal{D}_\phi(\mathbf{x})]+\mathbb{E}_{p_\theta(\mathbf{x})}[-\log(1-\mathcal{D}_\phi(\mathbf{x}))]
\]</span></p>
<p>生成器将最大化判别器对生成样本判定为真的概率作为损失函数，同时还有一个等价的但在实践中表现更好的替代版本：</p>
<p><span class="math display">\[
\textbf{Generator Loss: }\mathbb{E}_{p_\theta(\mathbf{x})}[\log(1-\mathcal{D}_\phi(\mathbf{x}))];\textbf{ Alternative Loss: }\mathbf{E}_{p_\theta(\mathbf{x})}[-\log\mathcal{D}_\phi(\mathbf{x})]
\]</span></p>
<h3 id="the-density-ratio-trick">The Density Ratio Trick</h3>
<p>令<span class="math inline">\(p^*(\mathbf{x})=p(\mathbf{x}|y=1)\)</span>，<span class="math inline">\(p_\theta(\mathbf{x})=p(\mathbf{x}|y=0)\)</span>。定义<em>Density Ratio</em> <span class="math inline">\(r_\phi(\mathbf{x})\)</span>为真实分布和生成分布之间的比例：</p>
<p><span class="math display">\[
r_\phi(\mathbf{x})=\frac{p^*(\mathbf{x})}{p_\theta(\mathbf{x})}=\frac{p(\mathbf{x}|y=1)}{p(\mathbf{x}|y=0)}=\frac{p(y=1|\mathbf{x})}{p(y=0|\mathbf{x})}=\frac{\mathcal{D}_\phi(\mathbf{x})}{1-\mathcal{D}_\phi(\mathbf{x})}
\]</span></p>
<p>上式表明了<em>Density Ratio</em>的计算可以仅通过从两个分布上采样得到的样本加上一个二分类器<span class="math inline">\(\mathcal{D}_\phi(\mathbf{x})\)</span>实现（假设<span class="math inline">\(p(y=0)=p(y=1)\)</span>）。更深入的说，对于不可解的分布<span class="math inline">\(p_\theta^*(\mathbf{x})\)</span>，我们可以通过计算<em>Density Ratio</em>来了解我们近似的分布<span class="math inline">\(p_\theta(\mathbf{x})\)</span>和真实的<span class="math inline">\(p_\theta^*(\mathbf{x})\)</span>之间的相对性。而且我们只需要能够在两个分布上进行采样，并且训练一个判别器即可。因为判别器是一个普通的分类器，所以大量的主流分类器都可以使用。</p>
<h3 id="variational-inference">Variational Inference</h3>
<p>现在来看VAE，另一种解决不可解分布的方法是近似。<em>Variational Inference</em>通过引入一个变分分布<span class="math inline">\(q_\eta(\mathbf{z}|\mathbf{x})\)</span>推出了不可解的<span class="math inline">\(\mathbf{x}\)</span>的对数似然的下界（常被称为证据下界ELBO）：</p>
<p><span class="math display">\[
\log p_\theta(\mathbf{x})=\log\int p_\theta(\mathbb{x}|\mathbb{z})p(\mathbf{z})\text{d}\mathbf{z}\geq \mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[\log p_\theta(\mathbf{x}|\mathbf{z})\right]-\text{KL}\left[q_\eta(\mathbf{z}|\mathbf{x})\parallel p(\mathbf{z})\right]=\mathcal{F}(\boldsymbol{\theta}, \boldsymbol{\eta})
\]</span></p>
<p>VAE是<em>Variational Inference</em>的一种实现，变分分布通过一个神经网络进行建模，并且建立起了完整的可优化的模型。</p>
<h3 id="synthetic-likelihood">Synthetic Likelihood</h3>
<p>当似然函数未知（GAN中没有显式的似然函数，而VAE中有）的时候，<em>Variational Inference</em>便无法直接使用。对于没有显式的似然函数的情况，以VAE的ELBO的第一项为例，假设<span class="math inline">\(p_\theta(\mathbf{x}|\mathbf{z})\)</span>分布的具体形式未知，我们只有从<span class="math inline">\(p_\theta(\mathbf{x}|\mathbf{z})\)</span>采样得到的样本，如何计算<span class="math inline">\(\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}[\log p_\theta(\mathbf{x}|\mathbf{z})]\)</span>呢？一个方法是乘以<span class="math inline">\(p_\theta^*(\mathbf{x})\)</span>再除以<span class="math inline">\(p_\theta^*(\mathbf{x})\)</span>：</p>
<p><span class="math display">\[
\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}[\log p_\theta(\mathbf{x}|\mathbf{z})]=\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[\log\frac{p_\theta(\mathbf{x}|\mathbf{z})}{p^*(\mathbf{x})}\right]+\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}[\log p^*(\mathbf{x})]
\]</span></p>
<p>公式(5)中的第一项包括了合成似然<span class="math inline">\(R(\theta)=\frac{p_\theta(\mathbf{x}|\mathbf{z})}{p^*(\mathbf{x})}\)</span>，优化<span class="math inline">\(R(\theta)\)</span>相当于优化<span class="math inline">\(\log p_\theta(\mathbf{x}|\mathbf{z})\)</span>。第二项与生成网络的参数<span class="math inline">\(\theta\)</span>无关，所以在优化的时候可以忽略。</p>
<h2 id="a-fusion-of-variational-and-adversarial-learning">A Fusion of Variational and Adversarial Learning</h2>
<p>GAN和VAE分别从不同的角度解决了生成模型的推断问题，我们下面从VAE出发，考虑将两者结合起来。</p>
<h3 id="implicit-variational-distributions">Implicit Variational Distributions</h3>
<p>变分推断<strong>Variational Inference</strong>的主要任务就是确定<span class="math inline">\(q_\eta(\mathbf{z}|\mathbf{x})\)</span>，通常的做法如<strong>Mean-field Variational Inference</strong>会假设一个简单的分布，如高斯分布。在本文中不对<span class="math inline">\(q_\eta(\mathbf{z}|\mathbf{x})\)</span>的形式作假设，仅假设其为一个隐含的分布。运用上文提到的<em>Density Ratio Trick</em>，我们可以将VAE损失函数中的第二项改写为：</p>
<p><span class="math display">\[
-\text{KL}[q_\eta(\mathbf{z}|\mathbf{x})\parallel p(\mathbf{z})]=\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[\log\frac{p(\mathbf{z})}{q_\eta(\mathbf{z}|\mathbf{x})}\right]\approx\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[\log\frac{\mathcal{C}_\boldsymbol{\omega}(\mathbf{z})}{1-\mathcal{C}_\boldsymbol{\omega}(\mathbf{z})}\right]
\]</span></p>
<p>文中引入了一个隐变量分类器（Latent Classifier）<span class="math inline">\(\mathcal{C}_{\boldsymbol{\omega}}(\mathbf{z})\)</span>，用来判别<span class="math inline">\(\mathbf{z}\)</span>是从编码网络还是从标准高斯分布中采样得到的（猜测这样做的好处是不用再对<span class="math inline">\(\mathbf{z}\)</span>的后验做高斯分布的假设了，也不需要在变分网络输出形成的高斯分布上采样得到<span class="math inline">\(\mathbf{z}\)</span>了，这样重参数技巧也省了）。具体实现上，期望可以用蒙特卡洛方法（采样多次取均值）进行计算。</p>
<h3 id="likelihood-choice">Likelihood Choice</h3>
<p>对于VAE损失函数第一项，对应生成网络，我们可以选择对<span class="math inline">\(p(\mathbf{x}|\mathbf{z})\)</span>分布的具体形式做假设， 这样对应<em>Likelihood-based</em>的情况。文中选择的是<em>Zero-mean Laplace Distribution</em> <span class="math inline">\(p_\theta(\mathbf{x}|\mathbf{z})\propto\exp(-\lambda\parallel\mathbf{x}-\mathcal{G}_\theta(\mathbf{z})\parallel_1)\)</span>（不就是<span class="math inline">\(L_1\)</span> Loss吗？？？）。</p>
<p>对于<em>Likelihood-free</em>的情况，可以继续使用上面提到的<em>Density Ratio Trick</em>，这时需要加一个一个判别器。</p>
<p><span class="math display">\[
\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[-\lambda\parallel\mathbf{x}-\mathcal{G}_\theta(\mathbf{z})\parallel_1\right]\space\space\text{  or  }\space\space\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[\log\frac{\mathcal{D}_\phi(\mathcal{G}_\theta(\mathbf{z}))}{1-\mathcal{D}_\phi(\mathcal{G}_\theta(\mathbf{z}))}\right]
\]</span></p>
<p>对于两种选择，前者对应VAE，好处是不会出现模式崩溃的情况，后者对应GAN，容易出现模式崩溃的情况，但是可以使用对抗学习的方式（这是优点？？？），本文选择两种都用（我全都要.jpg）。</p>
<h3 id="hybrid-loss-functions">Hybrid Loss Functions</h3>
<p>将前面的讨论结合起来，最后的损失函数就是：</p>
<p><span class="math display">\[
\mathcal{L}(\boldsymbol{\theta},\boldsymbol{\eta})=\mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[-\lambda\parallel\mathbf{x}-\mathcal{G}_\theta(\mathbf{z})\parallel_1+\log\frac{\mathcal{D}_\phi(\mathcal{G}_\theta(\mathbf{z}))}{1-\mathcal{D}_\phi(\mathcal{G}_\theta(\mathbf{z}))}+\log\frac{\mathcal{C}_\boldsymbol{\omega}(\mathbf{z})}{1-\mathcal{C}_\boldsymbol{\omega}(\mathbf{z})}\right]
\]</span></p>
<p>最后模型包含四个网络：生成网络<span class="math inline">\(p_\theta(\mathbf{x}|\mathbf{z})\)</span>、推断网络<span class="math inline">\(q_\eta(\mathbf{z}|\mathbf{x})\)</span>以及两个判别器<span class="math inline">\(\mathcal{C}_{\boldsymbol{\omega}}\)</span>和<span class="math inline">\(\mathcal{D}_\phi\)</span>，作者将其命名为<span class="math inline">\(\alpha\)</span>-GAN。</p>
<p>算法流程如下：</p>
<p><img src="http://qfxiao.me/img/image-20191106220923748.png" /></p>
<h3 id="improved-techniques">Improved Techniques</h3>
<p>作者为了改进模型的稳定性和效率，将生成器的Loss中的<span class="math inline">\(-\log(1-\mathcal{D}_\phi)\)</span>修改为了<span class="math inline">\(\log\mathcal{D}_\phi-\log(1-\mathcal{D}_\phi)\)</span>，并声称这样能提供非饱和（Non-saturating）的梯度：</p>
<p><span class="math display">\[
\textbf{Generator Loss: } \mathbb{E}_{q_\eta(\mathbf{z}|\mathbf{x})}\left[\lambda\parallel\mathbf{x}-\mathcal{G}_\theta(\mathbf{z})\parallel_1-\log\mathcal{D}_\phi(\mathcal{G}_\theta(\mathbf{z}))+\log(1-\mathcal{D}_\phi(\mathcal{G}_\theta(\mathbf{z})))\right]
\]</span></p>
<p>作者认为在生成器损失函数中加入<span class="math inline">\(\lambda\parallel\mathbf{x}-\mathcal{G}_\theta(\mathbf{z})\parallel_1\)</span>能够在一定程度防止模式崩溃。</p>
<p>除此之外，作者发现将真实样本（原文是The Samples）作为生成的样本输入到判别器中能够提升性能。作者给出的解释是根据Jensen不等式：<span class="math inline">\(\log p_\theta(\mathbf{x})=\log\int p_\theta(\mathbf{x}|\mathbf{z})p(\mathbf{z})\text{d}\mathbf{z}\geq \mathbb{E}_{p(\mathbf{z})}[\log p_\theta(\mathbf{x}|\mathbf{z})]\)</span>，</p>
<p>[TODO]</p>
<h2 id="related-work">Related Work</h2>
<p>[TODO]</p>
<p><img src="http://qfxiao.me/img/image-20191102233101258.png" /></p>
<p><img src="http://qfxiao.me/img/image-20191102233151987.png" /></p>
<h1 id="experiments">Experiments</h1>
<p>[TODO]</p>
<h2 id="metrics">Metrics</h2>
<p>本文使用了几种不同的评测生成模型的方法：</p>
<ul>
<li><strong>Inception Score: </strong></li>
<li><strong>Multi-scale Structural Similarity (MS-SSIM): </strong></li>
<li><strong>Independent Wasserstein Critic: </strong></li>
</ul>
<h2 id="results-on-colormnist">Results on ColorMNIST</h2>
<p><img src="http://qfxiao.me/img/image-20191102233220700.png" /></p>
<p><img src="http://qfxiao.me/img/image-20191102233244847.png" /></p>
<h2 id="results-on-celeba">Results on CelebA</h2>
<p><img src="http://qfxiao.me/img/image-20191102233303345.png" /></p>
<h2 id="results-on-cifar-10">Results on CIFAR-10</h2>
<p><img src="http://qfxiao.me/img/image-20191102233338213.png" /></p>
<p><img src="http://qfxiao.me/img/image-20191102233350494.png" /></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/10/22/An-Introduction-to-Variational-Autoencoders/"><img class="thumbnail" src="http://qfxiao.me/img/autoencoder23849248011.png" alt="An Introduction to Variational Autoencoders"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-22T07:14:26.000Z" title="2019-10-22T07:14:26.000Z">2019-10-22</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Tutorial/">Tutorial</a></span><span class="level-item">22 分钟 读完 (大约 3277 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/22/An-Introduction-to-Variational-Autoencoders/">An Introduction to Variational Autoencoders</a></h1><div class="content"><h1 id="deep-generative-models">Deep Generative Models</h1>
<p>生成模型是指一系列用于随机生成可观测数据的模型。假设在一个高维空间<span class="math inline">\(\mathcal{X}\)</span>中，存在一个随机向量<span class="math inline">\(\mathbf{X}\)</span>服从一个未知的分布<span class="math inline">\(p_r(x),x\in \mathcal{X}\)</span>。生成模型就是根据一些可观测的样本<span class="math inline">\(x^{(1)},x^{(2)},\cdots,x^{(N)}\)</span>来学习一个参数化的模型<span class="math inline">\(p_\theta(x)\)</span>来近似未知分布<span class="math inline">\(p_r(x)\)</span>。</p>
<p>生成模型主要用于密度估计和样本生成。</p>
<hr />
<p>密度估计即给定一组数据<span class="math inline">\(\mathcal{D}=\{x^{(i)}\},1\leq i\leq N\)</span>，假设他们都是从相同的概率密度函数<span class="math inline">\(p_r(x)\)</span>独立产生的。密度估计就是根据数据集<span class="math inline">\(\mathcal{D}\)</span>来估计其概率密度函数<span class="math inline">\(p_r(x)\)</span>。</p>
<p>如果将生成模型用于监督学习，那么就是输出标签的条件概率分布<span class="math inline">\(p(y|x)\)</span>，根据贝叶斯公式：</p>
<p><span class="math display">\[p(y|x)=\frac{p(x,y)}{\sum_y p(x,y)}\]</span></p>
<p>问题就变为了联合概率<span class="math inline">\(p(x,y)\)</span>的密度估计问题。</p>
<hr />
<p>样本生成即根据给定的概率分布<span class="math inline">\(p_\theta(x)\)</span>生成一些服从这个分布的样本，即采样。在含隐变量的生成模型中，生成<span class="math inline">\(x\)</span>的过程一般包含两步：</p>
<ol type="1">
<li>根据隐变量的分布<span class="math inline">\(p_\theta(z)\)</span>采样得到<span class="math inline">\(z\)</span>；</li>
<li>根据条件分布<span class="math inline">\(p_\theta(x|z;\theta)\)</span>进行采样得到<span class="math inline">\(x\)</span>。</li>
</ol>
<p>所以在生成模型中的重点是估计条件分布<span class="math inline">\(p(x|z;\theta)\)</span>。</p>
<h1 id="parameter-estimation-for-hidden-variable-with-em-algorithm">Parameter Estimation for Hidden Variable with EM Algorithm</h1>
<p>如果图模型中存在隐变量，就需要使用EM算法进行参数估计。</p>
<p>在一个包含隐变量的图模型中，令<span class="math inline">\(\mathbf{X}\)</span>为可观测变量集合，<span class="math inline">\(\mathbf{Z}\)</span>为隐变量集合，则一个样本<span class="math inline">\(x\)</span>的边际似然函数为：</p>
<p><span class="math display">\[p(x;\theta)=\sum_z p(x,z;\theta)\]</span></p>
<p>给定包含<span class="math inline">\(N\)</span>个训练样本的训练集<span class="math inline">\(\mathcal{D}=\{x^{(n)}\},1\leq i\leq N\)</span>，则训练集的对数边际似然为：</p>
<p><span class="math display">\[\begin{align}\mathcal{L}(\mathcal{D};\theta)&amp;=\frac{1}{N}\sum_{n=1}^N \log p(x^{(n)};\theta)\\&amp;=\frac{1}{N}\sum_{n=1}^N \log \sum_z p(x^{(n)},z;\theta)\end{align}\]</span></p>
<hr />
<p>这时，只要最大化整个训练集的对数边际似然<span class="math inline">\(\mathcal{L}(\mathcal{D};\theta)\)</span>，即可估计出最优的参数<span class="math inline">\(\theta^*\)</span>。不过在计算梯度的时候，需要在对数函数内部进行求和或积分计算。为了更好的计算<span class="math inline">\(\log p(x;\theta)\)</span>，我们引入一个额外的变分函数<span class="math inline">\(q(z)\)</span>，<span class="math inline">\(q(z)\)</span>为定义在隐变量<span class="math inline">\(z\)</span>上的分布。样本<span class="math inline">\(x\)</span>的对数边际似然函数为：</p>
<p><span class="math display">\[\begin{align}\log p(x;\theta)&amp;=\log \sum_z q(z)\frac{p(x,z;\theta)}{q(z)}\\&amp;\geq\sum_z q(z)\log \frac{p(x,z;\theta)}{q(z)}\\&amp;\triangleq ELBO(q,x;\theta)\end{align}\]</span></p>
<p>其中<span class="math inline">\(ELBO(q,x;\theta)\)</span>为对数边际似然函数<span class="math inline">\(\log p(x;\theta)\)</span>的下界，称为证据下界。公式中使用了Jensen不等式(即对于凹函数<span class="math inline">\(g\)</span>，有<span class="math inline">\(g(\mathbb{E}[x])\geq\mathbb{E}[g(X)]\)</span>)。在这里，<span class="math inline">\(\frac{p(x,z;\theta)}{q(z)}\)</span>可视为<span class="math inline">\(q(z)\)</span>的函数，记为<span class="math inline">\(f(q(z))\)</span>，那么<span class="math inline">\(f(q(z))\)</span>的期望即<span class="math inline">\(\mathbb{E}[f(q(z))]=\sum_z q(z)f(q(z))=\sum_z q(z)\frac{p(x,z;\theta)}{q(z)}\)</span>。而根据Jensen不等式，有<span class="math inline">\(g(\mathbb{E}[f(q(z))])\geq\mathbb{E}[g(f(q(z)))]\Leftrightarrow g(\sum_z q(z)\frac{p(x,z;\theta)}{q(z)})\geq \sum_z q(z)g(\frac{p(x,z;\theta)}{q(z)})\)</span>，在这里<span class="math inline">\(g\)</span>就是对数函数。</p>
<hr />
<p>根据Jensen不等式取等的条件：<span class="math inline">\(\frac{p(x,z;\theta)}{q(z)}=c\)</span>，<span class="math inline">\(c\)</span>为常数，有：</p>
<p><span class="math display">\[\begin{align}\sum_z p(x,z;\theta)&amp;=c\sum_z q(z)\\\Leftrightarrow\sum_z p(x,z;\theta)&amp;=c\cdot1\end{align}\]</span></p>
<p>因此：</p>
<p><span class="math display">\[\begin{align}q(z)&amp;=\frac{p(x,z;\theta)}{\sum_z p(x,z;\theta)}\\&amp;=\frac{p(x,z;\theta)}{p(x;\theta)}\\&amp;=p(z|x;\theta)\end{align}\]</span></p>
<p>所以，当且仅当<span class="math inline">\(q(z)=p(z|x;\theta)\)</span>时，<span class="math inline">\(\log p(x;\theta)=ELBO(q,x;\theta)\)</span>。</p>
<hr />
<p>于是最大化对数边际似然函数<span class="math inline">\(\log p(x;\theta)\)</span>的过程可以分解为两个步骤：</p>
<ol type="1">
<li>先找到近似分布<span class="math inline">\(q(z)\)</span>使得<span class="math inline">\(\log p(x;\theta)=ELBO(q,x;\theta)\)</span>；</li>
<li>再寻找参数<span class="math inline">\(\theta\)</span>最大化<span class="math inline">\(ELBO(q,x;\theta)\)</span>。</li>
</ol>
<p>这就是期望最大化(Expectation-Maximum,EM)算法。</p>
<hr />
<p>EM算法通过迭代的方法，不断重复直到收敛到某个局部最优解。在第<span class="math inline">\(t\)</span>步更新时，E步和M步分别为：</p>
<ol type="1">
<li><p>E步：固定参数<span class="math inline">\(\theta_t\)</span>，找到一个分布使<span class="math inline">\(ELBO(q,x;\theta_t)\)</span>最大，即等于<span class="math inline">\(\log p(x;\theta_t)\)</span>：<span class="math inline">\(q_{t+1}(z)=\text{arg}_q \max ELBO(q,x;\theta_t)\)</span>；</p></li>
<li><p>M步：固定<span class="math inline">\(q_{t+1}(z)\)</span>，找到一组参数使得证据下界最大，即：<span class="math inline">\(\theta_{t+1}=\text{arg}_\theta\max ELBO(q_{t+1},x;\theta)\)</span>。</p></li>
</ol>
<hr />
<p>对数边际似然也可以通过信息论的视角来进行分解：</p>
<p><span class="math display">\[\begin{align}\log p(x;\theta)&amp;=\sum_z q(z)\log p(x;\theta)\\&amp;=\sum_z q(z)(\log p(x,z;\theta)-\log p(z|x;\theta))\\&amp;=\sum_z q(z)\log\frac{p(x,z;\theta)}{q(z)}-\sum_z q(z)\log\frac{p(z|x;\theta)}{q(z)}\\&amp;=ELBO(q,x;\theta)+D_{KL}(q(z)\parallel p(z|x;\theta))\end{align}\]</span></p>
<p>其中<span class="math inline">\(D_{KL}(q(z)\parallel p(z|x;\theta))\)</span></p>
<h1 id="generative-model-with-hidden-variable">Generative Model with Hidden Variable</h1>
<p>假设一个生成模型包含不可观测的隐变量，其中可观测变量<span class="math inline">\(x\)</span>为一个高维空间中的随机向量，而不可观测的隐变量<span class="math inline">\(z\)</span>为一个相对低维空间中的随机向量。</p>
<p>这个生成模型的联合概率密度函数可以表达为：</p>
<p><span class="math display">\[p(x,z;\theta)=p(x|z;\theta)p(z;\theta)\]</span></p>
<p>其中<span class="math inline">\(p(z;\theta)\)</span>为隐变量<span class="math inline">\(z\)</span>的先验概率分布；<span class="math inline">\(p(x|z;\theta)\)</span>为已知<span class="math inline">\(z\)</span>条件下<span class="math inline">\(x\)</span>的概率分布。通常情况下，我们可以假设<span class="math inline">\(p(z;\theta)\)</span>和<span class="math inline">\(p(x|z;\theta)\)</span>服从某种带参的分布族，其形式已知，而参数可以通过最大似然来进行估计。</p>
<p>给定一个样本<span class="math inline">\(x\)</span>，其对数边际似然<span class="math inline">\(\log p(x;\theta)\)</span>可以分解为：</p>
<p><span class="math display">\[\log p(x;\theta)=ELBO(q,x;\theta,\phi)+D_{KL}(q(z;\phi)\parallel p(z|x;\theta))\]</span></p>
<p>其中<span class="math inline">\(q(z;\phi)\)</span>为额外引入的变分密度函数，<span class="math inline">\(ELBO(q,x;\theta,\phi)\)</span>为证据下界：</p>
<p><span class="math display">\[ELBO(q,x;\theta,\phi)=\mathbb{E}_{z\sim q(z;\phi)}[\log{\frac{p(x,z;\theta)}{q(z;\phi)}}]\]</span></p>
<p>最大化<span class="math inline">\(\log p(x;\theta)\)</span>可以用EM算法来求解：</p>
<ul>
<li><strong>E-step:</strong> 寻找一个密度函数<span class="math inline">\(q(z;\phi)\)</span>使其等于或接近于后验密度函数<span class="math inline">\(p(z|x;\theta)\)</span>;</li>
<li><strong>M-step:</strong> 保持<span class="math inline">\(q(z;\phi)\)</span>固定，寻找<span class="math inline">\(\theta\)</span>来最大化<span class="math inline">\(ELBO(q,x;\theta,\phi)\)</span>。</li>
</ul>
<p>在EM算法的每次迭代中，理论上最优的<span class="math inline">\(q(z;\phi)\)</span>为隐变量的后验概率密度函数<span class="math inline">\(p(z|x;\theta)\)</span>：</p>
<p><span class="math display">\[p(z|x;\theta)=\frac{p(x|z;\theta)p(z;\theta)}{\int_z p(x|z;\theta)p(z;\theta)\text{d}z}\]</span></p>
<p>后验密度函数<span class="math inline">\(p(z|x;\theta)\)</span>的计算是一个统计推断的问题，在一般情况下<span class="math inline">\(p(x|z;\theta)\)</span>也比较难以计算。</p>
<h1 id="variational-autoencoder">Variational Autoencoder</h1>
<p>变分自编码器(Variational Autoencoder, VAE)的主要思想是利用神经网络来分别建模两个复杂的条件概率密度函数：</p>
<ol type="1">
<li>用神经网络来产生变分分布<span class="math inline">\(q(z;\phi)\)</span>，称为推断网络。推断网络的输入为<span class="math inline">\(x\)</span>，输出为变分分布<span class="math inline">\(q(z|x;\phi)\)</span>；</li>
<li>用神经网络来产生概率分布<span class="math inline">\(p(x|z;\theta)\)</span>，称为生成网络。生成网络的输入为<span class="math inline">\(z\)</span>，输出为概率分布<span class="math inline">\(p(x|z;\theta)\)</span>。</li>
</ol>
<p><img src="http://qfxiao.me/img/autoencoder23849248011.png" /></p>
<p>VAE的图模型如下图所示：</p>
<p><img src="http://qfxiao.me/img/1565532060281.png" /></p>
<h2 id="variational-network">Variational Network</h2>
<p>假设<span class="math inline">\(q(z|x;\phi)\)</span>是服从对角化协方差的高斯分布：</p>
<p><span class="math display">\[q(z|x;\phi)=\mathcal{N}(z;\mu_I,\sigma^2_I I)\]</span></p>
<p>其中<span class="math inline">\(\mu_I\)</span>和<span class="math inline">\(\sigma_I^2\)</span>是高斯分布的均值和方差，可以通过推断网络<span class="math inline">\(f_I(x;\phi)\)</span>来预测：</p>
<p><span class="math display">\[
\left[\begin{matrix}\mu_I\\\sigma_I\end{matrix}\right]=f_I(x;\phi)
\]</span> 推断网络<span class="math inline">\(f_I(x;\phi)\)</span>可以是一般的全连接网络或卷积网络，比如一个两层的神经网络：</p>
<p><span class="math display">\[\begin{align}h&amp;=\sigma(W^{(1)}x+b^{(1)})\\\mu_I&amp;=W^{(2)}h+b^{(2)}\\\sigma_I&amp;=\text{softplus}(W^{(3)}h+b^{(3)})\end{align}\]</span></p>
<p>其中所有网络参数<span class="math inline">\(\{W^{(1)},W^{(2)},W^{(3)},b^{(1)},b^{(2)},b^{(3)}\}\)</span>即对应了变分参数<span class="math inline">\(\phi\)</span>。</p>
<hr />
<p>推断网络的目标是使得<span class="math inline">\(q(z|x;\phi)\)</span>来尽可能接近真实的后验<span class="math inline">\(p(z|x;\theta)\)</span>，需要找到变分参数<span class="math inline">\(\phi^*\)</span>来最小化两个分布的KL散度：</p>
<p><span class="math display">\[\phi^*=\text{arg}_\phi\min{D_{KL}(q(z|x;\phi)\parallel p(z|x;\theta))}\]</span></p>
<p>由于<span class="math inline">\(p(z|x;\theta)\)</span>未知，故KL散度无法直接计算，不过由于<span class="math inline">\(D_{KL}(q(z|x;\phi)\parallel p(z|x;\theta))=\log p(x;\theta)-ELBO(q,x;\theta,\phi)\)</span>，所以可以直接最大化证据下界，有：</p>
<p><span class="math display">\[\phi^*=\text{arg}_\phi\max{ELBO(q,x;\theta,\phi)}\]</span></p>
<h2 id="generative-network">Generative Network</h2>
<p>生成模型的联合分布可以分解为两部分：隐变量<span class="math inline">\(z\)</span>的先验分布<span class="math inline">\(p(z;\theta)\)</span>和条件概率分布<span class="math inline">\(p(x|z;\theta)\)</span>。为简单起见，一般假设隐变量<span class="math inline">\(z\)</span>的先验分布为标准正态分布<span class="math inline">\(\mathcal{N}(z|0,I)\)</span>，隐变量每一维之间都是独立的。条件概率分布<span class="math inline">\(p(x|z;\theta)\)</span>可以通过生成网络来建模，我们同样用参数化的分布族来表示条件概率分布<span class="math inline">\(p(x|z;\theta)\)</span>，这些分布族的函数可以用生成网络计算得到。根据变量<span class="math inline">\(x\)</span>的类型不同，可以假设<span class="math inline">\(p(x|z;\theta)\)</span>服从不同的分布族。如果<span class="math inline">\(x\in\{0,1\}^d\)</span>是<span class="math inline">\(d\)</span>维的二值向量，可以假设<span class="math inline">\(\log p(x|z;\theta)\)</span>服从多变量的伯努利分布，即：</p>
<p><span class="math display">\[\begin{align}p(x|z;\theta)&amp;=\prod\limits_{i=1}^d p(x_i|z;\theta)\\&amp;=\prod\limits_{i=1}^d \gamma_i^{x_i}(1-\gamma_i)^{(1-x_i)}\end{align}\]</span></p>
<p>如果<span class="math inline">\(x\in\mathbb{R}^d\)</span>是<span class="math inline">\(d\)</span>维的连续向量，可以假设<span class="math inline">\(p(x|z;\theta)\)</span>服从对角化协方差的高斯分布，即：</p>
<p><span class="math display">\[p(x|z;\theta)=\mathcal{N}(x;\mu_G,\sigma_G^2 I)\]</span></p>
<hr />
<p>生成网络的目标是找到一组<span class="math inline">\(\theta^*\)</span>最大化证据下界<span class="math inline">\(ELBO(q,x;\theta,\phi)\)</span>：</p>
<p><span class="math display">\[\theta^*=\text{arg}_\theta\max ELBO(q,x;\theta,\phi)\]</span></p>
<h2 id="model-combination">Model Combination</h2>
<p>推断网络和生成网络的目标都是最大化证据下界因此总的目标函数为：</p>
<p><span class="math display">\[\begin{align}\max_{\theta,\phi}ELBO(q,x;\theta,\phi)&amp;=\max_{\theta,\phi}\mathbb{E}_{z\sim q(z;\phi)}[\log\frac{p(x|z;\theta)p(z;\theta)}{q(z;\theta)}]\\&amp;=\max_{\theta,\phi}\mathbb{E}_{z\sim q(z|x;\phi)}[\log p(x|z;\theta)]-D_{KL}(q(z|x;\phi)\parallel p(z;\theta))\end{align}\]</span></p>
<p>其中先验分布<span class="math inline">\(p(z;\theta)=\mathcal{N}(z|0,I)\)</span>。</p>
<p>公式中<span class="math inline">\(\mathbb{E}_{z\sim q(z|x;\phi)}[\log p(x|z;\theta)]\)</span>一般通过采样的方式进行计算，最后取平均值。</p>
<h2 id="model-training">Model Training</h2>
<p>给定数据集<span class="math inline">\(\mathcal{D}\)</span>，包含<span class="math inline">\(N\)</span>个从未知数据分布中抽取的独立同分布样本<span class="math inline">\(x^{(1)},x^{(2)},\cdots,x^{(N)}\)</span>。变分自编码器的目标函数为：</p>
<p><span class="math display">\[\mathcal{J}(\phi,\theta|\mathcal{D})=\sum\limits_{n=1}^N(\frac{1}{M}\sum\limits_{m=1}^M\log p(x^{(n)}|z^{(n,m)};\theta)-D_{KL}(q(z|x^{(n)};\phi)\parallel\mathcal{N}(z;0,I)))\]</span></p>
<p>如果采用随机梯度下降法，每次从数据集中采一个样本<span class="math inline">\(x\)</span>，然后根据<span class="math inline">\(q(z|x;\phi)\)</span>采一个隐变量<span class="math inline">\(z\)</span>，则目标函数变为：</p>
<p><span class="math display">\[\mathcal{J}(\phi,\theta|x)=\log p(x|z;\theta)-D_{KL}(q(z|x;\phi)\parallel\mathcal{N}(z;0,I))\]</span></p>
<p>假设<span class="math inline">\(q(z|x;\phi)\)</span>是正态分布，KL散度可直接算出：</p>
<p><span class="math display">\[D_{KL}(\mathcal{N}(\mu_1,\Sigma_1)\parallel\mathcal(\mu_2,\Sigma_2))\\=\frac{1}{2}(\text{tr}(\sigma_I^2 I)+\mu_I^T\mu_I-d-\log(|\sigma_I^2 I|))\]</span></p>
<hr />
<p>再参数化是将一个参数为<span class="math inline">\(u\)</span>的函数<span class="math inline">\(f(u)\)</span>，通过一个函数<span class="math inline">\(u=g(v)\)</span>，转换为参数为<span class="math inline">\(v\)</span>的函数<span class="math inline">\(\hat{f}(v)=f(g(v))\)</span>。在变分自编码器中，一个问题是如何求随机变量<span class="math inline">\(z\)</span>关于<span class="math inline">\(\phi\)</span>的导数。但由于是采样的方式，无法直接刻画<span class="math inline">\(z\)</span>和<span class="math inline">\(\phi\)</span>之间的函数关系，因此也无法计算导数。</p>
<p>如果<span class="math inline">\(z\sim q(z|x;\phi)\)</span>的随机性独立于参数<span class="math inline">\(\phi\)</span>，我们可以通过再参数化的方法来计算导数。假设<span class="math inline">\(q(z|x;\phi)\)</span>为正态分布<span class="math inline">\(\mathcal{N}(\mu_I,\sigma^2_I I)\)</span>，其中<span class="math inline">\(\mu_I\)</span>和<span class="math inline">\(\sigma_I\)</span>是推断网络<span class="math inline">\(f_I(x;\phi)\)</span>的输出。我们可以通过下面的方式采样<span class="math inline">\(z\)</span>：</p>
<p><span class="math display">\[z=\mu_I+\sigma_I\odot \varepsilon\]</span></p>
<p>其中<span class="math inline">\(\varepsilon\sim\mathcal{N}(0,I)\)</span>。这样<span class="math inline">\(z\)</span>和<span class="math inline">\(\mu_I,\sigma_I\)</span>的关系从采样关系变为函数关系。</p>
<hr />
<p>如果进一步假设<span class="math inline">\(p(x|z;\theta)\)</span>服从高斯分布<span class="math inline">\(\mathcal{N}(x|\mu_G,I)\)</span>，其中<span class="math inline">\(\mu_G=f_G(z;\theta)\)</span>是生成网络的输出，则目标函数可以简化为：</p>
<p><span class="math display">\[\mathcal{J}(\phi,\theta|x)=-\parallel x-\mu_G\parallel^2+D_{KL}(\mathcal{N}(\mu_I,\sigma_I)\parallel\mathcal{N}(0,I))\]</span></p>
<p>其中第一项可以近似看作是输入<span class="math inline">\(x\)</span>的重构正确性，第二项可以看作是正则化项。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/10/18/Recurrent-Neural-Networks-for-Multivariate-Time-Series-with-Missing-Values/"><img class="thumbnail" src="http://qfxiao.me/img/1571412138245.png" alt="Recurrent Neural Networks for Multivariate Time Series with Missing Values"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-18T15:17:07.000Z" title="2019-10-18T15:17:07.000Z">2019-10-18</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/RNN/">RNN</a></span><span class="level-item">9 分钟 读完 (大约 1309 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/18/Recurrent-Neural-Networks-for-Multivariate-Time-Series-with-Missing-Values/">Recurrent Neural Networks for Multivariate Time Series with Missing Values</a></h1><div class="content"><h1 id="abstract">Abstract</h1>
<p>文中提出了一种可以处理带缺失值多为时间序列的GRU模型：<strong>GRU-D</strong>。本模型不仅可以捕捉时间序列中的长期依赖模式，并且还能利用时间序列中的缺失模式来达到更好的时间序列预测效果。</p>
<p><a href="https://www.nature.com/articles/s41598-018-24271-9">原文</a></p>
<h1 id="methodology">Methodology</h1>
<h2 id="notations">Notations</h2>
<p>记包含<span class="math inline">\(D\)</span>个变量的多变量时间序列为<span class="math inline">\(X=(x_1,x_2,\cdots,x_T)^T\in\mathbb{R}^{T\times D}\)</span>，其中对于每个<span class="math inline">\(t\in\{1,2,\cdots,T\},x_t\in\mathbb{R}^D\)</span>表示时间序列在时间<span class="math inline">\(t\)</span>的观测值，<span class="math inline">\(x_t^d\)</span>表示<span class="math inline">\(x_t\)</span>的第<span class="math inline">\(d\)</span>个成分。记<span class="math inline">\(s_t\in\mathbb{R}\)</span>为<span class="math inline">\(t\)</span>时刻的时间戳，并假设第一个观测值的时间戳为<span class="math inline">\(0\)</span>。对于包含缺失值的时间序列，我们用<strong>Masking Vector</strong> <span class="math inline">\(m_t\in\{0,1\}\)</span>进行标记，同时对每个<span class="math inline">\(x_t^d\)</span>维护距离上一个观测值的<strong>Time Interval</strong> <span class="math inline">\(\delta_t^d\in\mathbb{R}\)</span>，公式如下： <span class="math display">\[
m_t^d=\begin{cases}1, &amp;\text{if }x_t^d\text{ is observed}\\0, &amp;\text{otherwise}\end{cases}
\]</span></p>
<p><span class="math display">\[
\delta_t^d=\begin{cases}s_t-s_{t-1}+\delta_{t-1}^d, &amp;t&gt;1,m_{t-1}^d=0\\s_t-s_{t-1}, &amp;t&gt;1, m_{t-1}^d=1\\0, &amp;t=1\end{cases}
\]</span></p>
<p>下图是一些示例：</p>
<p><img src="http://qfxiao.me/img/1571476968374.png" /></p>
<p>在本文中，我们主要关注时间序列的分类问题，即给定数据集<span class="math inline">\(\mathcal{D}=\{(X_n,s_n,M_n)\}_{n=1}^N\)</span>，我们要对每个样本的类别进行预测<span class="math inline">\(l_n\in\{1,\cdots,L\}\)</span>。</p>
<h2 id="gru-rnn-for-time-series-classification">GRU-RNN for Time Series Classification</h2>
<p>GRU是一种改进版本的RNN，其最大不同是加入了门控机制。GRU单元的结构如下图所示：</p>
<p><img src="http://qfxiao.me/img/GRU49241911247.png" /></p>
<p>GRU包含了重置门和更新门，其中重置门<span class="math inline">\(R_t\)</span>负责控制上一时间的隐状态<span class="math inline">\(h_{t-1}\)</span>有多少部分需要保留，而更新门则决定由<span class="math inline">\(R_t\)</span>计算出来的候选隐状态<span class="math inline">\(\tilde{h}_t\)</span>有多少部分需要保留。最后当前时间的隐状态由<span class="math inline">\(h_{t-1}\)</span>和<span class="math inline">\(\tilde{h}_t\)</span>共同算出。GRU的状态更新公式如下： <span class="math display">\[
\begin{align}
R_t&amp;=\sigma(W_rx_t+U_rh_{t-1}+b_r)\\
Z_t&amp;=\sigma(W_zx_t+U_zh_{t-1}+b_z)\\
\tilde{h}_t&amp;=\text{tanh}(Wx_t+U(R_t\odot h_{t-1})+b)\\
h_t&amp;=(1-Z_t)\odot h_{t-1}+Z_t\odot \tilde{h}_t
\end{align}
\]</span> 文中提出了一些处理缺失值的简单方法：</p>
<ol type="1">
<li>直接用均值替代：<span class="math inline">\(x_t^d\leftarrow m_t^dx_t^d+(1-m_t^d)\tilde{x}^d\)</span>，其中<span class="math inline">\(\tilde{x}^d=\frac{\sum_{n=1}^N\sum_{t=1}^{T_n}m_{t,n}^d x_{t,n}^d}{\sum_{n=1}^N\sum_{t=1}^{T_n}m_{t,n}^d\tilde{x}^d}\)</span>。这种方法称为<strong>GRU-Mean</strong>；</li>
<li>用上一个观测值替代：<span class="math inline">\(x_t^d\leftarrow m_t^d x_t^d+(1-m_t^d)x_{t^\prime}^d\)</span>。这种方法称为<strong>GRU-Forward</strong>；</li>
<li>不填充，将是否缺失，距离上一个观测值的时间作为额外信息输入：<span class="math inline">\(x_t^{(n)}\leftarrow[x_t^{(n)};m_t^{(n)};\delta_t^{(n)}]\)</span>。这种方法称为<strong>GRU-Simple</strong>。</li>
</ol>
<h3 id="gru-d-model-with-trainable-decays">GRU-D: Model with Trainable Decays</h3>
<p>文中提出了时间序列缺失值的两个性质：一个是在上一个观测值距离很远的情况下缺失值倾向于接近一个默认的值，第二个是缺失值的影响会随着时间减弱。为了体现上述两点，文中提出了GPU-D模型，模型框架如下：</p>
<p><img src="http://qfxiao.me/img/1571412138245.png" /></p>
<p>在模型中，<strong>Decay Rates</strong>被设定为一个带参数的函数和GRU一起训练： <span class="math display">\[
\gamma_t=\exp\{-\max(0,W_\gamma\delta_t+b_\gamma)\}
\]</span></p>
<p><span class="math display">\[
\hat{x}_t^d=m_t^dx_t^d+(1-m_t^d)(\gamma_{x_t}^dx_{t^\prime}^d+(1-\gamma_{x_t}^d)\tilde{x}^d)
\]</span> 其中<span class="math inline">\(x_{t^\prime}^d\)</span>是第<span class="math inline">\(d\)</span>个变量的上一个观测值，<span class="math inline">\(\tilde{x}^d\)</span>是第<span class="math inline">\(d\)</span>个变量的经验均值。这样<span class="math inline">\(\hat{x}_t^d\)</span>就代表经过<strong>Input Decay</strong>的输入。</p>
<p>文中提到只用<strong>Input Decay</strong>是不够的，除此之外作者还使用了<strong>Hidden State Decay</strong>，即对<span class="math inline">\(h_{t-1}\)</span>进行Decay，公式如下： <span class="math display">\[
\hat{h}_{t-1}=\gamma_{h_t}\odot h_{t-1}
\]</span> 用Decay之后的<span class="math inline">\(\hat{x}_t\)</span>和<span class="math inline">\(\hat{h}_{t-1}\)</span>替换原始的GRU公式就得到了GRU-D模型： <span class="math display">\[
\begin{align}
R_t&amp;=\sigma(W_r\hat{x}_t-U_r\hat{h}_{t-1}+V_rm_t+b_r)\\
Z_t&amp;=\sigma(W_z\hat{x}_t+U_z\hat{h}_{t-1}+V_zm_t+b_z)\\
\tilde{h}_t&amp;=\text{tanh}(W\hat{x}_t+U(R_t\odot \hat{h}_{t-1})+Vm_t+b)\\
h_t&amp;=(1-z_t)\odot \hat{h}_{t-1}+z_t\odot\tilde{h}_t
\end{align}
\]</span></p>
<h1 id="experiments">Experiments</h1>
<h2 id="baseline-imputation-methods">Baseline Imputation Methods</h2>
<p>下图为文中比较中用到的Baseline：</p>
<p><img src="http://qfxiao.me/img/1571673314402.png" /></p>
<h2 id="baseline-prediction-methods">Baseline Prediction Methods</h2>
<p>下图为文中用到的用来预测的Baseline：</p>
<p><img src="http://qfxiao.me/img/1571673403956.png" /></p>
<h2 id="results">Results</h2>
<p>文中用到的数据集如下：</p>
<ul>
<li><em>Gesture phase segmentation dataset (Gesture)</em>.</li>
<li><em>PhysioNet Challenge 2012 dataset (PhysioNet)</em>.</li>
<li><em>MIMIC-Ⅲ dataset (MIMIC-Ⅲ)</em>.</li>
</ul>
<p>下图展示了不同方法在人工合成数据集上的表现：</p>
<p><img src="http://qfxiao.me/img/1571412162954.png" /></p>
<p>下表展示了不同模型在预测任务表现的对比：</p>
<p><img src="http://qfxiao.me/img/1571412183650.png" /></p>
<p>下表展示了不同方法在MIMIC-Ⅲ和PhysioNet数据集上的多任务表现：</p>
<p><img src="http://qfxiao.me/img/1571412196724.png" /></p>
<p>下图分别展示了模型学到的<strong>Input Decay</strong>和<strong>Hidden State Decay</strong>：</p>
<p><img src="http://qfxiao.me/img/1571412221428.png" /></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/10/18/Robust-Anomaly-Detection-for-Multivariate-Time-Series-through-Stochastic-Recurrent-Neural-Network/"><img class="thumbnail" src="http://qfxiao.me/img/1571411043958.png" alt="Robust Anomaly Detection for Multivariate Time Series through Stochastic Recurrent Neural Network"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-18T15:00:57.000Z" title="2019-10-18T15:00:57.000Z">2019-10-18</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></span><span class="level-item">25 分钟 读完 (大约 3813 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/18/Robust-Anomaly-Detection-for-Multivariate-Time-Series-through-Stochastic-Recurrent-Neural-Network/">Robust Anomaly Detection for Multivariate Time Series through Stochastic Recurrent Neural Network</a></h1><div class="content"><h1 id="abstract">Abstract</h1>
<p>本文提出了<em>OmniAnomaly</em>：一种针对多变量时间序列的随机循环神经网络异常检测算法。该模型运用了一系列技术来捕捉多变量时间序列的正常模式，并在检测阶段基于重构误差来检测异常，同时本文还提供了一定的理论解释。</p>
<p><a href="https://www.kdd.org/kdd2019/accepted-papers/view/robust-anomaly-detection-for-multivariate-time-series-through-stochastic-re">原文</a></p>
<h1 id="contribution">Contribution</h1>
<ol type="1">
<li>提出了<em>OmniAnomaly</em>，一种基于随机循环神经网络的多变量时间序列异常检测算法；</li>
<li>提出了针对多变量时间序列异常检测的解释方法；</li>
<li>通过实验证明了<em>OmniAnomaly</em>中所用的关键技术的有效性，包括GRU，planar NF, stochastic variable connection和adjusted Peaks-Over-Threshold method；</li>
<li>通过大量的实验我们证明了<em>OmniAnomaly</em>的有效性；</li>
<li>发布了代码和数据集。</li>
</ol>
<h1 id="background">Background</h1>
<h2 id="linear-gaussian-state-space-model">Linear Gaussian State Space Model</h2>
<p>状态空间模型（State Space Model, SSM）的概念来自于控制理论，在这里我们主要讨论其在时间序列中的应用。其大概思想是我们认为时间序列在时刻<span class="math inline">\(t\)</span>的观测值<span class="math inline">\(z_t\)</span>是一个隐含状态<span class="math inline">\(\boldsymbol{l}_t\)</span>的条件分布<span class="math inline">\(p(z_t|\boldsymbol{l}_t)\)</span>，而这个隐含状态<span class="math inline">\(\boldsymbol{l}_t\)</span>刻画了时间序列的内在规律，同时隐含状态会随着时间更新，即服从条件分布<span class="math inline">\(p(\boldsymbol{l}_t|\boldsymbol{l}_{t-1})\)</span>。</p>
<p>在线性状态空间模型（Linear State Space Model）中我们以如下的方式刻画隐含状态的更新： <span class="math display">\[
\boldsymbol{l}_t=\boldsymbol{F}_t\boldsymbol{l}_{t-1}+\boldsymbol{g}_t\varepsilon_t, \space\space\space\varepsilon_t\sim\mathcal{N}(0,1)
\]</span> <span class="math inline">\(\boldsymbol{F}_t\)</span>为确定的状态转移矩阵，而<span class="math inline">\(\boldsymbol{g}_t\varepsilon_t\)</span>则表示了状态转移的随机性。</p>
<p>观测值<span class="math inline">\(z_t\)</span>从隐含状态<span class="math inline">\(\boldsymbol{l}_t\)</span>计算而来： <span class="math display">\[
\begin{align}
z_t&amp;=y_t+\sigma_t\epsilon_t,\\
y_t&amp;=\boldsymbol{a}_t^\top\boldsymbol{l}_{t-1}+b_t,\\
\epsilon_t&amp;\sim\mathcal{N}(0,1)
\end{align}
\]</span> 其中<span class="math inline">\(\boldsymbol{a}_t\in\mathbb{R}^L,\sigma_t\in \mathbb{R},b_t\in\mathbb{R}\)</span>都是额外的参数。初始状态<span class="math inline">\(\boldsymbol{l}_0\)</span>则从一个独立的高斯分布得来，即<span class="math inline">\(\boldsymbol{l}_0\sim N(\boldsymbol\mu_0,\text{diag}(\boldsymbol{\sigma}_0^2))\)</span>。</p>
<p>令参数集合<span class="math inline">\(\Theta_t=(\boldsymbol{\mu}_0,\boldsymbol{\Sigma}_0,\boldsymbol{F}_t,\boldsymbol{g}_t,\boldsymbol{a}_t,b_t,\sigma_t),\forall t&gt;0\)</span>，一般来说参数集合不会随着时间变化，即每个时刻<span class="math inline">\(t\)</span>共享同样的参数<span class="math inline">\(\Theta_t=\Theta,\forall t&gt;0\)</span>。对参数的估计可以采用极大似然估计： <span class="math display">\[
\begin{align}
\Theta^*_{1:T}&amp;=\arg\max_{\Theta_{1:T}}p(z_{1:T}|\Theta_{1:T}),\\
\end{align}
\]</span> 其中： <span class="math display">\[
\begin{align}
p(z_{1:T}|\Theta_{1:T})&amp;=p(z_1|\Theta_1)\prod\limits_{t=2}^T p(z_t|z_{1:t-1},\Theta_{1:t})\\
&amp;=\int p(\boldsymbol{l}_0)\left[\prod\limits_{t=1}^T p(z_t|\boldsymbol{l}_t)p(\boldsymbol{l}_t|\boldsymbol{l}_{t-1})\right]\mathrm{d}\boldsymbol{l}_{0:T}
\end{align}
\]</span></p>
<h2 id="planar-normalizing-flow">Planar Normalizing Flow</h2>
<h3 id="normalizing-flows">Normalizing Flows</h3>
<p>VAE采用一个变分分布<span class="math inline">\(q_\phi(z|x)\)</span>来近似真实的后验分布<span class="math inline">\(p(z|x)\)</span>，并推导出<span class="math inline">\(\log p_\theta(x)\)</span>的下界（称为ELBO）来作为优化目标函数： <span class="math display">\[
\begin{align}
\log p_\theta(x)&amp;=\log \int p_\theta(x|z)p(z)\mathrm{d}z\\
&amp;=\log\int\frac{q_\phi(z|x)}{q_\phi(z|x)}p_\theta(x|z)p(z)\mathrm{d}z\\
&amp;\geq-D_{KL}[q_\phi(z|x)\parallel p(z)]+\mathbb{E}_q[\log p_\theta(x|z)]
\end{align}
\]</span> <span class="math inline">\(\log p_\theta(x)\)</span>与ELBO取等的条件是<span class="math inline">\(D_{KL}[q_\phi(z|x)\parallel p(z)]\)</span>，表明变分分布完全匹配了真实的后验分布。但在实际应用中，真实的后验分布可能会非常复杂，而我们的变分分布通常是一个确定的较为简单的分布，如高斯分布。这样变分分布可能很难对真实后验分布得到一个很好的拟合。</p>
<p>一个解决方案是使用标准化流（Normalizing Flows）。标准化流是从一个相对简单的分布出发，执行一系列可逆的映射，将原始简单的分布转化为一个复杂的分布。</p>
<p>首先考虑一个光滑的、可逆的映射<span class="math inline">\(f:\mathbb{R}^d\mapsto \mathbb{R}^d\)</span>，记<span class="math inline">\(g=f^{-1}\)</span>，那么<span class="math inline">\(g\circ f(\mathbf{z})=\mathbf{z}\)</span>。令<span class="math inline">\(\mathbf{z}^\prime=f(\mathbf{z})\)</span>，那么<span class="math inline">\(\mathbf{z}^\prime\)</span>的分布为： <span class="math display">\[
q(\mathbf{z}^\prime)=q(\mathbf{z})\left|\text{det}\frac{\partial f^{-1}}{\partial \mathbf{z}^\prime}\right|=q(z)\left|\text{det}\frac{\partial f}{\partial \mathbf{z}}\right|^{-1}
\]</span> 式中<span class="math inline">\(q(\mathbf{z}^\prime)=q(z)\left|\text{det}\frac{\partial f}{\partial \mathbf{z}}\right|^{-1}\)</span>说明了<span class="math inline">\(\mathbf{z}^\prime\)</span>的分布等于<span class="math inline">\(\mathbf{z}\)</span>的分布乘上<span class="math inline">\(f\)</span>的Jacobian矩阵的行列式的倒数。那么对于映射多次的情况： <span class="math display">\[
\mathbf{z}_K=f_K\circ\cdots\circ f_2\circ f_1(\mathbf{z}_0)
\]</span> <span class="math inline">\(\mathbf{z}_K\)</span>的分布可以通过链式计算得到： <span class="math display">\[
\ln q_K(\mathbf{z}_K)=\ln q_0(\mathbf{z}_0)-\sum\limits_{k=1}^K\ln\left|\text{det}\frac{\partial f_k}{\partial \mathbf{z}_{k-1}}\right|
\]</span></p>
<h3 id="planar-flows">Planar Flows</h3>
<p>考虑一个变换族： <span class="math display">\[
f(\mathbf{z})=\mathbf{z}+\mathbf{u}h(\mathbf{w}^\top\mathbf{z}+b)
\]</span> 其中<span class="math inline">\(\lambda=\{\mathbf{w}\in \mathbb{R}^d,\mathbf{u}\in\mathbb{R}^d,b\in\mathbb{R}\}\)</span>为参数集合，<span class="math inline">\(h(\cdot)\)</span>为元素级的非线性函数（如各种激活函数）。令<span class="math inline">\(\psi(\mathbf{z})=h^\prime(\mathbf{w}^\top\mathbf{z}+b)\mathbf{w}\)</span>，则<span class="math inline">\(f\)</span>的Jacobian矩阵行列式绝对值等于： <span class="math display">\[
\left|\text{det}\frac{\partial f}{\partial \mathbf{z}}\right|=\left|\text{det}(\mathbf{I}+\mathbf{u}\psi(\mathbf{z})^\top)\right|=\left|1+\mathbf{u}^\top\psi(\mathbf{z})\right|
\]</span> 但是<span class="math inline">\(f\)</span>并不保证总是可逆的，如<span class="math inline">\(h(x)=\tanh(x)\)</span>时，<span class="math inline">\(f\)</span>可逆的条件是<span class="math inline">\(\mathbf{w}^\top \mathbf{u}\geq-1\)</span>。</p>
<p>下面讨论如何保证可逆的条件。考虑将<span class="math inline">\(\mathbf{z}\)</span>分解为<span class="math inline">\(\mathbf{z}=\mathbf{z}_\bot+\mathbf{z}_\parallel\)</span>，其中<span class="math inline">\(\mathbf{z}_\bot\)</span>与<span class="math inline">\(\mathbf{w}\)</span>正交，<span class="math inline">\(\mathbf{z}_\parallel\)</span>与<span class="math inline">\(\mathbf{w}\)</span>平行，那么： <span class="math display">\[
f(z)=\mathbf{z}_\bot+\mathbf{z}_\parallel+\mathbf{u}h(\mathbf{w}^\top \mathbf{z}_\parallel +b)
\]</span> 实际上得到<span class="math inline">\(\mathbf{z}_\parallel\)</span>之后可以很容易的得到<span class="math inline">\(\mathbf{z}_\bot\)</span>，令<span class="math inline">\(\mathbf{y}=f(\mathbf{z})\)</span>，有： <span class="math display">\[
\mathbf{z}_\bot=\mathbf{y}-\mathbf{z}_\parallel-\mathbf{u}h(\mathbf{w}^\top\mathbf{z}_\parallel+b)
\]</span> 而<span class="math inline">\(\mathbf{z}_\parallel\)</span>与<span class="math inline">\(\mathbf{w}\)</span>平行，易知<span class="math inline">\(\mathbf{z}_\parallel=\alpha\frac{\mathbf{w}}{\parallel\mathbf{w}\parallel^2}\)</span>，其中<span class="math inline">\(\alpha\in\mathbb{R}\)</span>。</p>
<p>对式(16)两边同时乘以<span class="math inline">\(\mathbf{w}^\top\)</span>可得： <span class="math display">\[
\mathbf{w}^\top f(\mathbf{z})=\alpha+\mathbf{w}^\top\mathbf{u} h(\alpha+b)
\]</span> 当<span class="math inline">\(\alpha+\mathbf{w}^\top\mathbf{u} h(\alpha+b)\)</span>对于<span class="math inline">\(\alpha\)</span>是非递减函数的时候，<span class="math inline">\(f\)</span>是可逆的。因为<span class="math inline">\(\alpha+\mathbf{w}^\top\mathbf{u} h(\alpha+b)\)</span>是非递减函数时有<span class="math inline">\(1+\mathbf{w}^\top\mathbf{u}h^\prime(\alpha+b)\geq 0\equiv \mathbf{w}^\top \mathbf{u}\geq -\frac{1}{h^\prime(\alpha + b)}\)</span>，而<span class="math inline">\(0\leq h^\prime(\alpha + b) \leq 1\)</span>（<span class="math inline">\(\tanh\)</span>函数的性质），所以总是有<span class="math inline">\(\mathbf{w}^\top \mathbf{u}\geq-1\)</span>。</p>
<p>对于任意一个<span class="math inline">\(\mathbf{u}\)</span>，我们可以通过特定的方式构造一个<span class="math inline">\(\hat{\mathbf{u}}\)</span>使得<span class="math inline">\(\mathbf{w}^\top\hat{\mathbf{u}}&gt;-1\)</span>，即令<span class="math inline">\(\hat{\mathbf{u}}(\mathbf{w},\mathbf{u})=\mathbf{u}+[m(\mathbf{w}^\top\mathbf{u})-(\mathbf{w}^\top\mathbf{u})]\frac{\mathbf{w}}{\parallel\mathbf{w}\parallel^2}\)</span>，其中<span class="math inline">\(m(x)=-1+\log(1+e^x)\)</span>。</p>
<p><img src="http://qfxiao.me/img/image-20191031162515819.png" /></p>
<h1 id="methodology">Methodology</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>本文针对的是多变量时间序列<span class="math inline">\(x=\{x_1,x_2,\cdots,x_N\}\in R^{M\times N}\)</span>，<span class="math inline">\(N\)</span>为时间长度，其中某一时刻的观测值<span class="math inline">\(x_t\in R^M\)</span>为一个<span class="math inline">\(M\)</span>维的向量。作者使用<span class="math inline">\(x_{t-T:t}\in R^{M\times(T+1)}\)</span>来表示<span class="math inline">\(t-T\)</span>到<span class="math inline">\(t\)</span>之间的时间序列。</p>
<p><img src="http://qfxiao.me/img/image-20191024112404542.png" /></p>
<h2 id="overall-structure">Overall Structure</h2>
<p>算法的总体框架如下图所示：</p>
<p><img src="http://qfxiao.me/img/1571411043958.png" /></p>
<p>预处理模块主要是对数据进行标准化以及窗口切分。训练模块则根据输入的数据对正常模式进行捕捉，输出异常分数。在线检测模块则会定期执行。</p>
<h2 id="network-architecture">Network Architecture</h2>
<p>模型的总体结构如下图所示：</p>
<p><img src="http://qfxiao.me/img/1571411093161.png" /></p>
<p>在qnet中，首先GRU被用来建模样本的时间依赖关系，之后VAE将样本<span class="math inline">\(\mathbf{x}\)</span>映射到隐空间<span class="math inline">\(\mathbf{z}\)</span>。文中使用了Linear Gaussian State Space Model来建模隐变量之间的时间依赖关系。除此之外，作者还使用了Planar Normalizing Flow来将隐变量映射到复杂的非高斯分布。在pnet中，隐变量<span class="math inline">\(\mathbf{z}_{t-T:t}\)</span>被用来重建<span class="math inline">\(\mathbf{x}_{t-T:t}\)</span>，直观上来说，对样本的好的隐变量表示可以带来更好的重构效果。</p>
<p>从细节上来说，在时间<span class="math inline">\(t\)</span>，qnet的输入为<span class="math inline">\(\mathbf{x}_t\)</span>和<span class="math inline">\(\mathbf{e}_{t-1}\)</span>，两者经过GRU Cell之后会产生<span class="math inline">\(t\)</span>时间的<span class="math inline">\(\mathbf{e_t}\)</span>。<span class="math inline">\(\mathbf{e}_t\)</span>是GRU捕捉时间依赖性的关键，可以认为它包含了<span class="math inline">\(\mathbf{x}_{1:t}\)</span>的信息。之后<span class="math inline">\(\mathbf{e}_t\)</span>会和<span class="math inline">\(\mathbf{z}_{t-1}\)</span>进行拼接，进入标准的VAE变分网络结构，通过网络输出的参数<span class="math inline">\(\mu_{z_t},\sigma_{z_t}\)</span>采样得到隐变量<span class="math inline">\(\mathbf{z}_t^0\)</span>，此时隐变量可以说捕捉了时间依赖性。</p>
<p>网络中涉及到的公式如下所示：</p>
<p><span class="math display">\[
\begin{align}
e_t&amp;=(1-c_t^e)\circ\text{tanh}(w^ex_t+u^e(r_t^e\circ e_{t-1})+b^e)+c_t^e\circ e_{t-1}\\
\mu_{z_t}&amp;=w^{\mu_z}h^\phi([z_{t-1},e_t])+b^{\mu_z}\\
\sigma_{z_t}&amp;=\text{softplus}(w^{\sigma_z}h^\phi([z_{t-1},e_t])+b^{\sigma_z})+\epsilon^{\sigma_z}
\end{align}
\]</span></p>
<p>其中<span class="math inline">\(r_t^e=\text{sigmoid}(\mathbf{w}^{r^e}\mathbf{x}_t+\mathbf{u}^{r^e}\mathbf{e}_{t-1}+b^{r^e})\)</span>是GRU中的重置门，<span class="math inline">\(c_t^e=\text{sigmoid}(\mathbf{w}^{c^e}\mathbf{x}_t+\mathbf{u}^{c^e}\mathbf{e}_{t-1}+b^{c^e})\)</span>是GRU中的更新门。</p>
<p>此时<span class="math inline">\(\mathbf{z}_t^0\)</span>服从高斯分布，为了拟合复杂的后验分布，我们使用Planar Normalizing Flow来对<span class="math inline">\(\mathbf{z}_t^0\)</span>进行变换，最后得到经<span class="math inline">\(K\)</span>次变换后的随机变量<span class="math inline">\(\mathbf{z}_t^K\)</span>。</p>
<p>在时间<span class="math inline">\(t\)</span>，pnet试图通过<span class="math inline">\(\mathbf{z}_t^K\)</span>来重构<span class="math inline">\(\mathbf{x}_t\)</span>。首先<span class="math inline">\(\mathbf{z}\)</span>空间中的变量会根据Linear Gaussian State Space Model来进行“连接“，公式为<span class="math inline">\(\mathbf{z}_t=\mathbf{O}_\theta(\mathbf{T}_\theta\mathbf{z}_{t-1}+\mathbf{v}_t)+\boldsymbol{\epsilon}_t\)</span>，其中<span class="math inline">\(\mathbf{O}_\theta\)</span>和<span class="math inline">\(\mathbf{T}_\theta\)</span>为状态转移矩阵，<span class="math inline">\(\mathbf{v}_t\)</span>和<span class="math inline">\(\boldsymbol{\epsilon}_t\)</span>为随机噪声。之后<span class="math inline">\(\mathbf{z}_t\)</span>和<span class="math inline">\(\mathbf{d}_{t-1}\)</span>会作为GRU的输入，产生<span class="math inline">\(\mathbf{d}_t\)</span>。之后<span class="math inline">\(\mathbf{d}_t\)</span>会经过标准VAE中的生成网络，通过网络输出的高斯分布参数<span class="math inline">\(\mu_{x_t},\sigma_{x_t}\)</span>采样得到重构后的样本<span class="math inline">\(\mathbf{x}^\prime_t\)</span>。pnet中涉及到的公式如下所示： <span class="math display">\[
\begin{align}
d_t&amp;=(1-c_t^d)\circ\text{tanh}(w^dz_t+u^d(r_t^d\circ d_{t-1})+b^d)+c_t^d\circ d_{t-1}\\
\mu_{x_t}&amp;=w^{\mu_x}h^\theta(d_t)+b^{\mu_x}\\
\sigma_{x_t}&amp;=\text{softplus}(w^{\sigma_x}h^\theta(d_t)+b^{\sigma_x})+\epsilon^{\sigma_x}
\end{align}
\]</span></p>
<p>其中<span class="math inline">\(r_t^d=\text{sigmoid}(\mathbf{w}^{r^d}\mathbf{x}_t+\mathbf{u}^{r^d}\mathbf{d}_{t-1}+b^{r^d})\)</span>是GRU中的重置门，<span class="math inline">\(c_t^d=\text{sigmoid}(\mathbf{w}^{c^d}\mathbf{x}_t+\mathbf{u}^{c^d}\mathbf{d}_{t-1}+b^{c^d})\)</span>是GRU中的更新门。</p>
<h2 id="offline-model-training">Offline Model Training</h2>
<p>和传统VAE类似，模型的训练可以通过优化ELBO来完成。记长度为<span class="math inline">\(T+1\)</span>的输入序列为<span class="math inline">\(\mathbf{x}_{t-T:t}\)</span>，隐空间变量采样次数为<span class="math inline">\(L\)</span>，第<span class="math inline">\(l\)</span>个隐空间变量为<span class="math inline">\(\mathbf{l}^{(l)}_{t-T:t}\)</span>，损失函数可以写成如下形式：</p>
<p><span class="math display">\[
\tilde{\mathcal{L}}(\mathbf{x}_{t-T:t})\approx\frac{1}{L}\sum_{t=1}^L[\log(p_\theta(\mathbf{x}_{t-T:t}|\mathbf{z}_{t-T:t}^{(l)}))+\log(p_\theta(\mathbf{z}_{t-T:t}^{(l)}))-\log(q_\phi(\mathbf{z}_{t-T:t}^|\mathbf{x}_{t-T:t}))]
\]</span></p>
<p>第一项<span class="math inline">\(\log(p_\theta(\mathbf{x}_{t-T:t}|\mathbf{z}_{t-T:t}^{(l)}))\)</span>可以看作是重构误差；第二项<span class="math inline">\(\log(p_\theta(\mathbf{z}_{t-T:t}))=\sum_{i=t-T}^t \log(p_\theta(\mathbf{z}_i|\mathbf{z}_{i-1}))\)</span>通过Linear Gaussian State Space Model计算；第三项<span class="math inline">\(-\log(q_\phi(\mathbf{z}_{t-T:t}|\mathbf{x}_{t-T:t}))=-\sum_{i=t-T}^t\log(q_\phi(\mathbf{z}_i|\mathbf{z}_{i-1},\mathbf{x}_{t-T:i}))\)</span>为隐变量<span class="math inline">\(\mathbf{z}\)</span>后验分布的估计，同时<span class="math inline">\(\mathbf{z}_i\)</span>是经Planar Normalizing Flow转换过的。</p>
<h2 id="online-detection">Online Detection</h2>
<p>在训练好模型之后，就可以进行异常检测了。在时间<span class="math inline">\(t\)</span>，我们通过根据长度为<span class="math inline">\(T+1\)</span>的序列<span class="math inline">\(\mathbf{x}_{t-T:t}\)</span>来重构<span class="math inline">\(\mathbf{x}_t\)</span>，并根据重构概率<span class="math inline">\(\log(p_\theta(\mathbf{x}_t|\mathbf{z}_{t-T:t}))\)</span>来判定异常。定义<span class="math inline">\(\mathbf{x}_t\)</span>对应的异常分数<span class="math inline">\(S_t=\log(p_\theta(\mathbf{x}_t|\mathbf{z}_{t-T:t}))\)</span>，高异常分数代表样本<span class="math inline">\(\mathbf{x}_t\)</span>能够以大概率重构（因为模型是用正常样本训练，可以认为模型建模的是正常样本的分布，重构概率高就代表符合正常分布）。给定阈值之后便可根据异常分数来进行异常的判定。</p>
<h2 id="automatic-threshold-selection">Automatic Threshold Selection</h2>
<p>在异常检测阶段，需要根据设定的阈值和每个样本的异常分数来判断该样本是否为异常，所以阈值的选择十分重要。文中用到了一种根据<strong>Extreme Value Theory</strong>自动选择阈值的算法。对于一个分布，其中的极端事件往往位于分布的末尾，而Extreme Value Theory第一定理给出不管原始分布如何，这些极端事件的分布服从一个带参的分布族。因此，可以在对数据分布未知的情况下估计极端事件的分布。</p>
<p>除了Extreme Value Theory第一定理之外，Extreme Value Theory第二定理给出随机变量大于特定阈值<span class="math inline">\(t\)</span>的分布可以用Generalized Pareto Distribution来描述。作者使用了基于Extreme Value Theory第二定理的Peaks-Over-Threshold算法来进行阈值的选择。因为Extreme Value Theory第二定理给出随机变量大于特定阈值<span class="math inline">\(t\)</span>的分布，而在本文的场景中我们需要刻画的异常点的分布应该是小于一个给定阈值的分布，所以需要修改一下公式。</p>
<p>对于给定的数据，模型会给出对应的异常分数序列<span class="math inline">\(\{S_1,S_2,\cdots,S_{N^\prime}\}\)</span>，给定预先设定的阈值<span class="math inline">\(th\)</span>，<span class="math inline">\(S_i\)</span>极端部分（即小于<span class="math inline">\(th\)</span>的部分）的分布符合Generalized Pareto Distribution，公式如下： <span class="math display">\[
\bar{F}(s)=P(th-S&gt;s|S&lt;th)\sim(1+\frac{\gamma s}{\beta})^{-\frac{1}{\gamma}}
\]</span></p>
<p>其中<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>为分布的形状参数，本文使用极大似然估计来对参数进行估计。设参数的估计值分别为<span class="math inline">\(\hat{\gamma}\)</span>和<span class="math inline">\(\hat{\beta}\)</span>，最终的阈值<span class="math inline">\(th_F\)</span>由拟合得到的分布的分位数确定：</p>
<p><span class="math display">\[
th_F\simeq th-\frac{\hat{\beta}}{\hat{\gamma}}((\frac{qN^\prime}{N^\prime_{th}})^{-\hat{\gamma}}-1)
\]</span></p>
<p>其中<span class="math inline">\(q\)</span>为期望<span class="math inline">\(S&lt;th\)</span>的概率，<span class="math inline">\(N^\prime\)</span>为观测值的数量，<span class="math inline">\(N^\prime_{th}\)</span>为<span class="math inline">\(S_i&lt;th\)</span>的个数。</p>
<h2 id="anomaly-interpretation">Anomaly Interpretation</h2>
<p><span class="math display">\[
\log(p_\theta(\mathbf{x}_t|\mathbf{z}_{t-T:t}))=\sum_{i=1}^M\log(p_\theta(x_t^i|\mathbf{z}_{t-T:t}))
\]</span></p>
<h1 id="experiments">Experiments</h1>
<h2 id="datasets-and-metrics">Datasets and Metrics</h2>
<h2 id="overall-performance">Overall Performance</h2>
<p><img src="http://qfxiao.me/img/1571411131954.png" /></p>
<p><img src="http://qfxiao.me/img/1571411148667.png" /></p>
<h2 id="effects-of-major-techniques">Effects of Major Techniques</h2>
<p><img src="http://qfxiao.me/img/1571411161522.png" /></p>
<p><img src="http://qfxiao.me/img/1571411178434.png" /></p>
<h2 id="visualization-on-z-space-representations">Visualization on Z-Space Representations</h2>
<p><img src="http://qfxiao.me/img/1571411190279.png" /></p>
<p><img src="http://qfxiao.me/img/1571411212926.png" /></p>
<p><img src="http://qfxiao.me/img/1571411223173.png" /></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/10/16/GAIN-Missing-Data-Imputation-using-Generative-Adversarial-Nets/"><img class="thumbnail" src="http://qfxiao.me/img/1571228929894.png" alt="GAIN: Missing Data Imputation using Generative Adversarial Nets"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-16T12:19:10.000Z" title="2019-10-16T12:19:10.000Z">2019-10-16</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Time-Series-Imputation/">Time Series Imputation</a></span><span class="level-item">11 分钟 读完 (大约 1656 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/16/GAIN-Missing-Data-Imputation-using-Generative-Adversarial-Nets/">GAIN: Missing Data Imputation using Generative Adversarial Nets</a></h1><div class="content"><h1 id="abstract">Abstract</h1>
<p>本文基于GAN提出了一种时间序列缺失值填充（Time Series Imputation）的方法。其主要的思路为生成器<span class="math inline">\(G\)</span>从隐空间<span class="math inline">\(Z\)</span>生成完整的样本，而判别器<span class="math inline">\(D\)</span>则输出样本中不同部分为真实的概率。除此之外，作者提出了使用Hint Vector来揭示原始数据中缺失部分的信息，来优化训练过程。</p>
<p><a href="https://arxiv.org/abs/1806.02920">原文</a></p>
<h1 id="methodology">Methodology</h1>
<h2 id="problem-formulation">Problem Formulation</h2>
<p>考虑一个<span class="math inline">\(d\)</span>维的空间<span class="math inline">\(\mathcal{X}=\mathcal{X}_1\times \cdots\times \mathcal{X}_d\)</span>，设<span class="math inline">\(\mathbf{X}=(X_1,\cdots,X_d)\)</span>维空间<span class="math inline">\(\mathcal{X}\)</span>上的随机向量（即理想的完整的时间序列），记其分布为<span class="math inline">\(P(\mathbf{X})\)</span>。设<span class="math inline">\(\mathbf{M}=(M_1,\cdots,M_d)\)</span>为Mask向量表示<span class="math inline">\(\mathbf{X}\)</span>中被观察到的部分。（即标识时间序列哪些部分有缺失），取值为<span class="math inline">\(\{0,1\}^d\)</span>。</p>
<p>对于每一个<span class="math inline">\(i\in\{1,\cdots,d\}\)</span>，我们定义一个新空间<span class="math inline">\(\tilde{\mathcal{X}}=\mathcal{X}\cup\{*\}\)</span>，其中<span class="math inline">\(*\)</span>表示不属于任意<span class="math inline">\(\mathcal{X}_i\)</span>的一个点。令<span class="math inline">\(\tilde{\mathcal{X}}=\tilde{\mathcal{X}_1}\times\cdots\times\tilde{\mathcal{X}_d}\)</span>，同时定义一个新的随机变量（即我们观测到的含有缺失值的时间序列）<span class="math inline">\(\tilde{\mathbf{X}}=(\tilde{X}_1,\cdots,\tilde{X}_d)\in \tilde{\mathcal{X}}\)</span>： <span class="math display">\[
\tilde{X}_i=\begin{cases}X_i,&amp;\text{if } M_i=1\\*,&amp;\text{otherwise}\end{cases}
\]</span> 假设数据集的形式为<span class="math inline">\(\mathcal{D}=\{(\tilde{x}^i,m^i)\}^n_{i=1}\)</span>，我们的任务是从<span class="math inline">\(P(\mathbf{X}|\tilde{\mathbf{X}}=\tilde{x}^i)\)</span>上采样来对缺失值进行填充。</p>
<h2 id="model-architecture">Model Architecture</h2>
<p>模型的架构如下图所示：</p>
<p><img src="http://qfxiao.me/img/1571228929894.png" /></p>
<h3 id="generator">Generator</h3>
<p>生成器的输入有三项：<span class="math inline">\(\tilde{\mathbf{X}}\)</span>，<span class="math inline">\(\mathbf{M}\)</span>和随机噪声<span class="math inline">\(\mathbf{Z}\)</span>，输出设为<span class="math inline">\(\bar{\mathbf{X}}\)</span>。设生成器为映射<span class="math inline">\(G: \tilde{\mathcal{X}}\times\{0,1\}^d\times[0,1]^d\rightarrow \mathcal{X}\)</span>，而<span class="math inline">\(\mathbf{Z}\)</span>为<span class="math inline">\(d\)</span>维的高斯噪声。生成器的输出和填充后的时间序列定义为： <span class="math display">\[
\begin{align}
\bar{\mathbf{X}}&amp;=G(\tilde{\mathbf{X}},\mathbf{M},(1-\mathbf{M})\odot\mathbf{Z})\\
\hat{\mathbf{X}}&amp;=\mathbf{M}\odot\tilde{\mathbf{X}}+(1-\mathbf{M})\odot\bar{\mathbf{X}}
\end{align}
\]</span> <span class="math inline">\(\bar{\mathbf{X}}\)</span>即为生成器的直接输出，因为其实有些部分没有缺失，生成器还是会为每个部分输出值。</p>
<p><span class="math inline">\(\hat{\mathbf{X}}\)</span>为填充后的时间序列，对于缺失的部分采用生成器的输出进行填充。</p>
<h3 id="discriminator">Discriminator</h3>
<p>和原始的GAN不同的是，我们不需要判断整个样本是真实的或者是生成的，而是需要判断样本的那些部分是真实的或者是生成的，所以判别器为映射<span class="math inline">\(D: \mathcal{X}\rightarrow[0,1]^d\)</span>。判别器的具体目标函数将在后面讨论。</p>
<h3 id="hint">Hint</h3>
<p>Hint是一种提示机值，是一个和<span class="math inline">\(\mathbf{X}\)</span>相同维度的随机变量<span class="math inline">\(\mathbf{H}\)</span>，其分布依赖于<span class="math inline">\(\mathbf{M}\)</span>。<span class="math inline">\(\mathbf{H}\)</span>是由用户自己定义的，相当于一种不完整的<span class="math inline">\(\mathbf{M}\)</span>，用来作为判别器的额外输入。</p>
<h3 id="objective">Objective</h3>
<p>我们训练判别器最大化正确预测<span class="math inline">\(\mathbf{M}\)</span>的概率，而生成器最小化判别器正确预测<span class="math inline">\(\mathbf{M}\)</span>的概率，目标函数如下： <span class="math display">\[
\begin{align}
V(D,G)=&amp;\mathbb{E}_{\hat{X},M,H}[\mathbf{M}^T\log D(\hat{\mathbf{X}},\mathbf{H})\\&amp;+(1-\mathbf{M})^T\log(1-D(\hat{\mathbf{X}},\mathbf{H}))]
\end{align}
\]</span> 按照标准的GAN可以将优化函数写成以下的形式： <span class="math display">\[
\min_G\max_D V(D,G)
\]</span> 在这里判别器的任务可以看作是一个二分类，而目标函数就是二值交叉熵的定义，因此可以写为： <span class="math display">\[
\mathcal{L}(a,b)=\sum\limits_{i=1}^d[a_i\log(b_i)+(1-a_i)\log(1-b_i)]
\]</span> <span class="math inline">\(\mathbf{M}\)</span>可以看作Ground Truth，记<span class="math inline">\(\hat{\mathbf{M}}=D(\hat{\mathbf{X},\mathbf{H}})\)</span>，即判别器输出的预测，因此优化函数可以简记为： <span class="math display">\[
\min_G\max_D\mathbb{E}[\mathcal{L}(\mathbf{M},\hat{\mathbf{M}})]
\]</span></p>
<h2 id="gain-algorithm">GAIN Algorithm</h2>
<p>下面讨论GAIN算法的训练流程。</p>
<p>本文通过理论讨论，给出了生成Hint Vector的一个方法，首先定义随机变量<span class="math inline">\(\mathbf{B}=(B_1,\cdots,B_d)\in\{0,1\}^d\)</span>，<span class="math inline">\(\mathbf{B}\)</span>通过从<span class="math inline">\(\{1,\cdots,d\}\)</span>随机均匀采样一个<span class="math inline">\(k\)</span>，然后由下列公式得到： <span class="math display">\[
B_j=\begin{cases}1, &amp;\text{if }j\neq k\\0, &amp;\text{if }j=k\end{cases}
\]</span> 定义空间<span class="math inline">\(\mathcal{H}=\{0,0.5,1\}^d\)</span>，Hint Vector为<span class="math inline">\(\mathbf{H}=\mathbf{B}\odot\mathbf{M}+0.5(1-\mathbf{B})\in\mathcal{H}\)</span>。</p>
<p>判别器的训练过程如下：固定生成器<span class="math inline">\(G\)</span>，对一个大小为<span class="math inline">\(k_D\)</span>的mini-batch，独立同分布采样<span class="math inline">\(k_D\)</span>个<span class="math inline">\(z\)</span>和<span class="math inline">\(b\)</span>，用来计算<span class="math inline">\(\mathbf{Z}\)</span>和<span class="math inline">\(\mathbf{B}\)</span>。判别器的损失函数定义如下： <span class="math display">\[
\mathcal{L}_D(m,\hat{m},b)=\sum\limits_{i:b_i=0}[m_i\log(\hat{m}_i)+(1-m_i)\log(1-\hat{m}_i)]
\]</span> 判别器的优化函数为： <span class="math display">\[
\min_D-\sum\limits_{j=1}^{k_D}\mathcal{L}_D(m(j),\hat{m}(j),b(j))
\]</span> 其中<span class="math inline">\(\hat{m}(j)=D(\hat{x}(j),m(j))\)</span>。</p>
<p>在优化了判别器之后，需要优化生成器，对一个大小为<span class="math inline">\(k_G\)</span>的mini-batch，生成器的损失函数包含两个部分，一个是在缺失部分的损失：</p>
<p><span class="math display">\[
\mathcal{L}_G(m,\hat{m},b)=-\sum\limits_{i:b_i=0}(1-m_i)\log(\hat{m}_i)
\]</span> 一个是未缺失部分的损失： <span class="math display">\[
\mathcal{L}_M(x,x^\prime)=\sum\limits_{i=1}^d m_iL_M(x_i,x_i^\prime)
\]</span> 其中： <span class="math display">\[
L_M(x_i,x_i^\prime)=\begin{cases}(x_i^\prime-x_i)^2, &amp;\text{if }x_i\text{ is continuours},\\-x_i\log(x_i^\prime), &amp;\text{if }x_i\text{ is binary}.\end{cases}
\]</span> 最终的优化函数为： <span class="math display">\[
\min_G\sum\limits_{j=1}^{k_G}\mathcal{L}_G(m(j),\hat{m}(j),b(j))+\alpha\mathcal{L}_M(\tilde{x}(j),\hat{x}(j))
\]</span> 算法流程如下：</p>
<p><img src="http://qfxiao.me/img/1571228999385.png" /></p>
<h1 id="experiments">Experiments</h1>
<p>下表为在5个不同数据集上实验，与其他5种方法对比的结果：</p>
<p><img src="http://qfxiao.me/img/1571229028097.png" /></p>
<p>上图为GAIN、MissForest和Autoencoder三种模型在不同缺失比例、样本数量、特征维度下的对比曲线图。</p>
<p>下表为使用不同模型对时间序列进行填充之后，使用逻辑回归进行回归任务的性能：</p>
<p><img src="http://qfxiao.me/img/1571229051484.png" /></p>
<p>下图为GAIN、MissForest和Autoencoder三种模型在不同缺失比例下的AUROC曲线图：</p>
<p><img src="http://qfxiao.me/img/1571229066600.png" /></p>
<p>下表展示的是作者对时间序列填充算法保持特征-标签关系的能力。作者分别用完整的数据和填充后的数据用逻辑回归模型进行训练，将两者的权重求绝对值和均方根的结果。</p>
<p><img src="http://qfxiao.me/img/1571229079632.png" /></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2019/09/22/Anomaly-Detection-with-Generative-Adversarial-Networks-for-Multivariate-Time-Series/"><img class="thumbnail" src="http://qfxiao.me/img/1565783729478.png" alt="Anomaly Detection with Generative Adversarial Networks for Multivariate Time Series"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-22T14:32:18.000Z" title="2019-09-22T14:32:18.000Z">2019-09-22</time><span class="level-item"><a class="link-muted" href="/categories/Research/">Research</a><span> / </span><a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></span><span class="level-item">10 分钟 读完 (大约 1568 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/22/Anomaly-Detection-with-Generative-Adversarial-Networks-for-Multivariate-Time-Series/">Anomaly Detection with Generative Adversarial Networks for Multivariate Time Series</a></h1><div class="content"><h1 id="introduction">Introduction</h1>
<p>这篇文章提出了一个基于GAN的时间序列异常检测模型。</p>
<p><a href="https://arxiv.org/abs/1809.04758">原文</a></p>
<h2 id="contribution">Contribution</h2>
<ol type="1">
<li>提出了基于GAN的时间序列无监督异常检测模型</li>
<li>我们使用基于LSTM的GAN来对多变量时间序列进行建模</li>
<li>结合使用了Residual Loss和Discrimination Loss来进行异常的判断</li>
</ol>
<h2 id="background">Background</h2>
<h3 id="generative-adversarial-networks">Generative Adversarial Networks</h3>
<h4 id="gans-in-a-nutshell-an-extremely-simple-explanation">GANs In a Nutshell, an extremely simple explanation</h4>
<ul>
<li>我们想要从一个复杂的、高维的数据分布<span class="math inline">\(p_r(x)\)</span>上采样得到我们想要的数据点，然而<span class="math inline">\(p_r(x)\)</span>无法直接求得</li>
<li>代替方法：从一个简单的、已知的分布<span class="math inline">\(p_z(z)\)</span>上采样，然后学习一个Transformation <span class="math inline">\(G(z): z\rightarrow x\)</span>来将<span class="math inline">\(z\)</span>映射到<span class="math inline">\(x\)</span></li>
</ul>
<p><img src="http://qfxiao.me/img/1565836885697.png" /></p>
<h4 id="training-two-player-game">Training: Two-player Game</h4>
<ul>
<li><strong>Generator Network: </strong> 从随机分布<span class="math inline">\(p_z(z)\)</span>采样<span class="math inline">\(z\)</span>，通过映射生成样本<span class="math inline">\(x\)</span>，这个生成的样本要尽量“真实”。怎么“真实”？优化生成器参数<span class="math inline">\(\theta_G\)</span>最大化判别器对生成样本的评分即可</li>
<li><strong>Discriminator Network: </strong>接受一个样本<span class="math inline">\(x\)</span>，判断其是生成的样本还是真实的样本。在训练阶段，我们是知道一个样本<span class="math inline">\(x\)</span>到底是生成的还是真实的，所以优化判别器参数<span class="math inline">\(\theta_D\)</span>最小化判别器对生成样本的评分，最大化对真实样本的评分（即最大化分辨真实样本的能力）</li>
</ul>
<p><img src="http://qfxiao.me/img/1565836982707.png" /></p>
<p>形式化的来讲，优化函数如下：</p>
<p><span class="math display">\[\min\limits_{\theta_G}\max\limits_{\theta_D}V(G,D)=\mathbb{E}_{x\sim p_{data}(x)\log(\underbrace{D_{\theta{D}}(x)}_{判别器对真实样本的评分})}+\mathbb{E}_{z\sim p_z(z)}\log(1-\underbrace{D_{\theta_d}(G_{\theta_G}(z))}_{判别器对生成样本的评分})\]</span></p>
<p>训练过程如下：</p>
<p><img src="http://qfxiao.me/img/1565837745003.png" /></p>
<h3 id="long-short-time-memory-networks">Long Short Time Memory Networks</h3>
<h4 id="vanilla-recurrent-neural-networks">Vanilla Recurrent Neural Networks</h4>
<p>普通的神经网络：</p>
<p><img src="http://images0.cnblogs.com/blog2015/680781/201508/021735264703915.png" /></p>
<p>概括的来讲，可以涵盖为一个公式<span class="math inline">\(\hat{\mathbf{y}}=f(\mathbf{x})\)</span>。对于一个样本<span class="math inline">\(\mathbf{x}\)</span>，通过多层神经网络映射，输出<span class="math inline">\(\mathbf{y}\)</span>。</p>
<p>对于RNN，我们处理的是序列数据，也就是说所有样本之间并不是相互独立的。对于一个序列中的一个样本<span class="math inline">\(x_t\in\{x_1,x_2,\cdots,x_n\}\)</span>，将其输入到神经网络的时候，为了建模<span class="math inline">\(x_t\)</span>之前的子序列对<span class="math inline">\(x_t\)</span>的影响关系，需要将这个子序列的信息也输入到神经网络中，怎么做呢？为每一个样本点保存一个State。即定义<span class="math inline">\(h_t=g(\hat{y_t})=g(f(x_t))\)</span>，对于当前样本点，<span class="math inline">\(\hat{y_t}=f(x_t,h_{t-1})\)</span>。也就是说神经网络的输入不仅包含了当前样本点的特征，也包含了上一个样本点的“状态”(上一个样本点的“状态”又隐含了上上个样本点的“状态”...)，就像是为网络加上了短期记忆。</p>
<p><img src="https://adventuresinmachinelearning.com/wp-content/uploads/2017/09/Recurrent-neural-network.png" /></p>
<p><img src="http://qfxiao.me/img/1565838639451.png" /></p>
<p><img src="http://qfxiao.me/img/1565838658532.png" /></p>
<h4 id="gradient-flow-of-vanilla-rnn">Gradient Flow of Vanilla RNN</h4>
<p>下面来进行一些形式化的定义，假设在时刻<span class="math inline">\(t\)</span>网络输入特征为<span class="math inline">\(x_t\)</span>，输出隐含状态为<span class="math inline">\(h_{t}\)</span>，其不仅和当前输入<span class="math inline">\(x_t\)</span>有关，还和上一个隐含状态<span class="math inline">\(h_{t-1}\)</span>有关：</p>
<ul>
<li>当前时刻总的净输入<span class="math inline">\(z_t=Uh_{t-1}+Wx_t+b\)</span></li>
<li>当前时刻输出隐含状态<span class="math inline">\(h_t=f(z_t)\)</span></li>
<li>当前时刻输出<span class="math inline">\(\hat{y}_t=Vh_t\)</span></li>
</ul>
<p>RNN的梯度更新公式(推导过程比较复杂)：</p>
<p><span class="math display">\[\frac{\partial{\mathcal{L}}}{\partial U}=\sum\limits_{t=1}^T\sum\limits_{k=1}^t \delta_{t,k}\mathbf{h}_{k-1}^T\]</span></p>
<p><span class="math display">\[\frac{\partial{\mathcal{L}}}{\partial{W}}=\sum\limits_{t=1}^T\sum\limits_{k=1}^t \delta_{t,k}x_k^T\]</span></p>
<p><span class="math display">\[\frac{\partial\mathcal{L}}{\partial{b}}=\sum\limits_{t=1}^T\sum\limits_{k=1}^t\delta_{t,k}\]</span></p>
<p>其中<span class="math inline">\(\delta_{t,k}=\frac{\partial{\mathcal{L}}}{\partial{z_k}}=\text{diag}(f^\prime(z_k))U^T\delta_{t,k+1}\)</span>定义为第<span class="math inline">\(t\)</span>时刻的损失对第<span class="math inline">\(k\)</span>时刻隐藏神经层的净输入<span class="math inline">\(z_k\)</span>的导数，且<span class="math inline">\(z_k=Uh_{k-1}+Wx_k+b,1\leq k&lt;t\)</span>。</p>
<p>RNN的梯度流向如下图红箭头所示：</p>
<p><img src="http://qfxiao.me/img/1565838776226.png" /></p>
<p>RNN会遇到梯度消失和梯度爆炸的问题。根据前面的公式，<span class="math inline">\(\delta_{t,k}\)</span>实际上是递归定义的，展开得到：</p>
<p><span class="math display">\[\delta_{t,k}=\prod\limits_{\tau=k}^{t-1}(\text{diag}(f^\prime(z_\tau))U^T)\delta_{t,t}\]</span></p>
<p>如果定义<span class="math inline">\(\gamma\cong\parallel\text{diag}(f^\prime(z_\tau))U^T\parallel\)</span>，那么<span class="math inline">\(\delta_{t,k}\cong\gamma^{t-k}\delta_{t,t}\)</span>。在<span class="math inline">\(t-k\)</span>很大时，<span class="math inline">\(\gamma&lt;1\)</span>会导致梯度消失，<span class="math inline">\(\gamma&gt;1\)</span>时会导致梯度爆炸。</p>
<p><img src="http://qfxiao.me/img/1565839064829.png" /></p>
<p><img src="http://qfxiao.me/img/1565839083693.png" /></p>
<h4 id="long-short-time-memory">Long Short Time Memory</h4>
<p>LSTM是一种解决RNN梯度消失问题的改进版本：</p>
<p><img src="http://qfxiao.me/img/1565839135232.png" /></p>
<p>在LSTM中，维护了两个State，<span class="math inline">\(c_t\)</span>和<span class="math inline">\(h_t\)</span>。其中<span class="math inline">\(c_t\)</span>由遗忘门<span class="math inline">\(f\)</span>与上一个<span class="math inline">\(c_{t-1}\)</span>相乘(代表继承上一个Cell的信息并加以一定程度的遗忘)，加上输出门<span class="math inline">\(i\)</span>与Gate Gate <span class="math inline">\(g\)</span>相乘(Gate Gate代表当前的候选状态，输出门<span class="math inline">\(i\)</span>控制当前候选状态有多少信息需要保存)。最后，输出门<span class="math inline">\(o\)</span>控制当前时刻的Cell State <span class="math inline">\(c_t\)</span>有多少信息需要输出给外部状态<span class="math inline">\(h_t\)</span>。</p>
<p>三个门的计算方式为：</p>
<p><span class="math display">\[i_t=\sigma(W_ix_t+U_ih_{t-1}+b_i)\]</span></p>
<p><span class="math display">\[f_t=\sigma(W_fx_t+U_fh_{t-1}+b_f)\]</span></p>
<p><span class="math display">\[o_t=\sigma(W_ox_t+U_oh_{t-1}+b_o)\]</span></p>
<p><img src="http://qfxiao.me/img/1565839263008.png" /></p>
<p><img src="http://qfxiao.me/img/1565839279246.png" /></p>
<h2 id="methodology">Methodology</h2>
<p>总体框架图如Fig 1所示：</p>
<p><img src="http://qfxiao.me/img/1565783729478.png" /></p>
<h3 id="gan-with-lstm-rnn">GAN with LSTM-RNN</h3>
<p>网络结构上生成器和判别器都是LSTM，优化函数和普通GAN一样：</p>
<p><span class="math display">\[\min\limits_G\max\limits_D V(D,G)=\mathbb{E}_{x\sim p_{data}(x)}[\log D(x)]+\mathbb{E}_{z\sim p_z(z)}[\log (1-D(G(z)))]\]</span></p>
<h3 id="gan-based-anomaly-score">GAN-based Anomaly Score</h3>
<p>在测试阶段，需要使用梯度优化寻找一个使得<span class="math inline">\(G_{rnn}(z)\)</span>最接近<span class="math inline">\(X^{test}\)</span>的<span class="math inline">\(z^k\)</span>：</p>
<p><span class="math display">\[\min\limits_{Z^k}Error(X^{test},G_{rnn}(Z^k))=1-Similarity(X^{test},G_{rnn}(Z^k))\]</span></p>
<p>本文定义了两种Anomaly Score，一种是Residual Loss：</p>
<p><span class="math display">\[Res(X^{test}_t)=\sum\limits_{i=1}^n|x^{test,i}_t-G_{rnn}(Z^{k,i}_t)|\]</span></p>
<p>一种是Discrimination Loss，即判别器的输出<span class="math inline">\(D_{rnn}(x_t^{test})\)</span>。</p>
<p>总的Anomaly Score：</p>
<p><span class="math display">\[S^{test}_t=\lambda Res(X^{test}_t)+(1-\lambda)D_{rnn}(x^{test}_t)\]</span></p>
<h3 id="anomaly-detection-framework">Anomaly Detection Framework</h3>
<p>模型的算法流程如下：</p>
<p><img src="http://qfxiao.me/img/1565784946781.png" /></p>
<p>由于本文是多变量时间序列预测，而且时间序列的长度有可能比较长，作者使用了滑动窗口和PCA来进行预处理。</p>
<h2 id="experiments">Experiments</h2>
<p><img src="http://qfxiao.me/img/1565847175265.png" /></p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Deep-Learning/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/Deep-Learning/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Deep-Learning/">1</a></li><li><a class="pagination-link" href="/tags/Deep-Learning/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block line-height-inherit">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Research/"><span class="level-start"><span class="level-item">Research</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Research/Anomaly-Detection/"><span class="level-start"><span class="level-item">Anomaly Detection</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Research/GAN/"><span class="level-start"><span class="level-item">GAN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Research/Misc/"><span class="level-start"><span class="level-item">Misc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Research/RNN/"><span class="level-start"><span class="level-item">RNN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Research/Time-Series-Imputation/"><span class="level-start"><span class="level-item">Time Series Imputation</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Research/Tutorial/"><span class="level-start"><span class="level-item">Tutorial</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Technical-Notes/"><span class="level-start"><span class="level-item">Technical Notes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Technical-Notes/Misc/"><span class="level-start"><span class="level-item">Misc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/2020/03/01/Discovering-Physical-Concepts-with-Neural-Networks/"><p class="image is-64x64"><img class="thumbnail" src="http://qfxiao.me/img/image-20200301230011495.png" alt="Discovering Physical Concepts with Neural Networks"></p></a><div class="media-content size-small"><p><time dateTime="2020-03-01T14:55:02.000Z">2020-03-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/01/Discovering-Physical-Concepts-with-Neural-Networks/">Discovering Physical Concepts with Neural Networks</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Research/">Research</a> / <a class="link-muted" href="/categories/Research/Misc/">Misc</a></p></div></article><article class="media"><a class="media-left" href="/2020/02/27/Transfer-Anomaly-Detection-by-Inferring-Latent-Domain-Representations/"><p class="image is-64x64"><img class="thumbnail" src="http://qfxiao.me/img/image-20200109102830713.png" alt="Transfer Anomaly Detection by Inferring Latent Domain Representations"></p></a><div class="media-content size-small"><p><time dateTime="2020-02-27T12:02:18.000Z">2020-02-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/27/Transfer-Anomaly-Detection-by-Inferring-Latent-Domain-Representations/">Transfer Anomaly Detection by Inferring Latent Domain Representations</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Research/">Research</a> / <a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></p></div></article><article class="media"><a class="media-left" href="/2020/02/24/Deep-Anomaly-Detection-with-Deviation-Networks/"><p class="image is-64x64"><img class="thumbnail" src="http://qfxiao.me/img/image-20200113104953902.png" alt="Deep Anomaly Detection with Deviation Networks"></p></a><div class="media-content size-small"><p><time dateTime="2020-02-24T02:45:08.000Z">2020-02-24</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/24/Deep-Anomaly-Detection-with-Deviation-Networks/">Deep Anomaly Detection with Deviation Networks</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Research/">Research</a> / <a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></p></div></article><article class="media"><a class="media-left" href="/2020/01/31/Geant4-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"><p class="image is-64x64"><img class="thumbnail" src="http://qfxiao.me/img/image-20200131113557592.png" alt="Geant4 安装教程与调试环境配置"></p></a><div class="media-content size-small"><p><time dateTime="2020-01-31T03:25:59.000Z">2020-01-31</time></p><p class="title is-6"><a class="link-muted" href="/2020/01/31/Geant4-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">Geant4 安装教程与调试环境配置</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Technical-Notes/">Technical Notes</a> / <a class="link-muted" href="/categories/Technical-Notes/Misc/">Misc</a></p></div></article><article class="media"><a class="media-left" href="/2020/01/09/Complementary-Set-Variational-Autoencoder-for-Supervised-Anomaly-Detection/"><p class="image is-64x64"><img class="thumbnail" src="http://qfxiao.me/img/image-20200109102204802.png" alt="Complementary Set Variational Autoencoder for Supervised Anomaly Detection"></p></a><div class="media-content size-small"><p><time dateTime="2020-01-09T02:15:03.000Z">2020-01-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/01/09/Complementary-Set-Variational-Autoencoder-for-Supervised-Anomaly-Detection/">Complementary Set Variational Autoencoder for Supervised Anomaly Detection</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Research/">Research</a> / <a class="link-muted" href="/categories/Research/Anomaly-Detection/">Anomaly Detection</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Anomaly-Detection/"><span class="tag">Anomaly Detection</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Deep-Learning/"><span class="tag">Deep Learning</span><span class="tag is-grey-lightest">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flow-based-Model/"><span class="tag">Flow-based Model</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GAN/"><span class="tag">GAN</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Machine-Learning/"><span class="tag">Machine Learning</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RNN/"><span class="tag">RNN</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spectral/"><span class="tag">Spectral</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Statistics/"><span class="tag">Statistics</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Time-Series/"><span class="tag">Time Series</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Transfer-Learning/"><span class="tag">Transfer Learning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VAE/"><span class="tag">VAE</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Variational-Inference/"><span class="tag">Variational Inference</span><span class="tag is-grey-lightest">2</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hanzawa の 部屋" height="28"></a><p class="size-small"><span>&copy; 2020 Hanzawa</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://qfxiao.me',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>window.addEventListener("load", function () {
            MathJax.Hub.Config({
                'HTML-CSS': {
                    matchFontHeight: false
                },
                SVG: {
                    matchFontHeight: false
                },
                CommonHTML: {
                    matchFontHeight: false
                },
                tex2jax: {
                    inlineMath: [
                        ['$','$'],
                        ['\\(','\\)']
                    ]
                }
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>