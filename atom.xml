<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hanzawa の 部屋</title>
  
  
  <link href="http://qfxiao.me/atom.xml" rel="self"/>
  
  <link href="http://qfxiao.me/"/>
  <updated>2020-12-19T13:16:46.740Z</updated>
  <id>http://qfxiao.me/</id>
  
  <author>
    <name>Hanzawa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Recent Progress of Contrastive Learning in NeurIPS 2020</title>
    <link href="http://qfxiao.me/2020/12/19/Recent-Progress-of-Contrastive-Learning-in-NeurIPS-2020/"/>
    <id>http://qfxiao.me/2020/12/19/Recent-Progress-of-Contrastive-Learning-in-NeurIPS-2020/</id>
    <published>2020-12-19T13:15:28.000Z</published>
    <updated>2020-12-19T13:16:46.740Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Self-supervised Learning" scheme="http://qfxiao.me/categories/Research/Self-supervised-Learning/"/>
    
    
    <category term="Representation Learning" scheme="http://qfxiao.me/tags/Representation-Learning/"/>
    
    <category term="Self-supervised Learning" scheme="http://qfxiao.me/tags/Self-supervised-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Anomaly Detection Resource Collection</title>
    <link href="http://qfxiao.me/2020/10/27/Anomaly-Detection-Resource-Collection/"/>
    <id>http://qfxiao.me/2020/10/27/Anomaly-Detection-Resource-Collection/</id>
    <published>2020-10-27T04:49:22.000Z</published>
    <updated>2020-10-27T04:49:15.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>异常检测（Anomaly Detection或Outlier Detection或Novelty Detection）本身包含的东西很多，有时序（Time Series）的异常检测，图像（Image）的异常检测，视频（Video）的异常检测，图（Graph）的异常检测，表格数据（Categorical Data）的异常检测等等，他们之间有共性也有很大的区别。本文主要关注时序的异常检测，也包括图像和表格数据的异常检测。实际上时序异常检测还可以继续细分，如检测一条时序上逐点级别的异常，或者是在时序集合中检测异常的整条时序。而考虑到具体应用场景还会衍生出流式数据的异常检测和分布式异常检测等等。现阶段图像的异常检测主要是将关注的一类作为正常，而将其他类别的图像作为异常，类似于单分类。</p><p>更新中。。。</p><h1 id="literature">Literature</h1><h2 id="survey">Survey</h2><table><colgroup><col style="width: 37%" /><col style="width: 21%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Deep Learning for Anomaly Detection: A Survey</td><td>CoRR20</td><td><a href="https://arxiv.org/abs/2007.02500">📃Paper</a></td></tr><tr class="even"><td>Anomalous Instance Detection in Deep Learning: A Survey</td><td>CoRR20</td><td><a href="https://arxiv.org/abs/2003.06979">📃Paper</a></td></tr><tr class="odd"><td>Outlier Detection: Methods, Models, and Classification</td><td>ACM Comput. Surv.20</td><td><a href="https://dl.acm.org/doi/abs/10.1145/3381028">📃Paper</a></td></tr><tr class="even"><td>Outlier Analysis</td><td>Springer</td><td><a href="https://www.springer.com/gp/book/9783319475776">📕Book</a></td></tr><tr class="odd"><td>Outlier Detection for Temporal Data: A Survey</td><td>TKDE14</td><td><a href="https://ieeexplore.ieee.org/document/6684530">📃Paper</a></td></tr><tr class="even"><td>Anomaly detection: A survey</td><td>ACM Comput. Surv.09</td><td><a href="https://dl.acm.org/doi/10.1145/1541880.1541882">📃Paper</a></td></tr><tr class="odd"><td>A Survey of Outlier Detection Methodologies</td><td>Artificial Intelligence Review04</td><td><a href="https://link.springer.com/article/10.1007/s10462-004-4304-y">📃Paper</a></td></tr></tbody></table><h2 id="formalization">Formalization</h2><p>无监督异常检测 <span class="math display">\[\{\Theta^*,\mathbf W^*\}=\mathop{\arg\min}\limits_{\Theta,\mathbf W}\sum_{\mathbf x\in\mathcal X}\ell\left(\psi(\phi(\mathbf x;\Theta);\mathbf W)\right)\]</span> 第二步是Anomaly Scoring： <span class="math display">\[\mathcal S(\mathbf x)=f(\mathbf x, \phi_{\Theta^*},\psi_{\mathbf W^*})\]</span></p><h2 id="anomaly-detection-for-temporal-data">Anomaly Detection for Temporal Data</h2><p>在小标题里没用Time Series这个词而是用了Temporal Data的原因是Temporal Data的范围更广泛一些，凡是具有时间依赖性的数据都可归为Temporal Data，这包括了时间序列和视频这种固定频率采样的连续序列，也包含了事件流、轨迹、文本这种离散序列。当然本文主要探讨的是时间序列的异常检测，时间序列具有很强的时间依赖性，同时也具有广泛的应用，包括：</p><ul><li>金融市场（Financial Markets）：</li><li>运维（Ops）：</li><li>生理数据（Biological Data）：</li></ul><h3 id="categorization">Categorization</h3><p><img src="https://i.loli.net/2020/07/13/KeiSrsnlHVYIDE3.png" srcset="/img/loading.gif" /></p><h3 id="anomalies-with-a-given-time-series">Anomalies with a Given Time Series</h3><table><colgroup><col style="width: 57%" /><col style="width: 25%" /><col style="width: 9%" /><col style="width: 7%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Labels</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Opprentice: Towards Practical and Automatic Anomaly Detection Through Machine Learning</td><td></td><td></td><td></td></tr><tr class="even"><td>ALSR: An Adaptive Label Screening and Relearning Approach for Interval-Oriented Anomaly Detection</td><td></td><td></td><td></td></tr><tr class="odd"><td>Generic and Scalable Framework for Automated Time-series Anomaly Detection</td><td>KDD</td><td></td><td></td></tr><tr class="even"><td>A unifying framework for detecting outliers and change points from non-stationary time series data</td><td>KDD</td><td></td><td></td></tr><tr class="odd"><td>A Deep Neural Network for Unsupervised Anomaly Detection and Diagnosis in Multivariate Time Series Data</td><td>AAAI19</td><td></td><td></td></tr><tr class="even"><td>Non-Parametric Outliers Detection in Multiple Time Series A Case Study: Power Grid Data Analysis</td><td>AAA18</td><td></td><td></td></tr><tr class="odd"><td>Time Series Anomaly Discovery with Grammar-based Compression</td><td>EDBT15</td><td></td><td></td></tr><tr class="even"><td>A Self-Learning and Online Algorithm for Time Series Anomaly Detection, with Application in CPU Manufacturing</td><td>CIKM16</td><td></td><td></td></tr><tr class="odd"><td>Time-Series Aware Precision and Recall for Anomaly Detection: Considering Variety of Detection Result and Addressing Ambiguous Labeling</td><td>CIKM19</td><td></td><td></td></tr><tr class="even"><td>Granger Causality for Time-Series Anomaly Detection</td><td>ICDM12</td><td></td><td></td></tr><tr class="odd"><td>Modeling Multiple Time Series for Anomaly Detection</td><td>ICDM05</td><td></td><td></td></tr><tr class="even"><td>Outlier Detection for Time Series with Recurrent Autoencoder Ensembles</td><td>IJCAI19</td><td></td><td></td></tr><tr class="odd"><td>Stochastic Online Anomaly Analysis for Streaming Time Series</td><td>IJCAI17</td><td></td><td></td></tr><tr class="even"><td>A Unifying Framework for Detecting Outliers and Change Points from Time Series</td><td>TKDE06</td><td></td><td></td></tr><tr class="odd"><td>PSOM: Periodic Self-Organizing Maps for Unsupervised Anomaly Detection in Periodic Time Series</td><td>IWQoS17</td><td></td><td></td></tr><tr class="even"><td>Sparse Decomposition for Time Series Forecasting and Anomaly Detection</td><td>SDM18</td><td></td><td></td></tr><tr class="odd"><td>Time Series Anomaly Detection Based on Shapelet Learning</td><td>Computational Statistics19</td><td></td><td></td></tr><tr class="even"><td>Anomaly Detection in Streams with Extreme Value Theory</td><td>KDD17</td><td></td><td></td></tr><tr class="odd"><td>Semi-Markov Switching Vector Autoregressive Model-Based Anomaly Detection in Aviation Systems</td><td>KDD16</td><td></td><td></td></tr><tr class="even"><td>xStream: Outlier Dete‘x’ion in Feature-Evolving Data Streams</td><td>KDD18</td><td></td><td></td></tr><tr class="odd"><td>DILOF: Effective and Memory EfficientLocal Outlier Detection in Data Streams</td><td>KDD18</td><td></td><td></td></tr><tr class="even"><td>Online Novelty Detection on Temporal Sequences</td><td>KDD03</td><td></td><td></td></tr><tr class="odd"><td>An Approach to Spacecraft Anomaly Detection ProblemUsing Kernel Feature Space</td><td>KDD05</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="reconstruction">Reconstruction</h4><p>基于重构的异常检测 <span class="math display">\[\begin{align}\mathbf z=\mathcal E(\mathbf x;\Theta_{\mathcal E})\\\hat{\mathbf x}=\mathcal G(\mathbf z;\Theta_{\mathcal G})\end{align}\]</span> 目标函数 <span class="math display">\[\{\Theta_{\mathcal E}^*,\Theta_{\mathcal G}^*\}=\mathop{\arg\min}\limits_{\Theta_{\mathcal E},\Theta_{\mathcal G}}\sum_{\mathbf x\in\mathcal X}f(\mathbf x, \hat{\mathbf{x}})\]</span> 异常分数 <span class="math display">\[\mathcal S(\mathbf x)=f(\mathbf x, \hat{\mathbf{x}})\]</span> 其中<span class="math inline">\(f(\mathbf x, \hat{\mathbf x})\)</span>为重构误差</p><table><colgroup><col style="width: 37%" /><col style="width: 10%" /><col style="width: 16%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Labels</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Robust Anomaly Detection for Multivariate Time Series through Stochastic Recurrent Neural Network</td><td>KDD19</td><td>VAE, Flow-based Model, RNN</td><td><a href="https://dl.acm.org/doi/10.1145/3292500.3330672">📃Paper</a></td></tr></tbody></table><h4 id="supervised-learning">Supervised Learning</h4><table><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Labels</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td></td><td>KDD19</td><td>VAE, Flow-based Model, RNN</td><td><a href="https://dl.acm.org/doi/10.1145/3292500.3330672">📃Paper</a></td></tr></tbody></table><h4 id="others">Others</h4><table><colgroup><col style="width: 35%" /><col style="width: 11%" /><col style="width: 12%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Labels</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Time-Series Anomaly Detection Service at Microsoft</td><td>KDD19</td><td>Spectral Residual</td><td><a href="https://dl.acm.org/doi/10.1145/3292500.3330680">📃Paper</a></td></tr></tbody></table><h2 id="anomaly-detection-for-categorical-data">Anomaly Detection for Categorical Data</h2><p>对于表格数据，和时序、图像最大的区别在于表格数据的每一个维度，往往是有实际语义的，比如年龄、性别等等。而图像、时序（一维信号）这些属于Raw Data，本身是没有实际语义的，需要借助于特征抽取器来提取语义特征来服务于后面的任务，这也是表示学习（Representation Learning）的任务。</p><h3 id="categorization-1">Categorization</h3><h3 id="representation-learning-for-anomaly-detection">Representation Learning for Anomaly Detection</h3><h3 id="reconstrunction-based-anomaly-detection">Reconstrunction-based Anomaly Detection</h3><h3 id="predictability-modeling">Predictability Modeling</h3><h3 id="end-to-end-anomaly-scoring">End-To-End Anomaly Scoring</h3><p><span class="math display">\[\Theta^*=\mathop{\arg\min}\limits_{\Theta}\sum_{\mathbf x\in\mathcal X}\ell(\tau(\mathbf x;\Theta))\]</span></p><p><span class="math display">\[\mathcal S(\mathcal x)=\tau(\mathbf x; \Theta)\]</span></p><table><colgroup><col style="width: 63%" /><col style="width: 17%" /><col style="width: 10%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Labels</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Deep Anomaly Detection with Deviation Networks</td><td>KDD19</td><td></td><td></td></tr><tr class="even"><td>Learning Representations of Ultrahigh-dimensional Data for Random Distance-based Outlier Detection</td><td>KDD18</td><td></td><td></td></tr><tr class="odd"><td>Anomaly Detection for an E-commerce Pricing System</td><td>KDD19</td><td></td><td></td></tr><tr class="even"><td>Feedback-Guided Anomaly Discovery via Online Optimization</td><td>KDD18</td><td></td><td></td></tr><tr class="odd"><td>REMIX: Automated Exploration for Interactive Outlier Detection</td><td>KDD17</td><td></td><td></td></tr><tr class="even"><td>Distributed Local Outlier Detection in Big Data</td><td>KDD17</td><td></td><td></td></tr><tr class="odd"><td>Scalable Top-n Local Outlier Detection</td><td>KDD17</td><td></td><td></td></tr><tr class="even"><td>Outlier Detection by Active Learning</td><td>KDD06</td><td></td><td></td></tr><tr class="odd"><td>Feature Bagging for Outlier Detection</td><td>KDD05</td><td></td><td></td></tr></tbody></table><h2 id="anomaly-detection-for-image">Anomaly Detection for Image</h2><p>在近年来的机器学习/深度学习顶会中几乎都会出现图像数据的异常检测相关的论文。</p><h3 id="categorization-2">Categorization</h3><h3 id="reconstruction-1">Reconstruction</h3><table><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Labels</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Anomaly Detection with Robust Deep Autoencoders</td><td>KDD17</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="self-supervised">Self-Supervised</h3><h1 id="dataset">Dataset</h1><h1 id="benchmark">Benchmark</h1><p><img src="https://i.loli.net/2020/07/07/zleHDZ9PVibmaLo.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><p><img src="https://i.loli.net/2020/07/07/nNIBV9aWEPgFOfD.png" srcset="/img/loading.gif" style="zoom: 67%;" /></p><p><img src="https://i.loli.net/2020/07/07/FegvqUtILYV6hZA.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><p><img src="https://i.loli.net/2020/07/07/XWolYeUdb3qBu5m.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><h1 id="others-1">Others</h1><p><a href="https://www.ccf.org.cn/ccf/contentcore/resource/download?ID=99185">CCF推荐国际学术会议和期刊目录2019版📥</a></p><p>会考虑的会议和期刊列表（不是A类或者和异常检测相关性比较弱的会特别标出）：</p><ul><li>TKDE</li><li>TKDD（B类）</li><li>SIGMOD</li><li>SIGKDD</li><li>ICDE</li><li>CIKM（B类）</li><li>WSDM（B类）</li><li>ECML-PKDD（B类）</li><li>ICDM（B类）</li><li>EDBT（B类）</li><li>SDM（B类）</li><li>PAKDD（C类）</li><li>JMLR</li><li>AAAI</li><li>NeurIPS</li><li>ICML</li><li>ICLR</li><li>IJCAI</li><li>WWW</li><li>INFOCOM（弱相关）</li><li>IWQoS（B类，弱相关）</li></ul><p>使用的学术搜索为<a href="https://dblp.uni-trier.de/">DBLP</a>，在搜索的时候支持逻辑连接词，默认空白为AND。如果要用到OR，比如异常检测有的论文用的是"anomaly detection"，有的用的是"outlier detectin"，还有的用的是"novelty detection"，那就可以搜索"anomaly | outlier | novelty detection"。</p><table><colgroup><col style="width: 12%" /><col style="width: 31%" /><col style="width: 56%" /></colgroup><thead><tr class="header"><th style="text-align: left;">Feature</th><th style="text-align: left;">Query</th><th style="text-align: left;">Example</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">prefix search</td><td style="text-align: left;">default</td><td style="text-align: left;"><a href="http://dblp.org/search?q=sig">"sig"</a> matches "SIGIR" as well as "signal"</td></tr><tr class="even"><td style="text-align: left;">exact word</td><td style="text-align: left;">append dollar sign (<span class="math inline">\() | [&quot;graph\)</span>"](http://dblp.org/search?q=graph$) matches "graph", but not "graphics"</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">boolean AND</td><td style="text-align: left;">separate words by space</td><td style="text-align: left;"><a href="http://dblp.org/search?q=codd+model">"codd model"</a> matches "Codd's Relational Model" and "A Model by Codd"</td></tr><tr class="even"><td style="text-align: left;">boolean OR</td><td style="text-align: left;">connect words by pipe symbol (|)</td><td style="text-align: left;"><a href="http://dblp.org/search?q=graph%7Cnetwork">"graph|network"</a> matches "graph algorithm" and "Network Analysis"</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;异常检测（Anomaly Detection或Outlier Detection或Novelty Detection）本身包含的东西很多，有时序（Time Series）的异常检测，图像（Im</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/categories/Research/Anomaly-Detection/"/>
    
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/tags/Anomaly-Detection/"/>
    
  </entry>
  
  <entry>
    <title>Must Read Papers: Applications of Self-supervised Learning in Biomedical Signals</title>
    <link href="http://qfxiao.me/2020/10/27/Must-Read-Papers-Applications-of-Self-supervised-Learning-in-Biomedical-Signals/"/>
    <id>http://qfxiao.me/2020/10/27/Must-Read-Papers-Applications-of-Self-supervised-Learning-in-Biomedical-Signals/</id>
    <published>2020-10-27T03:32:52.000Z</published>
    <updated>2020-10-27T07:46:52.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>Self-supervised Learning (SSL)</p><p>更新中。。。</p><h1 id="self-supervised-learning">Self-supervised Learning</h1><table><colgroup><col style="width: 44%" /><col style="width: 11%" /><col style="width: 44%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Unsupervised Feature Learning via Non-Parametric Instance Discrimination</td><td>CVPR18</td><td><a href="https://openaccess.thecvf.com/content_cvpr_2018/papers/Wu_Unsupervised_Feature_Learning_CVPR_2018_paper.pdf">📃Paper</a></td></tr><tr class="even"><td>Momentum Contrast for Unsupervised Visual Representation Learning</td><td>CVPR20</td><td><a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/He_Momentum_Contrast_for_Unsupervised_Visual_Representation_Learning_CVPR_2020_paper.pdf">📃Paper</a></td></tr><tr class="odd"><td>A Simple Framework for Contrastive Learning of Visual Representations</td><td>ICML20</td><td><a href="https://arxiv.org/abs/2002.05709">📃Paper</a></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table><h1 id="ssl-in-video-representation-learning">SSL in Video Representation Learning</h1><table><colgroup><col style="width: 50%" /><col style="width: 13%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Video Representation Learning by Dense Predictive Coding</td><td>ICCVW19</td><td><a href="https://arxiv.org/abs/1909.04656">📃Paper</a></td></tr><tr class="even"><td>Memory-augmented Dense Predictive Coding for Video Representation Learning</td><td>ECCV20</td><td><a href="https://arxiv.org/abs/2008.01065">📃Paper</a></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table><h1 id="ssl-in-biomedical-signals">SSL in Biomedical Signals</h1><table><colgroup><col style="width: 50%" /><col style="width: 13%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Uncovering the structure of clinical EEG signals with self-supervised learning</td><td>CoRR20</td><td><a href="https://arxiv.org/abs/2007.16104">📃Paper</a></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table><h1 id="graph-neural-networks">Graph Neural Networks</h1><table><colgroup><col style="width: 45%" /><col style="width: 12%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th><strong>Title</strong></th><th><strong>Conf/Journal</strong></th><th><strong>Link</strong></th></tr></thead><tbody><tr class="odd"><td>Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks</td><td>KDD20</td><td><a href="https://dl.acm.org/doi/10.1145/3394486.3403118">📃Paper</a></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Self-supervised Learning (SSL)&lt;/p&gt;
&lt;p&gt;更新中。。。&lt;/p&gt;
&lt;h1 id=&quot;self-supervised-learning&quot;&gt;Self-superv</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Misc" scheme="http://qfxiao.me/categories/Research/Misc/"/>
    
    
    <category term="Papers" scheme="http://qfxiao.me/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Feature Learning via Non-Parametric Instance Discrimination</title>
    <link href="http://qfxiao.me/2020/09/23/Unsupervised-Feature-Learning-via-Non-Parametric-Instance-Discrimination/"/>
    <id>http://qfxiao.me/2020/09/23/Unsupervised-Feature-Learning-via-Non-Parametric-Instance-Discrimination/</id>
    <published>2020-09-23T12:36:57.000Z</published>
    <updated>2020-09-23T12:39:37.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>细节待完善。。。</p><p>本文基于样本分类和噪声对比估计提出了一个无监督表示学习算法。下图展示了一个Intuition Example：</p><p><img src="https://i.loli.net/2020/07/28/AimfJM7gtuDsPGQ.png" srcset="/img/loading.gif" style="zoom: 67%;" /></p><p>对于一个有监督的分类器，输入一张图片，作者观察到分类器的Softmax Response中较高的那些类都是在视觉上看起来比较接近的（美洲豹Leopard，美洲虎Jaguar，印度豹Cheetah），也就是说网络捕捉到了类间的视觉相似性，不过这是在有标签的情况下。对于无监督表示学习任务，作者将这个观察推广到了一个极端情况，就是把每一个样本都视作不同的类，然后让分类器来学习样本（类）间的视觉相似性。不过直接这么做会有严重的效率问题，所以作者还利用了Memory Bank机制和噪声对比估计来提高效率。</p><h1 id="proposed-method">Proposed Method</h1><p>学习一个嵌入表示函数<span class="math inline">\(\mathbf v=f_\theta(x)\)</span>。在表示空间中<span class="math inline">\(d_\theta(x,y)=\parallel f_\theta(x)-f_\theta(y)\parallel\)</span></p><p><img src="https://i.loli.net/2020/07/26/WICKVkhrBu6Mci5.png" srcset="/img/loading.gif" /></p><h2 id="non-parametric-softmax-classifier">Non-Parametric Softmax Classifier</h2><h3 id="parametric-classifier">Parametric Classifier</h3><p>在经过嵌入表示函数之后，得到表示向量<span class="math inline">\(\mathbf v_i=f_\theta(\mathbf x_i)\)</span>。要基于这个向量进行分类， <span class="math display">\[P(i|\mathbf v)=\frac{\exp(\mathbf w_i^\top\mathbf v)}{\sum_j\exp(\mathbf w_j^\top\mathbf v)}\]</span> ### Non-Parametric Classifier</p><p><span class="math display">\[P(i|\mathbf v)=\frac{\exp(\mathbf v_i^\top\mathbf v/\tau)}{\sum_j\exp(\mathbf v_j^\top\mathbf v/\tau)}\]</span></p><p>同时约束<span class="math inline">\(\parallel \mathbf v\parallel=1\)</span></p><p>最后的损失函数为负对数似然损失（negative log-likelihood）： <span class="math display">\[J(\theta)=-\sum_{i=1}^n\log P(i|f_\theta(x_i))\]</span></p><p>到这里，算法的大框架就确定下来了，剩下的就是解决两个效率上的问题。一个是损失函数的计算每次都需要计算整个训练集的表示，同时Softmax函数由于分母对应的项目很多（等于训练集大小）在效率上也有问题。</p><h3 id="learning-with-a-memory-bank">Learning with A Memory Bank</h3><p>这里解决第一个效率问题。要计算损失函数，需要遍历整个训练集获得对应的表示，而在训练的时候是一批一批的数据，每次重新计算表示效率很低。为了解决这个问题，作者引入了缓存机制，即加入一个memory bank <span class="math inline">\(V\)</span>，用来保存计算好的表示<span class="math inline">\(\mathbf f_i=f_\theta(x_i)\)</span>。一开始<span class="math inline">\(V\)</span>采用单位随机向量初始化，之后在训练的时候不断更新<span class="math inline">\(\mathbf f_i\rightarrow \mathbf v_i\)</span>。</p><h2 id="noise-contrastive-estimation">Noise Contrastive Estimation</h2><p>第二个效率问题很容易想到使用噪声对比估计（Noise Contrastive Estimation, NCE）来做。NCE主要是将计算复杂的分母作为一个参数来进行优化： <span class="math display">\[P(i|\mathbf v)=\frac{\exp(\mathbf v^\top\mathbf f_i/\tau)}{Z_i}\]</span></p><p>其中<span class="math inline">\(Z_i=\sum_{j=1}^n\exp(\mathbf v^\top_j\mathbf f_i/\tau)\)</span>，噪声分布<span class="math inline">\(P_n=1/n\)</span>，如果噪声样本数量是真实数据的<span class="math inline">\(m\)</span>倍，那么随意给定一个样本，其属于真实样本的后验概率为： <span class="math display">\[h(i,\mathbf v)=P(D=1|i,\mathbf v)=\frac{P(i|\mathbf v)}{P(i|\mathbf v)+mP_n(i)}=\sigma\left(s(\mathbf v)-\log \{m P_n(i)\}\right)\]</span> 其中<span class="math inline">\(\Delta s=s(\mathbf v)-\log [m P_n(i)]\)</span>。这里的真实数据分布<span class="math inline">\(P_d\)</span>为。NCE的损失函数就是要最大化<span class="math inline">\(h(i,\mathbf v)\)</span>，最小化<span class="math inline">\(h(i,\mathbf v^\prime)\)</span> <span class="math display">\[J_{NCE}(\theta)=-E_{P_d}[\log h(i,\mathbf v)]-m\cdot E_{P_n}[\log(1-h(i,\mathbf v^\prime))]\]</span> 为了计算<span class="math inline">\(Z_i\)</span> <span class="math display">\[Z\simeq Z_i\simeq nE_j[\exp(\mathbf v_j^\top\mathbf f_i/\tau)]=\frac{n}{m}\sum_{k=1}^m\exp(\mathbf v_{j_k}^\top\mathbf f_i/\tau)\]</span></p><h2 id="proximal-regularization">Proximal Regularization</h2><p>每个类别只有一个样本 <span class="math display">\[-\log h(i,\mathbf v_i^{(t-1)})+\lambda\parallel\mathbf v_i^{(i)}-\mathbf v_i^{(i-1)}\parallel^2_2\]</span></p><p>最终的损失函数：</p><p><span class="math display">\[J_{NCE}(\theta)=-E_{P_d}\left[\log h(i,\mathbf v_i^{(t-1)})-\lambda\parallel\mathbf v_i^{(t)}-\mathbf v_i^{(t-1)}\parallel^2_2\right]\\-m\cdot E_{P_n}\left[\log(1-h(i,\mathbf v^{\prime(t-1)}))\right]\]</span></p><p><img src="https://i.loli.net/2020/08/06/nvS3Z7jEldVcCep.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h2 id="weighted-k-nearest-neighbor-classifier">Weighted k-Nearest Neighbor Classifier</h2><p><span class="math inline">\(s_i=\cos(\mathbf v_i,\hat{\mathbf f})\)</span>。记<span class="math inline">\(\mathcal N_k\)</span>。<span class="math inline">\(w_c=\sum_{i\in\mathcal N_k}\alpha_i\cdot 1(c_i=c)\)</span>。</p><p><img src="https://i.loli.net/2020/07/29/Cl8xHeFZzXpvosL.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h1 id="experiments">Experiments</h1><p><img src="https://i.loli.net/2020/08/07/Zj628R7WYixJGog.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/08/07/k6rx1LoaZiFYGpQ.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="C:\Users\larry\AppData\Roaming\Typora\typora-user-images\image-20200807000724066.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/08/07/a3tNMQ7I2xmGdYA.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/08/07/CK7s3wHbmgnv2j4.png" srcset="/img/loading.gif" style="zoom:80%;" /></p><p><img src="https://i.loli.net/2020/08/07/rM7n3jhOiBbvJXf.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/08/07/PVL4nlGFtqOdyRh.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/08/07/F3miMXyOqg1DUtK.png" srcset="/img/loading.gif" style="zoom:67%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;细节待完善。。。&lt;/p&gt;
&lt;p&gt;本文基于样本分类和噪声对比估计提出了一个无监督表示学习算法。下图展示了一个Intuition Example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Self-supervised Learning" scheme="http://qfxiao.me/categories/Research/Self-supervised-Learning/"/>
    
    
    <category term="Representation Learning" scheme="http://qfxiao.me/tags/Representation-Learning/"/>
    
    <category term="Self-supervised Learning" scheme="http://qfxiao.me/tags/Self-supervised-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Representation Learning with Contrastive Predictive Coding</title>
    <link href="http://qfxiao.me/2020/09/17/Representation-Learning-with-Contrastive-Predictive-Coding/"/>
    <id>http://qfxiao.me/2020/09/17/Representation-Learning-with-Contrastive-Predictive-Coding/</id>
    <published>2020-09-17T12:08:53.000Z</published>
    <updated>2020-09-17T12:23:15.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>本文提出了一种表示学习框架：Contrastive Predictive Coding（CPC）。To be finished...</p><p><a href="https://arxiv.org/abs/1807.03748">原文</a></p><h1 id="proposed-method">Proposed Method</h1><h2 id="contrastive-predictive-coding">Contrastive Predictive Coding</h2><p>N-pair Loss: <span class="math display">\[\mathcal L=-\log\frac{\exp(f^+\cdot f^\top)}{\exp(f^+\cdot f^\top)+\sum_{f_j\neq f^\top}\exp(f^+\cdot f_j)}\]</span> 你有N个样本<span class="math inline">\(\{x_1,x_2,\cdots,x_N\}\)</span>，然后对应的表示为<span class="math inline">\(f_j\)</span>。假设当前样本为<span class="math inline">\(f^+\)</span>，在所有的<span class="math inline">\(f_j\)</span>中只有一个表示与<span class="math inline">\(f^+\)</span> match，记为<span class="math inline">\(f^\top\)</span>（可以理解为属于同一类，或者两个相似），其他的都是负样本。我们优化上面的优化公式就会拉近<span class="math inline">\(f^+\)</span>和<span class="math inline">\(f^\top\)</span>之间的距离（拉近同类），疏远<span class="math inline">\(f^+\)</span>和所有其他负样本<span class="math inline">\(f_j\)</span>的距离（疏远异类）。不过在N-pair Loss中，正负样本是根据标签来选取的，然而在这里我们没有标签。</p><p>下图展示了Contrastive Predictive Coding的结构：</p><p><img src="https://i.loli.net/2020/07/07/mcFYnVGasjkHrw5.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>对比学习 <span class="math display">\[\mathcal L(f_i)=-\log\frac{\exp(f_i\cdot f^\top)}{\sum_j\exp(f_i\cdot f_j)}\]</span> 设数据集（一个Batch）为<span class="math inline">\(\mathbf X=\{x_1,x_2,\cdots,x_N\}\)</span>，正样本对为，负样本对。</p><p>至于<span class="math inline">\(f(\cdot,\cdot)\)</span>的具体形式，其实<span class="math inline">\(\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\)</span>这个式子我们也是没法直接优化的，因为这个Density Ratio无法直接算出来。在这里，作者使用了一个替代的办法，就是用<span class="math inline">\(\mathbf c_t\)</span>来预测未来的隐变量<span class="math inline">\(\hat{\mathbf z}_{t+1},\hat{\mathbf z}_{t+2},\cdots\)</span>，而真实的隐变量<span class="math inline">\(\mathbf z_{t+1},\mathbf z_{t+2},\cdots\)</span>我们是知道的。这里预测直接使用权重矩阵和<span class="math inline">\(\mathbf c_t\)</span>相乘： <span class="math display">\[f_k(\mathbf x_{t+k},\mathbf c_t)=\exp\left(\mathbf z_{t+k}^T \cdot \mathbf W_k\mathbf c_t\right)\]</span></p><p>上式有点难以理解，实际上预测值<span class="math inline">\(\hat{\mathbf z}_{t+k}=\mathbf W_k\mathbf c_t\)</span>，而<span class="math inline">\(\mathbf z_{t+k}\hat{\mathbf z}_{t+k}\)</span>相当于计算两者的距离，即相似性。所以<span class="math inline">\(f_k(\cdot,\cdot)\)</span>其实是在计算预测值和真实值的相似性。现在大家先接受这个<span class="math inline">\(f(\cdot,\cdot)\)</span>的定义，因为后面会证明优化这个<span class="math inline">\(f(\cdot,\cdot)\)</span>就相当于在优化Density Ratio <span class="math inline">\(\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\)</span>。</p><p>一个来自<span class="math inline">\(p(x_{t+k}|c_t)\)</span>的正例和<span class="math inline">\(N-1\)</span>个来自<span class="math inline">\(p(x_{t+k})\)</span>的负例，目标函数（文中称为CPC Loss）为： <span class="math display">\[\mathcal L_N=-\mathop{\mathbb E}\limits_X\left[\log\frac{f_k(x_{t+k},c_t)}{\sum_{x_j\in X}f_k(x_j,c_t)}\right]\]</span></p><p>这里相当于做了个<span class="math inline">\(N\)</span>分类，因为这里损失函数等价于<span class="math inline">\(N\)</span>分类交叉熵损失函数。</p><blockquote><p>两个离散随机变量的交叉熵的定义为： <span class="math display">\[H(p,q) = -\sum_{x\in\mathcal X}p(x)\log q(x)\]</span> 对于交叉熵损失函数，设<span class="math inline">\(i\)</span>为真实标签，<span class="math inline">\(\hat{\boldsymbol y}\)</span>为分类器的输出。<span class="math inline">\(\frac{\exp(\hat y_i)}{\sum_j\exp(\hat y_j)}\)</span>为经过<code>Softmax</code>归一化之后的输出，其每个分量<span class="math inline">\(\hat y_j\)</span>相当于输入样本<span class="math inline">\(x\)</span>的预测类别为<span class="math inline">\(j\)</span>的概率。不过由于对于真实标签<span class="math inline">\(y\)</span>来说，只有<span class="math inline">\(y_i=1\)</span>，其他的分量都为<span class="math inline">\(0\)</span>，所以最后交叉熵只剩下一项： <span class="math display">\[\mathcal L=-\log\left(\frac{\exp(\hat y_i)}{\sum_j\exp(\hat y_j)}\right)\]</span></p></blockquote><p><span class="math display">\[I(x;c)=\sum_{x,c}p(x,c)\log\frac{p(x|c)}{p(x)}\]</span></p><p>编码器<span class="math inline">\(g_{enc}\)</span>将观测值<span class="math inline">\(\boldsymbol x_t\)</span>编码到隐变量<span class="math inline">\(\boldsymbol z_t=g_\text{enc}(\boldsymbol x_t)\)</span>（对应于局部信息），之后自回归模型<span class="math inline">\(g_{ar}\)</span>将所有<span class="math inline">\(t\)</span>之前的（包括<span class="math inline">\(t\)</span>）隐变量<span class="math inline">\(z_{\leq t}\)</span>压缩到一个上下文隐变量<span class="math inline">\(\boldsymbol c_t=g_\text{ar}(\boldsymbol z_{\leq t})\)</span>（希望具有预测性质，捕获了长时依赖性）。不过本文并不是基于<span class="math inline">\(\boldsymbol c_t\)</span>来预测未来的观测值<span class="math inline">\(\boldsymbol x_{t+k}\)</span>，即估计分布<span class="math inline">\(p_k(\boldsymbol x_{t+k}|\boldsymbol c_t)\)</span>，而这样的话又要用到MSE之类的Loss。文中利用的是最大化<span class="math inline">\(\boldsymbol c_t\)</span>和<span class="math inline">\(\boldsymbol x_{t+k}\)</span>之间的互信息<span class="math inline">\(\log \frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\)</span>（这种形式的互信息被称为是点互信息，详见<a href="https://en.wikipedia.org/wiki/Pointwise_mutual_information">维基</a>）。定义一个度量函数<span class="math inline">\(f(\cdot,\cdot)\)</span>，要求其具有与<span class="math inline">\(\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\)</span>成比例的性质： <span class="math display">\[f_k(x_{t+k},c_t)\propto\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\]</span> 这时最大化<span class="math inline">\(f(\cdot,\cdot)\)</span>就相当于最大化两者的互信息。</p><h2 id="mutual-information-estimation-explanation">Mutual Information Estimation Explanation</h2><p>现在回到公式<span class="math inline">\(I(x;c)=\sum_{x,c}p(x,c)\log\frac{p(x|c)}{p(x)}\)</span>，</p><h2 id="multual-information">Multual Information</h2><p>互信息是衡量已知一个变量时，另一个变量不确定性的减少程度的度量。对于离散随机变量，互信息的定义为： <span class="math display">\[I(X,Y)=\sum_{y\in\mathcal Y}\sum_{x\in\mathcal X}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}=\sum_{y\in\mathcal Y}\sum_{x\in\mathcal X}p(x,y)\log\frac{p(y|x)}{p(y)}\]</span> 对于连续随机变量，互信息的定义为： <span class="math display">\[I(X,Y)=\int_{\mathcal Y}\int_{\mathcal X}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}\mathrm dx\mathrm d y=\int_{\mathcal Y}\int_{\mathcal X}p(x,y)\log\frac{p(y|x)}{p(y)}\mathrm dx\mathrm d y\]</span> 互信息与熵之间的关系： <span class="math display">\[\begin{align}I(X,Y)&amp;=H(X)-H(X|Y)\\&amp;=H(Y)-H(Y|X)\\&amp;=H(X)+H(Y)-H(X,Y)\\&amp;=H(X,Y)-H(X|Y)-H(Y|X)\end{align}\]</span> 互信息与KL散之间的关系： <span class="math display">\[I(X,Y)=\mathbb E_Y[D_{KL}(p(x|y)\parallel p(x))]\]</span> 从图中可以很容易看出互信息相当于<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>两者的熵的“重叠”的部分：</p><p><img src="https://i.loli.net/2020/07/17/orRXnpugEzsZDwq.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>在表示学习中，互信息的应用越来越广泛。对于输入的数据<span class="math inline">\(X\)</span>，表示学习的目的是尽可能学到“好“的表示<span class="math inline">\(Z\)</span>，保留原始数据尽可能多的重要信息。如果使用基于重构的模型，我们就会要求最小化重构误差<span class="math inline">\(\parallel X-\hat{X}\parallel^2_2\)</span>，但是这种”逐像素“式的损失函数过于严苛，不利于模型学习高层语义信息。如果加入一个判别器来自动学习一个度量，首先增大了计算开销，同时GAN本身也有诸多问题。</p><p>现阶段很多工作使用互信息来判定学到的表示<span class="math inline">\(Z\)</span>的好坏，即最大化原始数据<span class="math inline">\(X\)</span>与表示<span class="math inline">\(Z\)</span>之间的互信息： <span class="math display">\[Z^*=\mathop{\arg\max}_{p(z|x)}I(X,Z)\]</span> 互信息越大意味着<span class="math inline">\(\log\frac{p(z|x)}{p(z)}\)</span>越大，即<span class="math inline">\(p(z|x)\)</span>要大于<span class="math inline">\(p(z)\)</span>。<span class="math inline">\(p(z)\)</span>可以看作是<span class="math inline">\(Z\)</span>的先验，而<span class="math inline">\(p(z|x)\gg p(z)\)</span>可以理解为在得知输入<span class="math inline">\(X\)</span>之后，我们能找到专属<span class="math inline">\(X\)</span>的那个编码<span class="math inline">\(Z\)</span>。</p><p>接下来作者证明优化<span class="math inline">\(\mathcal L_N\)</span>会使得<span class="math inline">\(f_k(\mathbf x_{t+k},\mathbf c_t)\)</span>和互信息接近。这里的<span class="math inline">\(p(\mathbf x_{t+k}|\mathbf c_t)\)</span>。设<span class="math inline">\(p(d=i|X,c_t)\)</span>为给定数据集（或者Batch）<span class="math inline">\(X\)</span>和context向量<span class="math inline">\(c_t\)</span>的条件下，样本<span class="math inline">\(x_i\)</span>为正样本的概率，有： <span class="math display">\[\begin{align}p(d=i|X,c_t)&amp;=\frac{p(x_i|c_t)\prod_{l\neq i}p(x_l)}{\sum^N_{j=1} p(x_j|c_t)\prod_{l\neq j}p(x_l)}\\&amp;=\frac{\frac{p(x_i|c_t)}{p(x_i)}}{\sum^N_{j=1}\frac{p(x_j|c_t)}{p(x_j)}}\end{align}\]</span></p><p>$$ <span class="math display">\[\begin{align}\mathcal L_\text{N}^\text{opt}&amp;=-\mathop{\mathbb E}\limits_X\log\left[\frac{\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}}{\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}+\sum_{x_j\in X_\text{neg}}\frac{p(x_j|c_t)}{x_j}}\right]\\\end{align}\]</span> $$</p><p><span class="math display">\[I(x_{t+k},c_t)\geq \log(N)-\mathcal L_N\]</span></p><p>可以说<span class="math inline">\(\mathcal L_N\)</span>作为互信息<span class="math inline">\(I(x_{t+k},c_t)\)</span>的一个下界。</p><h2 id="implementation-details">Implementation Details</h2><h1 id="experiments">Experiments</h1><h2 id="audio">Audio</h2><p><img src="https://i.loli.net/2020/07/07/kWectjL27MKy1dA.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/07/07/vhBRmpntw2Xx6J9.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/07/07/5QaDOCFvxLE6wqT.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/07/07/nA49kE1WP73oGQJ.png" srcset="/img/loading.gif" /></p><h2 id="vision">Vision</h2><p><img src="https://i.loli.net/2020/07/07/gkNnWo4zyUeBRCa.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/07/07/qH6BAJnhMcP9bKy.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/07/07/ezO1IibwvC5Mus8.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/07/07/sWNGXqv1n38kgcf.png" srcset="/img/loading.gif" /></p><h2 id="natural-language">Natural Language</h2><p><img src="https://i.loli.net/2020/07/07/Ly86Xu9n4KSOJge.png" srcset="/img/loading.gif" /></p><h2 id="reinforcement-learning">Reinforcement Learning</h2><p><img src="https://i.loli.net/2020/07/07/92XzLqltMUfCgTs.png" srcset="/img/loading.gif" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;本文提出了一种表示学习框架：Contrastive Predictive Coding（CPC）。To be finished...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxi</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Self-supervised Learning" scheme="http://qfxiao.me/categories/Research/Self-supervised-Learning/"/>
    
    
    <category term="Deep Learning" scheme="http://qfxiao.me/tags/Deep-Learning/"/>
    
    <category term="Self-supervised Learning" scheme="http://qfxiao.me/tags/Self-supervised-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Bagging and Random Forest: Machine Learning Ensemble Algorithms 3</title>
    <link href="http://qfxiao.me/2020/09/15/Bagging-and-Random-Forest-Machine-Learning-Ensemble-Algorithms-3/"/>
    <id>http://qfxiao.me/2020/09/15/Bagging-and-Random-Forest-Machine-Learning-Ensemble-Algorithms-3/</id>
    <published>2020-09-15T02:35:01.000Z</published>
    <updated>2020-09-15T03:07:06.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h1 id="bagging">Bagging</h1><p>Bagging的步骤如下图所示：</p><p><img src="https://i.loli.net/2020/09/15/x85li9MqPaeLShZ.jpg" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>分为几个步骤</p><ol type="1"><li><strong>随机采样 (Bootstrap)</strong>，按照固定的数目对数据集做<strong>有放回</strong>采样，一般情况下采样集的数目和训练集一样，设为<span class="math inline">\(N\)</span>，那么每个样本被采到的机率就是<span class="math inline">\(\frac{1}{N}\)</span>，采样<span class="math inline">\(N\)</span>次都没采到的机率是<span class="math inline">\((1-\frac{1}{N})^N\)</span>，当采样数目<span class="math inline">\(N\)</span>比较大的时候，即<span class="math inline">\(N\rightarrow \infty\)</span>有<span class="math inline">\((1-\frac{1}{N})^N\rightarrow \frac{1}{e}\approx 0.3679\)</span>。也就是说在每轮采样中，采样数目足够大的情况下，大概有<span class="math inline">\(36.79\%\)</span>的样本没有被采样中；</li><li>使用基模型在采样集上进行训练</li><li>进行模型组合的时候，对于分类问题，可以使用简单的投票法，对于回归问题，可以使用简单的平均法</li></ol><h1 id="random-forest">Random Forest</h1><p>随机森林 (Random Forest) 是Bagging模型的一种，</p><p><img src="https://i.loli.net/2020/09/15/jnJ8IKc52e1rtax.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><p>进行了诸多改进：</p><ol type="1"><li>使用CART决策树作为弱学习器，</li><li>使用列采样策略，对于划分特征的选择进行下采样，即有<span class="math inline">\(M\)</span>个特征，只会随机选取这<span class="math inline">\(M\)</span>个特征的一个子集进行特征选取，进一步减小方差</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;h1 id=&quot;bagging&quot;&gt;Bagging&lt;/h1&gt;
&lt;p&gt;Bagging的步骤如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/15/</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="Random Forest" scheme="http://qfxiao.me/tags/Random-Forest/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Anomaly Detection Algorithms Overview</title>
    <link href="http://qfxiao.me/2020/09/10/Unsupervised-Anomaly-Detection-Algorithms-Overview/"/>
    <id>http://qfxiao.me/2020/09/10/Unsupervised-Anomaly-Detection-Algorithms-Overview/</id>
    <published>2020-09-10T15:41:22.000Z</published>
    <updated>2020-09-18T05:42:24.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>未完待续，缓慢填坑中。。。</p><h1 id="lof">LOF</h1><h1 id="one-class-svm">One-Class SVM</h1><h1 id="isolation-forest">Isolation Forest</h1><p><img src="https://i.loli.net/2020/09/15/hSrG3W1JzbByEkH.png" srcset="/img/loading.gif" /></p><p>孤立森林 (Isolation Forest) 的思路和随机森林有异曲同工之妙（随机森林可以参考我的<a href="http://qfxiao.me/2020/09/15/Bagging-and-Random-Forest-Machine-Learning-Ensemble-Algorithms-3/">另一篇博文</a>），孤立森林本身也是一种树模型。孤立森林要解决的是无监督异常检测问题，即给定无标签的训练集，把其中的异常值挑选出来。孤立森林的基本假设是我不断选择特征进行分裂，达到停止条件后，每个叶子节点就对应一个/多个样本，正常样本由于比较集中，往往处于比较深的叶子节点，而异常样本由于偏离正常范围，所以往往处于比较浅的叶子节点。在此基础之上，孤立森林和随机森林类似，采用了集成的方法，即采样多个采样集，分别在采样集上训练，最后集成结果。孤立森林的主要特征如下：</p><ol type="1"><li>首先，和随机森林一样，孤立森林也需要对数据集进行采样，不过采样集的数量往往比较小；</li><li>对于每一棵树的建立，孤立森林采用的是随机选择特征进行划分，划分点也是随机选取（所以孤立森林的每棵树都是二叉树），这样做的原因可能是我们的数据没有标签，孤立森林对数据分布没有做特定假设，所以采用随机的方式</li></ol><p>对于异常点的判断，孤立森林根据的是该样本在树上的深度。对于样本<span class="math inline">\(x\)</span>在树<span class="math inline">\(T\)</span>上的异常分数，使用下面的公式进行计算： <span class="math display">\[h(x) = e + C(N_T)\]</span> 其中<span class="math inline">\(e\)</span>为该样本在树上的深度，<span class="math inline">\(C(N_T)\)</span>为用<span class="math inline">\(N_T\)</span>个样本构建二叉树的一个平均深度的估计值，可以由下式计算： <span class="math display">\[C(n)=2H(n-1)-\frac{2(n-1)}{n}\]</span> 其中<span class="math inline">\(H(n-1)\)</span>可以由<span class="math inline">\(\ln (n-1)+\gamma\)</span>估算，<span class="math inline">\(\gamma\)</span>为欧拉常数。</p><p>最后的异常分数采用集成的方式： <span class="math display">\[\mathcal S(x) = 2^{-\frac{E(h(x))}{C(\psi)}}\]</span> <span class="math inline">\(E(h(x))\)</span>代表样本<span class="math inline">\(x\)</span>在不同树上分数的均值，<span class="math inline">\(C(\psi)\)</span>代表主要用来做归一化，<span class="math inline">\(\psi\)</span>代表用来建树的采样集的样本数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;未完待续，缓慢填坑中。。。&lt;/p&gt;
&lt;h1 id=&quot;lof&quot;&gt;LOF&lt;/h1&gt;
&lt;h1 id=&quot;one-class-svm&quot;&gt;One-Class SVM&lt;/h1&gt;
&lt;h1 id=&quot;iso</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/categories/Technical-Notes/Anomaly-Detection/"/>
    
    
    <category term="LOF" scheme="http://qfxiao.me/tags/LOF/"/>
    
    <category term="OCSVM" scheme="http://qfxiao.me/tags/OCSVM/"/>
    
    <category term="iForest" scheme="http://qfxiao.me/tags/iForest/"/>
    
  </entry>
  
  <entry>
    <title>Model Selection and Evaluation: Machine Learning Basics</title>
    <link href="http://qfxiao.me/2020/09/09/Model-Selection-and-Evaluation-Machine-Learning-Basics/"/>
    <id>http://qfxiao.me/2020/09/09/Model-Selection-and-Evaluation-Machine-Learning-Basics/</id>
    <published>2020-09-09T03:33:25.000Z</published>
    <updated>2020-09-10T05:46:03.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h1 id="overfitting">Overfitting</h1><p>我们将模型输出与真实值之间的差异称为误差，如对于分类问题，我们可以使用模型分类错误的样本数量占总样本数的比例。模型在训练集（我们收集到的数据）上的误差称作是<strong>训练误差 (training error)</strong>，而在新样本（这里指的是新的样本而不是测试集，训练集测试集是从我们收集到的数据上人为划分出来的）上的误差称作是<strong>泛化误差 (generalization error)</strong>。对于机器学习算法，我们希望算法能学到数据背后的普遍规律，所以我们总是希望模型的泛化误差越小越好。</p><p>不过测试集对训练过程来说是未知的，所以模型只能尽量从训练集中发掘数据的普遍规律，要是模型把训练集学得”太好“了，很可能把训练集中不属于普遍规律的部分特点作为了一般性质，这就会导致泛化性能下降，我们称这种情况为<strong>过拟合 (overfitting)</strong>。反之，模型对训练集的特性学得不够，就会出现<strong>欠拟合 (underfitting)</strong>。关于过拟合和欠拟合，周志华老师的《机器学习》中有一张很好的图：</p><p><img src="https://i.loli.net/2020/09/09/tVPeQfu9CWLaSi6.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>一般来说，欠拟合比较容易克服，可以通过增加模型的复杂度来实现。而过拟合则比较难解决，一般而言可以通过增加数据量、加正则化约束来改善。</p><h1 id="model-selection">Model Selection</h1><p>对于一个机器学习任务，一般我们有多种模型供我们选择，并且模型也有不同的超参数，我们希望得到泛化性能尽可能高的模型。不过根据前面的讨论，新样本是未知的，所以没法直接得到泛化误差，而过拟合的存在使得我们不能贸然的根据模型在我们收集到的数据上的表现来选择模型（训练误差低不代表泛化误差低）。</p><p>我们假设无论是我们收集到的数据还是新样本都是从数据的真实分布中独立同分布采样得来，为此我们可以从数据中划分出一部分”测试集“，然后将模型在测试集上的表现作为泛化误差的近似，而剩下的部分用来模型训练。</p><p>那么如何划分训练集和测试集呢？比较常见的方法是”<span class="math inline">\(k\)</span>折交叉验证法“ (<span class="math inline">\(k\)</span>-fold cross validation)，一般<span class="math inline">\(k\)</span>常取<span class="math inline">\(10\)</span>，其基本思想如下图所示：</p><p><img src="https://i.loli.net/2020/09/09/8KEWDe3qMTsQoUx.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><p><span class="math inline">\(k\)</span>折交叉验证法首先将数据集均匀地划分为<span class="math inline">\(k\)</span>个部分，然后进行<span class="math inline">\(k\)</span>个循环，在每个循环中将第<span class="math inline">\(k\)</span>份作为测试集，其余的作为训练集，最后得到的结果进行平均。</p><h1 id="evaluation-metrics">Evaluation Metrics</h1><p>前面我们讨论了评测的框架，但是没有说具体的评测指标。实际上评测指标要根据任务来确定，并且不同的评测指标也有自己的特点。</p><h2 id="regression">Regression</h2><p>回归任务比较常用的评测标准是<strong>均方误差 (Mean Squared Error)</strong>： <span class="math display">\[\text{MSE}(f;D)=\frac{1}{m}\sum_{i=1}^m (f(x_i)-y_i)^2\]</span> 和<strong>平均绝对误差 (Mean Absolute Error)</strong>： <span class="math display">\[\text{MAE}(f;D)=\frac{1}{m}\sum_{i=1}^m |f(x_i)-y_i|\]</span></p><h2 id="classification">Classification</h2><h3 id="binary-classification">Binary Classification</h3><p>对于分类任务，最简单的想法是使用模型分类正确的比例来作为评测标准，我们称之为<strong>准确率 (Accuracy)</strong>： <span class="math display">\[\text{ACC}(f;D)=\frac{1}{m}\sum_{i=1}^m \mathbb{I}(f(x_i)=y_i)\]</span> 但准确率并不能满足我们的所有要求，比如说对于新冠病毒的分类任务，我们可能会更关注于对于所有患有新冠的病人，模型到底查出来了多少，而对于模型误把正常病人当作是患病的情况没有那么关注。对于二分类问题，我们可以将样例根据其真实类别与模型预测的类别划分为真正例 (true positive, TP)、假正例 (false positive, FP)、真反例 (true negative, TN) 和假反例 (false negative, FN) 四种，形成<strong>混淆矩阵 (Confusion Matrix)</strong>：</p><p><img src="https://i.loli.net/2020/09/09/xY8KAldMZSRwHnB.jpg" srcset="/img/loading.gif" /></p><p>下面给一个具体的例子：</p><p><img src="https://i.loli.net/2020/09/09/tCLxvZfNoEgqWID.png" srcset="/img/loading.gif" /></p><p>比如我们的任务是预测一张手写数字图片是不是<span class="math inline">\(5\)</span>，根据上图，右下角就是我们正确预测的是<span class="math inline">\(5\)</span>的图片，左下角就是本来是<span class="math inline">\(5\)</span>，但被预测成不是<span class="math inline">\(5\)</span>的图片；左上角是本来不是<span class="math inline">\(5\)</span>，我们也正确地预测出其不是<span class="math inline">\(5\)</span>的，右上角是本来不是<span class="math inline">\(5\)</span>却被预测成是<span class="math inline">\(5\)</span>的。是不是有点被绕晕了😀，只要记住T和F代表的是预测结果对还是不对，P和N代表的是模型预测当前样本是正例还是负例。</p><p>基于混淆矩阵，我们可以定义<strong>查准率 (Precision)</strong> 和<strong>查全率 (Recall)</strong> 这两个评测标准。</p><p>查准率，顾名思义，对于检测出来的正例，有多少是真正的正例，即查的准不准，公式为： <span class="math display">\[\text{Precision}=\frac{TP}{TP+FP}\]</span> 分母就是模型预测为正例的样本总数。</p><p>查全率，就对应刚才举的新冠的例子，我们比较在乎对于数据集中的正例，有多少被查出来了，公式为： <span class="math display">\[\text{Recall} = \frac{TP}{TP+FN}\]</span> 分母就是真实类别为正例的样本总数。一般来说，查准率和查全率是相互矛盾的，除非是特别简单的任务，很难兼顾查准率和查全率。</p><p><strong>F1分数 (F1 Score)</strong> 综合了查准率和查全率： <span class="math display">\[\text{F}1=\frac{2\cdot\text{Precision}\cdot\text{Recall}}{\text{Precision}+\text{Recall}}\]</span> 查准率和查全率中任意一项较低都会导致F1分数较低。有时候我们对待查准率和查全率的权重不同，这时候可以使用F<span class="math inline">\(_\beta\)</span>分数： <span class="math display">\[\text{F}_\beta=\frac{(1+\beta^2)\cdot \text{Precision}\cdot\text{Recall}}{(\beta^2\cdot\text{Precision})+\text{Recall}}\]</span> <span class="math inline">\(\beta=1\)</span>时等价于F1分数，<span class="math inline">\(\beta&gt;1\)</span>代表偏重查全率，<span class="math inline">\(\beta&lt;1\)</span>代表偏重查准率。</p><h3 id="multi-classification">Multi-classification</h3><p>前面的讨论都是基于二分类任务，如果是多分类任务的话， 对于每一类，我们将该类作为正例，其他类别作为负例，都能得到一个混淆矩阵。如果我们在每个混淆矩阵上计算评测指标，然后进行平均，这样就得到宏查准率 (macro-Precision)、宏查全率 (macro-Recall) 和宏F1分数 (macro-F1)。如果我们事先将混淆矩阵的TP、FP、TN、FN先进行平均，再计算评测指标，就得到了微查准率 (micro-Precision)、微查全率 (micro-Recall) 和微F1分数 (micro-F1)。</p><h3 id="pr-curve">PR-Curve</h3><p>很多情况下模型的输出是样本为正例的“概率值”或者是分数，分数越高的样本代表越可能是正例。这种时候需要人为划定阈值，规定高于阈值的样本是正例。不过阈值的划分相当于超参数的选取，同时我们会认为一个鲁棒的模型的性能应该不受阈值选取的左右。这个时候我们可以使用<strong>PR曲线 (Precision-Recall Curve)</strong>，即遍历所有可能的阈值，对于每个阈值，计算其对应的Precision和Recall，然后画在图上，最后会得到一系列离散的点（理论上应该是连续曲线，不过阈值是连续值，我们只能取离散值），形成PR-曲线。</p><p><img src="https://i.loli.net/2020/09/09/ecP8flTYZIDUBrV.png" srcset="/img/loading.gif" alt="2-class Precision-Recall curve: AP=0.88" style="zoom:67%;" /></p><p>模型性能越好，曲线就会越接近右上角的点，我们可以把PR曲线的曲线下面积 (PR-AUC) 作为评测标准。</p><h3 id="roc-curve">ROC-Curve</h3><p>ROC全称是<strong>受试者工作特征 (Receiver Operating Characteristic) 曲线</strong>, 和PR曲线类似，ROC曲线也是遍历不同的阈值计算点，不过ROC曲线计算的是真正例率 (True Positive Rate, TPR) 和假正例率 (False Positive Rate, FPR)，两者定义分别是： <span class="math display">\[\begin{align}\text{TPR}=\frac{TP}{TP+FN}\\\text{FPR}=\frac{FP}{TN+FP}\end{align}\]</span> 其中TPR就是查全率，而FPR是所有负例中没有检测出来的比例，这一项是越低越好。</p><p><img src="https://i.loli.net/2020/09/09/CdHrDaKAns4EN93.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>模型性能越好，曲线就会越接近左上角的点，我们可以把ROC曲线的曲线下面积 (ROC-AUC) 作为评测标准。</p><p>下面来总结一下PR曲线和ROC曲线之间的优缺点。</p><table><thead><tr class="header"><th></th><th>纵轴</th><th>横轴</th></tr></thead><tbody><tr class="odd"><td><strong>PR</strong></td><td><span class="math inline">\(\text{Precision}=\frac{TP}{TP+FP}\)</span></td><td><span class="math inline">\(\text{Recall} = \frac{TP}{TP+FN}\)</span></td></tr><tr class="even"><td><strong>ROC</strong></td><td><span class="math inline">\(\text{TPR}=\frac{TP}{TP+FN}\)</span></td><td><span class="math inline">\(\text{FPR}=\frac{FP}{TN+FP}\)</span></td></tr></tbody></table><p><img src="https://i.loli.net/2020/09/09/xY8KAldMZSRwHnB.jpg" srcset="/img/loading.gif" /></p><p>ROC的优点：</p><ul><li>相比PR仅关注正例，ROC同时关注正例和负例</li><li>相比PR不易受到正负例相对数量的影响，ROC的两个指标的计算都只涉及到P、N中的一列，正例或负例增加对总体影响不大。而PR曲线就不一样，两个指标的计算都涉及到了P、N两列，那么正例或负例样本数量的变化会造成较大影响。如负例突然增大，那么FP也会增大，这样Precision会降低，而Recall却不变。</li></ul><p>ROC的缺点：</p><ul><li>对于类别不平衡问题，存在大量负例，这样会带来大量的FP，而ROC的FPR却不会因为FP的大幅增长而剧烈改变，结果是这一类错误很难在ROC曲线中体现出来。所以ROC会呈现出一个过于乐观的评价。</li></ul><p>我们来尝试下是否如此，下面是用随机森林分类器，测试样本正负例数量比为1:1的情况下的ROC曲线和PR曲线：</p><p><img src="https://i.loli.net/2020/09/10/yqMDQh5oTs96SJm.png" srcset="/img/loading.gif" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/09/10/zFW941YTMl8yxiP.png" srcset="/img/loading.gif" style="zoom:50%;" /></p><p>在我们将正负例数量比调整为1:9之后（总数量相同），可以看到ROC曲线比较稳定，没出现较大变化，而PR曲线则出现了剧烈变化：</p><p><img src="https://i.loli.net/2020/09/10/HbnLtfGsiVc17q5.png" srcset="/img/loading.gif" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/09/10/FfYrb3SnkeZ9JTv.png" srcset="/img/loading.gif" alt="4" style="zoom:50%;" /></p><h1 id="bias-and-variance">Bias and Variance</h1><p>在机器学习中，偏差-方差分解是解释学习算法泛化性能的重要工具。假设我们要预测某一个地区的房子的房价，每一套房子都是一个样本，我们认为每个样本都是从总体分布<span class="math inline">\(P(X)\)</span>独立同分布采样得来的。不过我们不可能得到所有的样本，我们采样得到的训练集只是其中一个子集。那么，即使对于同样的测试样本，使用不同的训练集（训练集大小相同）训练出来的模型对测试样本的预测也是不一样的，我们将这一部分模型自身的不稳定性用<strong>方差 (Variance) </strong>来描述：<span class="math inline">\(\text{Var}(X)=E_D\left[(\hat f(X)-E[\hat f(X)])^2\right]\)</span>，方差越小代表模型稳定性越强。模型输出的期望与真实值之间的差距我们用<strong>偏差 (Bias) </strong>来描述：<span class="math inline">\(\text{Bias}(X)=E[\hat f(X)]-f(X)\)</span>。</p><p>泛化误差与方差、偏差有下列关系： <span class="math display">\[\begin{align}\text{Err}(X)&amp;=E\left[(y-\hat f(X))^2\right]\\&amp;=E\left[(f(X)+\varepsilon-\hat f(X))^2\right]\\&amp;= (E[\hat f(X)]-f(X))^2 + E\left[(\hat f(X)-E[\hat f(X)])^2\right]+\sigma_{\varepsilon}^2\\&amp;=\text{Bias}^2 + \text{Variance} + \text{Random Error}\end{align}\]</span> 也就是说泛化误差可以分解为方差、偏差和随机噪声之和。偏差刻画了模型的期望预测与真实值之间的偏离程度，方差刻画了不同训练集对模型性能的影响，他们之间的关系如下图所示：</p><p><img src="https://i.loli.net/2020/09/09/2IpmrwJGfqORU3z.png" srcset="/img/loading.gif" style="zoom: 33%;" /></p><p>图中左上角的部分是比较理想的情况，即方差和偏差都较小。但实际上方差和偏差往往是相互冲突的，如下图所示：</p><p><img src="https://i.loli.net/2020/09/09/GsREiklKYfuX3Ub.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>模型复杂度不足的时候，模型的拟合能力不够强，偏差主导了泛化误差，而随着模型复杂度的提高，模型的拟合能力逐渐提高，训练数据的扰动会造成模型发生显著变化，这时方差逐渐主导了泛化误差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;h1 id=&quot;overfitting&quot;&gt;Overfitting&lt;/h1&gt;
&lt;p&gt;我们将模型输出与真实值之间的差异称为误差，如对于分类问题，我们可以使用模型分类错误的样本数量占总样本数的比例。模型</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="Overfitting" scheme="http://qfxiao.me/tags/Overfitting/"/>
    
    <category term="Bias" scheme="http://qfxiao.me/tags/Bias/"/>
    
    <category term="Variance" scheme="http://qfxiao.me/tags/Variance/"/>
    
  </entry>
  
  <entry>
    <title>Decision Tree: Machine Learning Classification Algorithms 3</title>
    <link href="http://qfxiao.me/2020/09/02/Decision-Tree-Machine-Learning-Classification-Algorithms-3/"/>
    <id>http://qfxiao.me/2020/09/02/Decision-Tree-Machine-Learning-Classification-Algorithms-3/</id>
    <published>2020-09-02T10:47:55.000Z</published>
    <updated>2020-09-10T06:54:21.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>（PS：本文内容是学习高级树模型（GBDT，XGBoost）的基础，强烈建议在看那些内容之前先了解本文的内容！）</p><p>本文主要是介绍常用的三种决策树模型：ID3、C4.5和CART。决策树（Decision Tree）是一种<strong>有监督分类模型</strong>（稍加改造可进行回归任务）。</p><p>比如我们要判断一个瓜是不是好瓜，对于人来说，要判断一个瓜是不是好瓜，可能会先去看看色泽，然后看看根蒂，然后再敲一敲听听声音，这样经过一系列的决策过程。</p><p><img src="https://i.loli.net/2020/09/02/WuGQ79g4NcHqJDh.png" srcset="/img/loading.gif" style="zoom:50%;" /></p><p>决策树正是模拟了这样的过程。给定数据集，决策树会不断地选择最佳的特征将数据集进行切分（如选择色泽，然后将数据分为青绿、乌黑、浅白这几个子集），然后递归地进行下去，直到达到停止条件：</p><ol type="1"><li>每个叶子节点的样本都属于同一个类别</li><li>没有可供划分的特征，或者集合中每个样本所有特征取值都相同</li><li>决策树达到预先指定的最大深度</li></ol><p>所以决策树算法要解决的关键问题就是如何去选择当前最好的划分特征。</p><h1 id="id3">ID3</h1><p>ID3算法根据信息熵来进行特征的划分。信息熵是衡量一个随机变量信息量的度量，如果把数据集的标签<span class="math inline">\(y\)</span>看作是随机变量，那么<span class="math inline">\(y\)</span>的熵越小代表不确定性越小（集合里几乎都是一种类别的样本），熵越大代表不确定性越大（集合包含不同类别的样本），其公式为： <span class="math display">\[Ent(D)=-\sum_{k=1}^{|\mathcal Y|}p_k\log p_k\]</span> <span class="math inline">\(Ent(D)\)</span>代表集合<span class="math inline">\(D\)</span>对应的熵，<span class="math inline">\(|\mathcal Y|\)</span>是类别数量，二分类就是<span class="math inline">\(|\mathcal Y|=2\)</span>，<span class="math inline">\(p_k\)</span>为第<span class="math inline">\(k\)</span>个类别对应的概率（频率）。很自然的，我们可以根据划分前后熵的变化来确定划分特征的选择，如果划分之后熵减小的最多，那么这个特征也是最好的。假设我们选定特征<span class="math inline">\(a\)</span>来对集合进行划分，特征<span class="math inline">\(a\)</span>共有<span class="math inline">\(V\)</span>个离散取值，那么划分之后将会产生<span class="math inline">\(V\)</span>个子集，我们记每个子集为<span class="math inline">\(D^v, v=1,\cdots, V\)</span>。那么，信息增益可以写为： <span class="math display">\[Gain(D,a)=Ent(D)-\sum_{v=1}^V \frac{|D^v|}{|D|}Ent(D^v)\]</span> 不过，ID3存在两个致命的缺点：</p><ol type="1"><li>无法对连续取值的特征进行计算</li><li>对取值较多的特征具有很大的偏向性（极端的情况，把样本编号作为特征，由于每个样本的编号都不同，分裂之后每个自己只有一个样本/类别，熵是最小的）</li></ol><h1 id="c4.5">C4.5</h1><p>C4.5算法在ID3的基础上做了诸多改进。C4.5解决了ID3对于取值数目较多的特征的偏向性问题，其采用的方案很直观，即对信息增益除以一个系数，特征取值数目越多的特征系数越大，该划分标准被称作是信息增益率： <span class="math display">\[Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}\]</span> 其中<span class="math inline">\(IV(a)=-\sum_{v=1}^V\frac{|D^v|}{|D|}\log \frac{|D^v|}{|D|}\)</span>。其实<span class="math inline">\(IV(a)\)</span>可以看作是“划分之后每个样本属于集合<span class="math inline">\(v\)</span>的概率”这个随机变量的熵，划分的子集越多，划分之后属于哪个集合就越不确定，所以熵就越大。</p><p>不过信息增益率反而会对特征取值数目少的特征有所偏好，所以C4.5算法是先计算信息增益，确定信息增益高于平均值的候选集，再从中选择信息增益率最高的特征。</p><p>除此之外，C4.5还能处理连续取值的特征，其做法是“离散化”，即将连续取值划分为若干个离散的区间，一般二分比较常用。设连续特征<span class="math inline">\(a\)</span>，假设其出现了<span class="math inline">\(n\)</span>个取值，将其排序得到<span class="math inline">\(\{a^1,a^2,\cdots,a^n\}\)</span>，我们考虑每两个相邻节点的中点集合<span class="math inline">\(T_a=\{\frac{a^i+a^{i+1}}{2}|1\leq i \leq n-1\}\)</span>，之后我们就可以像考察离散属性值一样选择最优划分。</p><p>下图是在breast cancer数据上决策树的可视化（图片太大了，可以点开放大🔍看）：</p><p><img src="https://i.loli.net/2020/09/10/RNyxp8EM6BCsOHK.png" srcset="/img/loading.gif" /></p><h1 id="cart">CART</h1><p>CART (Classification and Regression Trees) 是一种应用广泛的决策树模型，既可应用于分类任务也可应用于回归任务。</p><h2 id="cart-regression">CART Regression</h2><p>我们先来说说CART怎么进行回归。在回归问题中，CART使用了MSE作为划分准则： <span class="math display">\[\frac{1}{N}\sum_{i=1}^N (f(x_i)-y_i)^2\]</span> 如果CART有<span class="math inline">\(M\)</span>片叶子，那么相当于CART将输入划分成了<span class="math inline">\(M\)</span>个单元<span class="math inline">\(R_m, m=1,\cdots,M\)</span>，也即有<span class="math inline">\(M\)</span>个输出，那么该CART在数据集上的MSE为： <span class="math display">\[\frac{1}{N}\sum_{m=1}^M\sum_{x_i\in R_m} (c_m-y_i)^2\]</span> 这里<span class="math inline">\(c_j\)</span>为叶子节点<span class="math inline">\(j\)</span>的输出，一般选为对应样本的均值<span class="math inline">\(c_m=\text{avg}(y_i|x_i\in R_m)\)</span>。这样，剩下的问题就是如何确定每次的切分特征和切分点了。假设选择的特征是<span class="math inline">\(j\)</span>，切分点<span class="math inline">\(s\)</span>，那么该划分方案对应的损失为： <span class="math display">\[\min_{c_1}\sum_{x_i\in R_1\{j,s\}}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2\{j,s\}}(y_i-c_2)^2\]</span> 遍历所有的<span class="math inline">\(j\)</span>和<span class="math inline">\(s\)</span>，我们就能找到最佳的特征和切分点： <span class="math display">\[\min_{j,s}\left[\min_{c_1}\sum_{x_i\in R_1\{j,s\}}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2\{j,s\}}(y_i-c_2)^2\right]\]</span></p><p>算法流程大致如下：</p><blockquote><p><strong>CART Decision Tree Algorithm</strong></p><p>INPUT: 数据集 <span class="math inline">\(D=\{(x_1,y_1),\cdots,(x_N,y_N)\}\)</span></p><p>OUTPUT: 预测值<span class="math inline">\(\{\hat y_1,\cdots,\hat y_N\}\)</span></p><p>PROCEDURE:</p><p><strong>1. 选取当前最优切分特征变量<span class="math inline">\(j^*\)</span>与最优切分点<span class="math inline">\(s^*\)</span></strong></p><p>设当前选择的切分变量为<span class="math inline">\(j\)</span>，切分点为<span class="math inline">\(s\)</span>那么可以根据切分点将数据集分为两个子集，一个是<span class="math inline">\(R_1(j,s)=\left\{x|x^{(j)}\leq s\right\}\)</span>，另一个是<span class="math inline">\(R_2(j,s)=\left\{x|x^{(j)}&gt; s\right\}\)</span>。 遍历所有的<span class="math inline">\(j\)</span>，求解 <span class="math display">\[\min_{j,s}\left[\min_{c_1}\sum\limits_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min\limits_{c_2}\sum\limits_{x_i\in R_2(j,s)}(y_i-c_2)^2\right]\]</span> 注意<span class="math inline">\(\hat c_1=\frac{1}{N_1}\sum\limits_{x_i\in R_1(j,s)}y_i\)</span> <strong>2. 用选定的<span class="math inline">\((j^*,s^*)\)</span>来划分区域并计算输出值</strong></p><p>此时，我们还需要确定这两个区域（划分到同一个区域的样本对应的输出是相同的）的输出值<span class="math inline">\(c_1\)</span>和<span class="math inline">\(c_2\)</span>，其确定方式是使得对应区域上的均方误差最小。这样我们相当于得到了给定<span class="math inline">\(j,s\)</span>下的损失，所以只要找出使得损失最小的<span class="math inline">\(j^*,s^*\)</span>即可：</p><p><strong>3. 递归地对划分出来的两个区域重复步骤1和步骤2，直到满足停止条件</strong></p><p><strong>4. 最后将输入空间划分为<span class="math inline">\(M\)</span>，输出<span class="math inline">\(f(x)=\sum_{m=1}^M \hat c_m I(x\in R_m)\)</span></strong></p></blockquote><p>下图是在波士顿房价数据上决策树的可视化（图片太大了，可以点开放大🔍看）：</p><p><img src="https://i.loli.net/2020/09/09/knOHuvsfyorTpxt.png" srcset="/img/loading.gif" /></p><h2 id="cart-classification">CART Classification</h2><p>从前面的讨论可以看到，CART回归树是一棵二叉树，对于分类任务，CART也是一棵二叉树。我们先来介绍CART的划分准则，再来介绍它是怎么进行划分的。</p><p>采用基尼系数作为准则，基尼系数的计算依赖于基尼值： <span class="math display">\[\begin{align}Gini(D)&amp;=1-\sum_{k=1}^{|\mathcal Y|}p_k^2\end{align}\]</span> 直观上来说，基尼值表示随机抽取两个样本，其类别不一致的概率</p><p>如果说一个特征越好，那么划分之后其每个子集对应的基尼值应该越小越好。基尼系数的定义为： <span class="math display">\[Gini\_index(D,a)=\sum_{v=1}^V \frac{|D^v|}{|D|}Gini(D^v)\]</span></p><p>对于离散取值特征，CART不会根据不同取值个数进行划分，而是和连续值类似，会确定一个“划分点”，将样本进行二分。比如对于特征<span class="math inline">\(a\)</span>，其对应取值为<span class="math inline">\(\{a^1,a^2,\cdots,a^n\}\)</span>，CART会考察每个取值，将样本集划分为特征<span class="math inline">\(a\)</span>是不是等于<span class="math inline">\(a^i\)</span>两部分，然后计算基尼系数，最终会采用基尼系数最小的取值作为划分点。</p><p>下图是在breast cancer数据上决策树的可视化（图片太大了，可以点开放大🔍看）：</p><p><img src="https://i.loli.net/2020/09/10/mMf2EVkI1NaQLdS.png" srcset="/img/loading.gif" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;（PS：本文内容是学习高级树模型（GBDT，XGBoost）的基础，强烈建议在看那些内容之前先了解本文的内容！）&lt;/p&gt;
&lt;p&gt;本文主要是介绍常用的三种决策树模型：ID3、C4.5和CART</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="ID3" scheme="http://qfxiao.me/tags/ID3/"/>
    
    <category term="C4.5" scheme="http://qfxiao.me/tags/C4-5/"/>
    
    <category term="CART" scheme="http://qfxiao.me/tags/CART/"/>
    
  </entry>
  
  <entry>
    <title>Support Vector Machine: Machine Learning Classification Algorithms 2</title>
    <link href="http://qfxiao.me/2020/08/26/Support-Vector-Machine-Machine-Learning-Classification-Algorithms-2/"/>
    <id>http://qfxiao.me/2020/08/26/Support-Vector-Machine-Machine-Learning-Classification-Algorithms-2/</id>
    <published>2020-08-25T18:09:24.000Z</published>
    <updated>2020-09-20T04:30:52.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>Still working on it😅...</p><p><a href="http://blog.pluskid.org/?page_id=683">blog</a></p><h1 id="hyperplane">Hyperplane</h1><p>超平面可以从代数和几何两方面来理解。超平面的代数定义可以看作是方程： <span class="math display">\[a_1x_1+\cdots+a_nx_n=d\]</span> 的所有解形成的集合，其中<span class="math inline">\(a_1,\cdots,a_n\)</span>为不全为<span class="math inline">\(0\)</span>的实数，<span class="math inline">\(d\)</span>也是实数。</p><p>从几何上来说，超平面可以看作是除空间<span class="math inline">\(R^n\)</span>自身外维度最大的仿射空间。</p><p><img src="https://i.loli.net/2020/09/07/WiMJQSe7lN8upfw.jpg" srcset="/img/loading.gif" /></p><h1 id="maximum-margin-classifier">Maximum Margin Classifier</h1><p><img src="https://i.loli.net/2020/08/26/vjuyCGXMr4msaUK.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>要谈SVM就得先谈线性分类器，其设置是这样的。对于<span class="math inline">\(D\)</span>维空间，我们有一堆数据<span class="math inline">\(X\)</span>，进行二分类任务，标签记为<span class="math inline">\(y\)</span>，其中<span class="math inline">\(y=-1\)</span>和<span class="math inline">\(y=1\)</span>分别代表不同的类别。我们的任务就是找到一个超平面，将正负例切分开来（先假设数据是线性可分的），这个超平面的方程可以表示为： <span class="math display">\[w^\top x+b=0\]</span> 我们令<span class="math inline">\(f(x)=w^\top x+b\)</span>，对于<span class="math inline">\(f(x)&lt;0\)</span>的样本，我们赋予其类别<span class="math inline">\(-1\)</span>，对于<span class="math inline">\(f(x)&gt;0\)</span>的样本，我们可以赋予其类别<span class="math inline">\(1\)</span>。对于相同的分类结果，我们可以找出无限种超平面。不过，对于那些样本特别靠近超平面的情况，鲁棒性并不好。为什么呢？因为这时只要超平面有轻微的变化，样本的分类结果就会发生变化。直观上来说，我们希望样本到超平面的距离越大越好。</p><p>我们先定义函数间隔的概念，函数间隔<span class="math inline">\(\hat \gamma=y(w^\top x+b)\)</span>，乘以<span class="math inline">\(y\)</span>的目的主要是保持非负性，表示起来方便。可见函数间隔的大小并不能表示样本距离，因为同一个超平面，法向量<span class="math inline">\(w\)</span>可以任意增大，函数间隔也会相应增大。</p><p>下面来推导点<span class="math inline">\(x\)</span>到超平面的距离。设<span class="math inline">\(x\)</span>在超平面上的投影为<span class="math inline">\(x_0\)</span>，到超平面的距离为<span class="math inline">\(\gamma\)</span>，<span class="math inline">\(w\)</span>为法向量，那么有： <span class="math display">\[x=x_0+\gamma\frac{w}{\parallel w\parallel}\]</span> 将上式带入到超平面方程可以得到 <span class="math display">\[\gamma=\frac{w^\top}{\parallel w\parallel}x+\frac{b}{\parallel w\parallel}\]</span> 我们称<span class="math inline">\(\gamma\)</span>为几何间隔。</p><p><img src="https://i.loli.net/2020/08/26/b6qLJWzHwFAPDne.png" srcset="/img/loading.gif" /></p><p>可以很容易看出函数间隔和几何间隔的关系： <span class="math display">\[\gamma = \frac{\hat \gamma}{\parallel w\parallel}\]</span> 前面提到我们希望几何间隔越大越好，于是可以直接最大化<span class="math inline">\(\gamma\)</span>，得到： <span class="math display">\[\begin{align}\max \space &amp;\gamma\\s.t. \space &amp; y_i(w^\top x_i+b)=\hat\gamma_i\geq\hat\gamma, \space i=1,\cdots,n\end{align}\]</span> 这里<span class="math inline">\(\hat \gamma=\gamma \parallel w\parallel\)</span>，根据前面的分析我们知道，对于同一个超平面，函数间隔<span class="math inline">\(\hat\gamma\)</span>可以随着<span class="math inline">\(\parallel w\parallel\)</span>的变化而变化，所以为了找到最优的<span class="math inline">\(\gamma\)</span>，我们可以考虑固定<span class="math inline">\(\parallel w\parallel\)</span>或者<span class="math inline">\(\hat\gamma\)</span>，这里我们固定<span class="math inline">\(\hat \gamma=1\)</span>，所以有： <span class="math display">\[\begin{align}\max &amp; \space \frac{1}{\parallel w\parallel},\\ s.t. \space&amp; y_i(w^\top x_i+b)\geq 1, \space i=1,\cdots,n\end{align}\]</span></p><p>下面的约束条件代表前提是所有样本分类正确，而<span class="math inline">\(\max\frac{1}{\parallel w\parallel}\)</span>代表最大化间隔。为了方便，我们将其化为等价的最小化形式： <span class="math display">\[\begin{align}\min &amp; \space \frac{1}{2}\parallel w\parallel^2,\\ s.t. &amp; y_i(w^\top x_i+b)\geq 1, \space i=1,\cdots,n\end{align}\]</span> 其中那些<span class="math inline">\(y_i(w^\top x_i+b)=1\)</span>的样本就是“支持向量”。这个优化问题是典型的二次凸优化问题，可以调用现成的算法去解决。不过我们可以使用拉格朗日乘子法来更高效的解决。</p><h1 id="dual-problem">Dual Problem</h1><p>拉格朗日乘子法可以将有<span class="math inline">\(d\)</span>个变量和<span class="math inline">\(k\)</span>个约束条件的最优化问题转化成有<span class="math inline">\(d+k\)</span>个变量的无约束最优化问题求解。</p><h2 id="lagrange-multiplier">Lagrange Multiplier</h2><p>对于以下有约束优化问题： <span class="math display">\[\begin{align}\min_x \space &amp; f(x)\\\text{s.t.} \space &amp; h_i(x)=0 \space (i=1,\cdots,m),\\&amp;g_j(x) \leq 0 \space (j=1,\cdots,n)\end{align}\]</span></p><p>引入拉格朗日乘子<span class="math inline">\(\boldsymbol\lambda = (\lambda_1,\lambda_2,\cdots,\lambda_n)^\top\)</span>和<span class="math inline">\(\boldsymbol\mu=(\mu_1,\mu_2,\cdots,\mu_m)^\top\)</span>，相应的广义拉格朗日函数 (generalized Lagrange function) 为： <span class="math display">\[L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu)=f(\boldsymbol x)+\sum_{j=1}^n \lambda_j g_j(\boldsymbol x)+\sum_{i=1}^m \mu_i h_i(\boldsymbol x)\]</span></p><p>其中<span class="math inline">\(\lambda_j\)</span>，<span class="math inline">\(\mu_i\)</span>被称作是拉格朗日乘子，<span class="math inline">\(\lambda_j \geq 0\)</span>。</p><h3 id="primal-problem">Primal Problem</h3><p>现在我们来讨论原问题的等价性。假设给定某个<span class="math inline">\(x\)</span>，如果<span class="math inline">\(x\)</span>违反约束条件，即存在某个<span class="math inline">\(x\)</span>使得<span class="math inline">\(h_i(x)\neq 0\)</span>或者<span class="math inline">\(g_j(x)&gt;0\)</span>，那么就有： <span class="math display">\[\max\limits_{\boldsymbol\lambda,\boldsymbol\mu:\lambda_j\geq 0} L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu)=+\infty\]</span> 如果存在某个<span class="math inline">\(x\)</span>使得<span class="math inline">\(h_i(x)\neq 0\)</span>，那么可以令<span class="math inline">\(\lambda_j \rightarrow +\infty\)</span>，如果存在<span class="math inline">\(g_j(x)&gt;0\)</span>，那么可令<span class="math inline">\(\mu_ih_i(x)\rightarrow +\infty\)</span>。</p><p>如果考虑以下极小化问题： <span class="math display">\[p^*=\min_x\max\limits_{\boldsymbol\lambda,\boldsymbol\mu:\lambda_j\geq 0} L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu)\]</span> 他与原始带约束最优化问题是等价的（因为不符合约束时会有<span class="math inline">\(+\infty\)</span>，而我们考虑的是极小化问题），我们将其记为原问题 (Primal problem)。</p><h3 id="dual-problem-1">Dual Problem</h3><p>如果先考虑最小化<span class="math inline">\(x\)</span>，再考虑最大化<span class="math inline">\(\boldsymbol\lambda\)</span>和<span class="math inline">\(\boldsymbol\mu\)</span>，这时有： <span class="math display">\[\max\limits_{\boldsymbol\lambda,\boldsymbol\mu:\lambda_j\geq 0}\min_x L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu)\]</span> 对偶问题 (Dual problem) <span class="math display">\[d^*=\max\limits_{\boldsymbol\lambda,\boldsymbol\mu:\lambda_j\geq 0}\min_x L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu)\]</span> 原问题和对偶问题的关系 <span class="math display">\[d^*=\max\limits_{\boldsymbol\lambda,\boldsymbol\mu:\lambda_j\geq 0}\min_x L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu) \leq \min_x\max\limits_{\boldsymbol\lambda,\boldsymbol\mu:\lambda_j\geq 0} L(\boldsymbol x,\boldsymbol\lambda,\boldsymbol\mu) = p^*\]</span></p><h3 id="kkt-condition">KKT Condition</h3><blockquote><p>对于原问题和对偶问题，设<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(g_i(x)\)</span>为凸函数，<span class="math inline">\(h_i(x)\)</span>为仿射函数，并且不等式约束<span class="math inline">\(c_i(x)\)</span>是严格可行的，则<span class="math inline">\(x^*\)</span>，<span class="math inline">\(\lambda^*\)</span>，<span class="math inline">\(\mu^*\)</span>分别是原问题和对偶问题的解的充分必要条件是满足下面的Karush-Kuhn-Tucker (KKT) 条件： <span class="math display">\[\begin{cases}\nabla_x L(x^*,\lambda^*,\mu^*)=0 &amp;\\ \lambda^*_j g_j(x^*)=0 &amp; j=1,\cdots n\\g_j(x^*)\leq 0 &amp; j=1,\cdots n\\\lambda_j^*\geq 0 &amp; j=1,\cdots n\\h_i(x^*) = 0 &amp; i = 1, \cdots m\end{cases}\]</span></p></blockquote><p>这告诉我们</p><h2 id="dual-form-of-svm-optimization">Dual Form of SVM Optimization</h2><p>支持向量机优化的对偶问题可以写为： <span class="math display">\[L(w,b,\alpha)=\frac{1}{2}\parallel w\parallel^2-\sum_{i=1}^n \alpha_i(y_i(w^\top x_i+b)-1)\]</span> 我们先令： <span class="math display">\[\begin{align}\frac{\partial L}{\partial w}=0&amp;\Rightarrow w=\sum_{i=1}^n\alpha_i y_i x_i\\\frac{\partial L}{\partial b}=0&amp;\Rightarrow \sum_{i=1}^n\alpha_i y_i =0\end{align}\]</span> 带回到<span class="math inline">\(L\)</span>得到： <span class="math display">\[\begin{align}L(w,b,\alpha)&amp;=\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_j y_i y_j x^\top_i x_j-\sum_{i,j=1}^n \alpha_i\alpha_jy_iy_jx^\top_ix_j-b\sum_{i=1}^n\alpha_iy_i+\sum_{i=1}^n\alpha_i\\&amp;=\sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i,j=1}^n \alpha_i\alpha_j y_i y_j x^\top_i x_j\end{align}\]</span> 于是得到关于<span class="math inline">\(\alpha\)</span>的对偶优化问题： <span class="math display">\[\begin{align}\max_\alpha &amp;\sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i,j=1}^n \alpha_i\alpha_j y_i y_j x^\top_i x_j\\\text{s.t. }&amp; \alpha_i\geq 0, i=1,\cdots,n\\&amp; \sum_{i=1}^n \alpha_i y_i = 0\end{align}\]</span></p><p>前面有提到我们根据<span class="math inline">\(f(x)=w^\top x + b\)</span>的输出来判定样本类别，而刚才得到<span class="math inline">\(w=\sum_{i=1}^n\alpha_i y_i x_i\)</span>，于是： <span class="math display">\[\begin{align}f(x) &amp;= (\sum_{i=1}^n \alpha_iy_ix_i)^\top x+b\\&amp;= \sum_{i=1}^n \alpha_i y_i \langle x_i, x\rangle + b\end{align}\]</span> 最后的<span class="math inline">\(\sum_{i=1}^n \alpha_i y_i \langle x_i, x\rangle + b\)</span>值得特别注意，这意味着我们对于测试样本<span class="math inline">\(x\)</span>的预测，只需要计算它与训练集的内积即可，同时由于所有非支持向量对应的<span class="math inline">\(\alpha\)</span>都是<span class="math inline">\(0\)</span>，我们只需要求一小部分内积。同时这个内积计算也是后面核方法应用的前提。</p><h1 id="kernel">Kernel</h1><p>到目前为止，我们的讨论都是在数据是线性可分的前提下进行讨论的，那么对于线性不可分的情况呢？答案是使用核方法。</p><p><img src="https://i.loli.net/2020/09/08/kSTVgelDjWqtu8v.png" srcset="/img/loading.gif" /></p><p>核方法的思想是，对于原始不可分的数据，我们假设原始数据通过一个映射<span class="math inline">\(\phi(\cdot)\)</span>就变得线性可分了。核方法相当于对数据找到了一种新的表示，如上图没法用一个超平面直接分割，但通过<span class="math inline">\(\phi(\cdot)\)</span>映射之后就变得可分了。原始的分类函数为： <span class="math display">\[f(x)= \sum_{i=1}^n \alpha_i y_i \langle x_i, x\rangle + b\]</span> 加上映射之后变为： <span class="math display">\[f(x)= \sum_{i=1}^n \alpha_i y_i \langle \phi(x_i), \phi(x)\rangle + b\]</span> 优化问题也变为： <span class="math display">\[\begin{align}\max_\alpha &amp;\sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i,j=1}^n \alpha_i\alpha_j y_i y_j \langle\phi(x_i), \phi(x_j)\rangle\\\text{s.t. }&amp; \alpha_i\geq 0, i=1,\cdots,n\\&amp; \sum_{i=1}^n \alpha_i y_i = 0\end{align}\]</span> 我们把计算两个向量在映射后的空间中的内积的函数叫做核函数 <span class="math display">\[f(x)= \sum_{i=1}^n \alpha_i y_i k(x_i, x) + b\]</span> 优化问题改为： <span class="math display">\[\begin{align}\max_\alpha &amp;\sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i,j=1}^n \alpha_i\alpha_j y_i y_j k(\phi(x_i), \phi(x_j))\\\text{s.t. }&amp; \alpha_i\geq 0, i=1,\cdots,n\\&amp; \sum_{i=1}^n \alpha_i y_i = 0\end{align}\]</span> 实际上，通过核函数，我们隐式地定义了一个映射<span class="math inline">\(\phi(\cdot)\)</span></p><p>常用核函数</p><table><thead><tr class="header"><th>名称</th><th>表达式</th><th>参数</th></tr></thead><tbody><tr class="odd"><td>线性核</td><td></td><td></td></tr><tr class="even"><td>多项式核</td><td></td><td></td></tr><tr class="odd"><td>RBF核</td><td></td><td></td></tr><tr class="even"><td>拉普拉斯核</td><td></td><td></td></tr><tr class="odd"><td>Sigmoid核</td><td></td><td></td></tr></tbody></table><h1 id="soft-margin">Soft Margin</h1><p>数据线性不可分的情况，除了数据本身结构非线性的原因之外（核方法），还有可能是因为噪声或者离群点。为了处理这种情况，我们可以允许一部分点在一定程度上偏离超平面，具体来说就是原来的约束条件<span class="math inline">\(y_i(w^\top x_i+b)\geq 1, \space i=1,\cdots,n\)</span>变成了： <span class="math display">\[y_i(w^\top x_i+b)\geq 1-\xi_i, \space i=1,\cdots,n\]</span> 其中<span class="math inline">\(\xi_i\geq 0\)</span>称作是松弛变量，代表样本<span class="math inline">\(i\)</span>允许的偏离程度。当然松弛变量不可能无限大，所以我们需要将<span class="math inline">\(\xi_i\)</span>加入到优化目标函数中使其尽量小，于是有： <span class="math display">\[\begin{align}\min &amp; \space \frac{1}{2}\parallel w\parallel^2+C\sum_{i=1}^n \xi_i,\\ s.t. &amp; y_i(w^\top x_i+b)\geq 1-\xi_i, \space i=1,\cdots,n\end{align}\]</span> 其中<span class="math inline">\(C\)</span>为控制最优化<span class="math inline">\(\parallel w\parallel\)</span>和松弛变量这两项的权重。这里的优化函数还是对偶问题之前的形式，我们马上会讨论对偶问题。</p><h1 id="numerical-optimization">Numerical Optimization</h1><p>这里讨论SVM高效求解的Sequential Minimal Optimization (SMO)算法。</p><p>坐标下降法是一种非梯度优化算法，</p><p><img src="https://i.loli.net/2020/09/08/I6AonzFRHGVBU3t.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/09/08/Hmr79nMlK4C8GeJ.png" srcset="/img/loading.gif" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Still working on it😅...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.pluskid.org/?page_id=683&quot;&gt;blog&lt;/a&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="SVM" scheme="http://qfxiao.me/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>Linear Regression and Logistic Regression - Machine Learning Classification Algorithms 1</title>
    <link href="http://qfxiao.me/2020/08/26/Linear-Regression-and-Logistic-Regression-Machine-Learning-Classification-Algorithms-1/"/>
    <id>http://qfxiao.me/2020/08/26/Linear-Regression-and-Logistic-Regression-Machine-Learning-Classification-Algorithms-1/</id>
    <published>2020-08-25T18:08:49.000Z</published>
    <updated>2020-09-19T11:45:47.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>Still working on it...</p><h1 id="linear-regression">Linear Regression</h1><h2 id="the-model">The Model</h2><p><span class="math display">\[\hat y = w^\top x + b\]</span></p><p><img src="https://i.loli.net/2020/09/04/Ji14CNOLADmysah.png" srcset="/img/loading.gif" /></p><p>损失函数： <span class="math display">\[\mathcal L(w) = \sum_{i=1}^N \parallel w^\top x_i -y_i\parallel^2\]</span> 写成矩阵形式 <span class="math display">\[\mathcal L(w) = \]</span></p><p>设训练集包含<span class="math inline">\(M\)</span>个样本，<span class="math inline">\(N\)</span>个特征，为了方便后续推导，我们添加一列全是<span class="math inline">\(1\)</span>的向量： <span class="math display">\[\mathbf X=\left(\begin{matrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1N} &amp; 1\\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2N} &amp; 1\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\x_{M1} &amp; x_{M2} &amp; \cdots &amp; x_{MN} &amp; 1 \end{matrix}\right)\]</span> 我们的模型 <span class="math display">\[\boldsymbol{\hat y} = \mathbf X \hat{\boldsymbol w}\]</span> 最终得到</p><h2 id="projection-matrix">Projection Matrix</h2><p><img src="https://i.loli.net/2020/09/17/zTRyQptEDPf5iIN.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><h2 id="probabilistic-interpretation">Probabilistic Interpretation</h2><p><span class="math display">\[\hat{\boldsymbol w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top\boldsymbol y\]</span></p><h1 id="regularization">Regularization</h1><p>当特征数<span class="math inline">\(N\)</span>大于样本数量<span class="math inline">\(M\)</span>时，容易发生过拟合。</p><p>过拟合的解决思路：</p><ol type="1"><li>增加数据量</li><li>降维，特征选择、特征提取</li><li>增加正则化</li></ol><p>常见的正则项有<span class="math inline">\(\ell_1\)</span>正则和<span class="math inline">\(\ell_2\)</span>正则。假设原始优化函数为 <span class="math display">\[\mathop{\arg\min}\limits_{\theta} \mathcal L(\theta)\]</span> 加入<span class="math inline">\(\ell_1\)</span>正则化之后 <span class="math display">\[\mathop{\arg\min}\limits_{\theta} \mathcal J_1(\theta)=\mathcal L(\theta)+\color{red}{\lambda\parallel \theta\parallel_1}\]</span> 加入<span class="math inline">\(\ell_2\)</span>正则化之后 <span class="math display">\[\mathop{\arg\min}\limits_{\theta} \mathcal J_2(\theta)=\mathcal L(\theta)+\color{red}{\lambda\parallel \theta\parallel_2^2}\]</span></p><p>上面两个公式是大家最常见到的形式，那么这两个公式是怎么来的呢？下面先从最优化的角度来推导一下。</p><h2 id="the-optimization-problem">The Optimization Problem</h2><p>一般来说，模型的参数量与模型的复杂度成正比，模型参数越多，越容易发生过拟合。要限制模型的复杂度，最自然的想法是限制参数中非零元素的个数，加入一个约束条件： <span class="math display">\[\begin{align}\min_\theta &amp;\space\mathcal L(\theta)\\\text{s.t.} &amp;\parallel \theta \parallel_0\space \leq\space C\end{align}\]</span> 这里<span class="math inline">\(\parallel \theta \parallel_0\)</span>代表参数<span class="math inline">\(\theta\)</span>中非零元素的个数。不过直接求解这个问题复杂度过高，我们可以采用近似的方式，不要求<span class="math inline">\(\theta\)</span>严格等于<span class="math inline">\(0\)</span>，而是接近<span class="math inline">\(0\)</span>即可，于是可以用<span class="math inline">\(\ell_1\)</span>范数或者<span class="math inline">\(\ell_2\)</span>范数来替代： <span class="math display">\[\begin{align}\min_\theta &amp;\space\mathcal L(\theta)\\\text{s.t.} &amp;\parallel \theta \parallel_1\space \leq\space C\end{align}\]</span> 或 <span class="math display">\[\begin{align}\min_\theta &amp;\space\mathcal L(\theta)\\\text{s.t.} &amp;\parallel \theta \parallel_2\space \leq\space C\end{align}\]</span> 对于上述的优化问题，我们可以使用拉格朗日乘子法将其变为无约束优化形式，以<span class="math inline">\(\ell_1\)</span>范数为例，有： <span class="math display">\[\begin{align}\min_\theta \max_\lambda &amp; \space\mathcal L(\theta) + \lambda (\parallel \theta \parallel_1-C)\\\text{s.t.} &amp; \space \lambda \geq 0\end{align}\]</span> 我们假设<span class="math inline">\(\lambda\)</span>的最优解为<span class="math inline">\(\lambda^*\)</span>，那么带入上式有： <span class="math display">\[\begin{align}\min_\theta &amp;\space\mathcal L(\theta) + \lambda^* (\parallel \theta \parallel_1-C) \\\Rightarrow&amp; \space\mathcal L(\theta) + \lambda^*\parallel\theta\parallel_1\end{align}\]</span> 这就是我们常看到的正则化优化形式。<span class="math inline">\(\ell_2\)</span>范数的推导类似，这里不再赘述。</p><h2 id="optimization-interpretation">Optimization Interpretation</h2><p>下面来从优化的角度进行直观解释，假设参数只有两个<span class="math inline">\(w_1\)</span>和<span class="math inline">\(w_2\)</span>。下图蓝色椭圆代表原始损失函数<span class="math inline">\(\mathcal L(\theta)\)</span>的一条等高线，红色为正则项约束对应的可行域。原函数的最优解一定在导数为<span class="math inline">\(0\)</span>处取得，也就是说导数与蓝色等高线相切，</p><p><img src="https://i.loli.net/2020/09/19/sEzbDiA3Gq9hoFj.png" srcset="/img/loading.gif"  /></p><h2 id="probabilistic-interpretation-1">Probabilistic Interpretation</h2><p>从贝叶斯的角度来看，无论是输入<span class="math inline">\(x\)</span>，输出<span class="math inline">\(y\)</span>还是参数<span class="math inline">\(\theta\)</span>，都是随机变量，我们将参数<span class="math inline">\(\theta\)</span>的先验记为<span class="math inline">\(p(\theta)\)</span>，而<span class="math inline">\(\theta\)</span>的后验有： <span class="math display">\[\begin{align}p(\theta|x,y)&amp;=\frac{p(x,y|\theta)\cdot p(\theta)}{p(x,y)}\\&amp;=\frac{p(x|\theta)\cdot p(y|x,\theta)\cdot p(\theta)}{p(x,y)}\\&amp;=\frac{p(x)\cdot p(y|x,\theta)\cdot p(\theta)}{p(x,y)}\\&amp;\propto p(y|x,\theta)\cdot p(\theta)\end{align}\]</span> 其中<span class="math inline">\(x\)</span>和<span class="math inline">\(\theta\)</span>相互独立，那么<span class="math inline">\(p(x|\theta)=p(x)\)</span>，而</p><p><img src="https://i.loli.net/2020/09/19/jRrPJGV2ALvqhIF.png" srcset="/img/loading.gif" style="zoom:33%;" /></p><h2 id="lasso-regression">LASSO Regression</h2><p>LASSO (Least Absolute Shrinkage and Selection Operator)</p><h2 id="ridge-regression">Ridge Regression</h2><p><span class="math display">\[\sum_{i=1}^N\parallel \hat{\boldsymbol w}^\top x_i-y_i\parallel^2+\lambda \hat{\boldsymbol w}^\top\hat{\boldsymbol w}\]</span> 最优解 <span class="math display">\[\hat{\boldsymbol w}^* = (\mathbf X^\top \mathbf X + \lambda \mathbf I)^{-1}\mathbf X^\top\boldsymbol y\]</span></p><h1 id="logistic-regression">Logistic Regression</h1><p>假设我们线性回归的对象不是标签，而是关于标签的一个函数<span class="math inline">\(g(y)\)</span>， <span class="math display">\[g(y)=w^\top x+b\]</span> 取反函数得到 <span class="math display">\[y=g^{-1}(w^\top x+b)\]</span> 我们就得到了广义线性模型，可以将线性回归适用到更广的情形</p><h2 id="the-model-1">The Model</h2><p>将线性回归的输出值与标签<span class="math inline">\(y\)</span>联系起来，最直观的想法是使用一个单位阶跃函数： <span class="math display">\[y=\begin{cases}0, &amp;z&lt;0\\0.5, &amp;z=0\\1, &amp;z&gt;0\end{cases}\]</span> 这样，对于线性回归输出大于<span class="math inline">\(0\)</span>的认为是正样本，小于<span class="math inline">\(0\)</span>的认为是负样本。不过这样的函数是不可导的，我们可以使用一个替代函数： <span class="math display">\[\sigma(z)=\sigma(w^\top x+b)=\frac{1}{1+e^{-(w^\top x+b)}}\]</span> 其函数图像如下图所示：</p><p><img src="https://i.loli.net/2020/09/14/xa6QIhbGi4eCog1.png" srcset="/img/loading.gif" style="zoom:50%;" /></p><p>该函数被称为是Sigmoid函数，其导数具有以下性质： <span class="math display">\[\sigma^\prime(x)=\sigma(x)(1-\sigma(x))\]</span> 其输出在<span class="math inline">\(0-1\)</span>之间，可以用作概率解释。</p><p>这样我们就有 <span class="math display">\[y=\frac{1}{1+e^{-(w^\top x+b)}}\]</span> 我们可以通过变换将其写成广义线性模型的形式，即： <span class="math display">\[\log \frac{y}{1-y}=w^\top x+b\]</span> 从这一层面上可以认为逻辑回归是以“对数几率”为对象的线性回归</p><h2 id="loss-function">Loss Function</h2><p>前面我们说过Sigmoid函数的输出在<span class="math inline">\(0-1\)</span>之间，可以从概率分布的角度来解释。我们设定Sigmoid为<span class="math inline">\(x\)</span>为负例的概率： <span class="math display">\[p_w(y=0|x) = \frac{1}{1+e^{-(w^\top x+b)}}\]</span> 那么 <span class="math display">\[p_w(y=1|x)=\frac{e^{-(w^\top x + b)}}{1+e^{-(w^\top x+b)}}\]</span> 这样我们实际上是认为<span class="math inline">\(p(y|x)\)</span>服从伯努利分布。我们当然是希望参数<span class="math inline">\(w\)</span>得到的模型与真实数据的拟合程度越高越好，可以使用极大似然估计来解决。</p><p>似然 <span class="math display">\[L(w,b) = \prod_{i=1}^N (p_w(y=1|x_i))^{y_i} (1-p_w(y=1|x_i))^{1-y_i}\]</span> 对数似然为 <span class="math display">\[\begin{align}\log L(w,b) &amp;= \log \prod_{i=1}^N (p_w(y=1|x_i))^{y_i} (1-p_w(y=1|x_i))^{1-y_i}\end{align}\]</span> 为了方便推导，我们将偏置项<span class="math inline">\(b\)</span>与<span class="math inline">\(w\)</span>合并起来： <span class="math display">\[w^\top x+b\Rightarrow \beta x\]</span> 于是 <span class="math display">\[\begin{align}\log L(\beta) &amp;=\sum_{i=1}^N y_i\log p_\beta(y=1|x_i)+(1-y_i)\log(1-p_\beta(y=1|x_i))\\&amp;=\sum_{i=1}^N y_i \log \frac{e^{-\beta x_i}}{1+e^{-\beta x_i}} +(1-y_i)\log \frac{1}{1+e^{-\beta x_i}}\\&amp;=\sum_{i=1}^N y_i\log (e^{-\beta x_i} \cdot \frac{1}{1+e^{-\beta x}})+(1-y_i)\log \frac{1}{1+e^{-\beta x}}\\&amp; = \sum_{i=1}^N -y_i\beta x_i+y_i \log \frac{1}{1+e^{-\beta x_i}}+\log \frac{1}{1+e^{-\beta x_i}}-y_i \log \frac{1}{1+e^{-\beta x_i}}\\&amp;=\sum_{i=1}^N -y_i\beta x_i + \log \frac{1}{1+ e^{-\beta x_i}}\\&amp;=\sum_{i=1}^N -y_i\beta x_i - \log(1+ e^{-\beta x_i})\end{align}\]</span> 损失函数相当于最小化<span class="math inline">\(\log L(\beta)\)</span>的负数： <span class="math display">\[\ell (\beta) = \sum_{i=1}^N y_i\beta x_i + \log(1+ e^{-\beta x_i})\]</span></p><p>损失函数的导数 <span class="math display">\[\frac{\partial \ell(\beta)}{\partial \beta}=\sum_{i=1}^N x_i(y_i-p_\beta(y=1|x_i))\]</span> 二阶导数为 <span class="math display">\[\frac{\partial^2\ell(\beta)}{\partial\beta\partial\beta^\top}=\sum_{i=1}^N x_ix_i^\top p_\beta(y=0|x)p_\beta(y=1|x)\]</span></p><h2 id="optimization">Optimization</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Still working on it...&lt;/p&gt;
&lt;h1 id=&quot;linear-regression&quot;&gt;Linear Regression&lt;/h1&gt;
&lt;h2 id=&quot;the-model</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="Linear Regression" scheme="http://qfxiao.me/tags/Linear-Regression/"/>
    
  </entry>
  
  <entry>
    <title>Boosting and AdaBoost: Machine Learning Ensemble Algorithms 1</title>
    <link href="http://qfxiao.me/2020/08/26/Boosting-and-AdaBoost-Machine-Learning-Ensemble-Algorithms-1/"/>
    <id>http://qfxiao.me/2020/08/26/Boosting-and-AdaBoost-Machine-Learning-Ensemble-Algorithms-1/</id>
    <published>2020-08-25T16:28:44.000Z</published>
    <updated>2020-09-09T03:33:38.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h1 id="boosting">Boosting</h1><h1 id="adaboost-algorithm">AdaBoost Algorithm</h1><p>给定数据集<span class="math inline">\(X=\{(x_1,y_1),\cdots,(x_N,y_N)\}\)</span>，AdaBoost的思想是通过训练一系列弱分类器，并通过线性相加将这些弱分类器组合成强分类器。</p><ol type="1"><li>初始化数据的权重分布<span class="math inline">\(D_1\)</span></li><li>在训练数据上使用权重分布<span class="math inline">\(D_m\)</span>进行训练，得到基分类器<span class="math inline">\(G_m(x)\)</span></li><li>计算基分类器<span class="math inline">\(G(x)\)</span>在训练数据上的误差<span class="math inline">\(e_m\)</span></li><li>计算基分类器<span class="math inline">\(G(x)\)</span>的权重<span class="math inline">\(\alpha_m\)</span>，可以看出这个权重是与误差<span class="math inline">\(e_m\)</span>成反比的，即误差越大，权重越低</li><li>更新训练数据的权重分布<span class="math inline">\(D_{m+1}\)</span>，可以看到这个权重是和误差成正比的，即误差大的样本会受到更高的关注</li><li>回到步骤2，直到得到<span class="math inline">\(M\)</span>个分类器</li><li>将分类器进行线性组合得到最终分类器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;h1 id=&quot;boosting&quot;&gt;Boosting&lt;/h1&gt;
&lt;h1 id=&quot;adaboost-algorithm&quot;&gt;AdaBoost Algorithm&lt;/h1&gt;
&lt;p&gt;给定数据集&lt;span</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="Boosting" scheme="http://qfxiao.me/tags/Boosting/"/>
    
    <category term="Adaboost" scheme="http://qfxiao.me/tags/Adaboost/"/>
    
  </entry>
  
  <entry>
    <title>GBDT and XGBoost: Machine Learning Ensemble Algorithms 2</title>
    <link href="http://qfxiao.me/2020/08/26/GBDT-and-XGBoost-Machine-Learning-Ensemble-Algorithms-2/"/>
    <id>http://qfxiao.me/2020/08/26/GBDT-and-XGBoost-Machine-Learning-Ensemble-Algorithms-2/</id>
    <published>2020-08-25T16:28:26.000Z</published>
    <updated>2020-09-17T13:32:26.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>在学习本文内容之前建议先学习<a href="http://qfxiao.me/2020/09/02/Decision-Tree-Machine-Learning-Classification-Algorithms-3/">决策树相关内容</a>。</p><p>Still working on it😅...</p><p><a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">XGBoost Documentation</a></p><p><a href="https://www.cnblogs.com/pinard/p/6133937.html">AdaBoost blog</a></p><p><a href="https://www.cnblogs.com/pinard/p/6140514.html">GBDT blog</a></p><p><a href="http://wepon.me/files/gbdt.pdf">slide</a></p><p><a href="https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf">陈天奇slide</a></p><p><a href="https://snaildove.github.io/2018/10/01/8.Booting-Methods_LiHang-Statistical-Learning-Methods/">blog</a></p><p><a href="https://snaildove.github.io/2018/10/02/get-started-XGBoost/">blog</a></p><h1 id="preliminaries">Preliminaries</h1><p>实际上，GBDT和梯度下降、XGBoost和牛顿法之间是存在密切关系的，这里我们先回顾一下梯度下降算法和牛顿法的基础知识。</p><h2 id="taylor-formulation">Taylor Formulation</h2><p>函数<span class="math inline">\(f(x)\)</span>在点<span class="math inline">\(x_0\)</span>处的泰勒展开为： <span class="math display">\[f(x)=\sum_{n=0}^\infty\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</span> 特别的，一阶展开为： <span class="math display">\[f(x)\approx f(x_0)+f^\prime(x_0)(x-x_0)\]</span> 二阶展开为： <span class="math display">\[f(x)\approx f(x_0)+f^\prime(x_0)(x-x_0) + f^{\prime\prime}(x_0)\frac{(x-x_0)^2}{2}\]</span> 迭代形式：假设<span class="math inline">\(x^t=x^{t-1}+\Delta x\)</span>，将<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x^{t-1}\)</span>处进行泰勒展开 <span class="math display">\[\begin{align}f(x^t) &amp;= f(x^{t-1}+\Delta x)\\&amp;\approx f(x^{t-1})+f^\prime(x^{t-1})\Delta x + f^{\prime\prime}(x^{t-1})\frac{\Delta x^2}{2}\end{align}\]</span></p><h2 id="gradient-descend-method">Gradient Descend Method</h2><p>设参数<span class="math inline">\(\theta\)</span>，那么参数对应的损失函数为<span class="math inline">\(L(\theta)\)</span>，</p><p>设当前步数为<span class="math inline">\(t\)</span>，那么<span class="math inline">\(t-1\)</span>步时的参数为<span class="math inline">\(\theta^{t-1}\)</span>，将<span class="math inline">\(L(\theta^t)\)</span>在<span class="math inline">\(\theta^{t-1}\)</span>处展开得到：</p><p><span class="math display">\[L(\theta^t) \approx L(\theta^{t-1})+ L^\prime(\theta^{t-1})\Delta\theta\]</span> 我们想求的<span class="math inline">\(\theta^t=\theta^{t-1}+\Delta \theta\)</span></p><h2 id="newtons-method">Newton's Method</h2><p>将<span class="math inline">\(L(\theta^t)\)</span>在<span class="math inline">\(\theta^{t-1}\)</span>处进行二阶泰勒展开 <span class="math display">\[\begin{align}L(\theta^t) &amp;= L(\theta^{t-1}+\Delta \theta)\\&amp;\approx L(\theta^{t-1})+L^\prime(\theta^{t-1})\Delta \theta + L^{\prime\prime}(\theta^{t-1})\frac{\Delta \theta^2}{2}\end{align}\]</span> 记一阶导数和二阶导数分别为<span class="math inline">\(g\)</span>和<span class="math inline">\(H\)</span>，那么 <span class="math display">\[L(\theta^t)=L(\theta^{t-1})+g\Delta \theta + H\frac{\Delta \theta^2}{2}\]</span> 要使得迭代后的结果尽量小，即<span class="math inline">\(g\Delta \theta + H\frac{\Delta \theta^2}{2}\)</span>尽量小，那么有<span class="math inline">\(\frac{\left(g\Delta \theta + H\frac{\Delta \theta^2}{2}\right)}{\partial\Delta\theta}=0\)</span></p><p>求得<span class="math inline">\(\Delta \theta=H^{-1}g\)</span>，故<span class="math inline">\(\theta^{t}=\theta^{t-1}+\Delta \theta=\theta^{t-1}-\frac{g}{h}\)</span>。如果<span class="math inline">\(\theta\)</span>是一个向量，那么<span class="math inline">\(\theta^{t}=\theta^{t-1}-H^{-1}g\)</span>，这里<span class="math inline">\(H\)</span>为海森矩阵。</p><h1 id="gradient-boosting-decision-tree-gbdt">Gradient Boosting Decision Tree (GBDT)</h1><p>我们首先来看基于树的Boosting模型中，非常经典的梯度提升树 (Gradient Boosting Decision Tree)。</p><h2 id="the-additive-model">The Additive Model</h2><p>首先GBDT是一个加法模型，即最终模型由一系列树模型乘以对应权重相加得来： <span class="math display">\[F_T(x;w)=\sum_{t=0}^T\alpha_t h_t(x;w_t)=\sum_{t=0}^T f_t(x;w_t)\]</span> 我们的目标是使得<span class="math inline">\(F\)</span>的损失函数最小化： <span class="math display">\[F_T^*=\mathop{\arg\min}\limits_{F}\sum_{i=1}^N L(y_i, F_T(x_i;w))\]</span></p><p>直接优化这个损失函数复杂度是很高的，GBDT实际上运用了一种类似贪心的策略来优化这个函数，将优化过程分解成了迭代的步骤。</p><p>回想梯度下降算法进行优化的步骤，我们有参数<span class="math inline">\(\theta\)</span>，损失函数<span class="math inline">\(L(\theta)\)</span>是<span class="math inline">\(\theta\)</span>的函数，我们希望找到最优的<span class="math inline">\(\theta^*\)</span>使得<span class="math inline">\(L(\theta^*)\)</span>最小，于是我们使用了迭代优化的步骤。假设迭代执行到第<span class="math inline">\(t\)</span>步，也就是说我们现在的参数<span class="math inline">\(\theta^{t-1}\)</span>为前面<span class="math inline">\(t-1\)</span>步增量之和：<span class="math inline">\(\theta^{t-1}=\sum_{j=1}^{t-1}\Delta \theta_j\)</span>，每一步的增量记为<span class="math inline">\(\Delta \theta_t\)</span>。当前的增量<span class="math inline">\(\Delta \theta_{t}\)</span>是怎么计算得到的呢？大家都知道是采用的损失函数在<span class="math inline">\(\theta^{t-1}\)</span>的负梯度乘以一个步长，即<span class="math inline">\(\Delta \theta_t=-\alpha_t \frac{\partial L(\theta)}{\partial \theta^{t-1}}\)</span>。</p><p>梯度下降相当于是在参数空间<span class="math inline">\(\theta\)</span>找到最合适的参数<span class="math inline">\(\theta^*\)</span>使得损失函数<span class="math inline">\(L(\theta)\)</span>最小化，如果我们把模型<span class="math inline">\(F_T\)</span>看作是函数空间，我们的目的是在函数空间中找到最优的<span class="math inline">\(F_T^*\)</span>使得损失函数最小化，在这一个角度上GBDT和梯度下降就统一起来了。每一步的基模型<span class="math inline">\(f_t\)</span>就相当于梯度下降中的增量<span class="math inline">\(\Delta \theta\)</span>，所以我们就得到了GBDT每一的优化目标，即损失函数<span class="math inline">\(L\)</span>对于<span class="math inline">\(F_{t-1}\)</span>的负梯度。</p><table><thead><tr class="header"><th></th><th>梯度下降</th><th>GBDT</th></tr></thead><tbody><tr class="odd"><td>损失函数</td><td><span class="math inline">\(L(\theta)\)</span></td><td><span class="math inline">\(L(F_t)\)</span></td></tr><tr class="even"><td>参数</td><td><span class="math inline">\(\theta^t\)</span></td><td><span class="math inline">\(F_t\)</span></td></tr><tr class="odd"><td>增量</td><td><span class="math inline">\(\Delta \theta_t=-\alpha_t g_t\)</span></td><td><span class="math inline">\(f_t=-\alpha_t g_t\)</span></td></tr><tr class="even"><td>步长</td><td><span class="math inline">\(\alpha_t\)</span></td><td><span class="math inline">\(\alpha_t\)</span></td></tr><tr class="odd"><td>初始值</td><td><span class="math inline">\(\theta_0\)</span></td><td><span class="math inline">\(f_0\)</span></td></tr></tbody></table><h2 id="gradient-boosting-tree-for-regression">Gradient Boosting Tree for Regression</h2><p>我们先来讨论GBDT解决回归问题的算法。前面我们已经讨论过，在每一步GBDT的优化目标是损失函数的负梯度，那么现在的问题就是如何求得每一步最优的基模型（GBDT的基模型选用的是CART）。GBDT的算法步骤如下：</p><blockquote><p><strong>Gradient Boosting Tree Algorithm</strong></p><p>INPUT: 训练样本<span class="math inline">\(\{(x_1,y_1),\cdots,(x_m,y_m)\}\)</span>，迭代轮数<span class="math inline">\(T\)</span>，损失函数<span class="math inline">\(L\)</span></p><p>OUTPUT: 强模型<span class="math inline">\(F_T\)</span></p><ol type="1"><li>初始化弱学习器<span class="math inline">\(f_0\)</span>，直接使用一个基模型在训练集上进行训练</li><li>在步骤<span class="math inline">\(t=1...T\)</span>，对于每个样本计算负梯度<span class="math inline">\(r_{ti}=\left[\frac{\partial L(y_i,F_{t-1}(x_i))}{\partial F_{t-1}}\right]\)</span></li><li>在<span class="math inline">\((x_i,r_{ti})\)</span>上训练得到一个CART回归树，确定树的结构</li><li>假设一共有<span class="math inline">\(J\)</span>个叶子节点，那么对每个叶子节点计算最佳输出值<span class="math inline">\(c_{tj}=\mathop{\arg\min}\limits_{c_{tj}}\sum_{x_i\in R_{tj}} L(y_i,F_{t-1}(x_i)+c_{tj})\)</span>（其中<span class="math inline">\(c_{tj}\)</span>代表第<span class="math inline">\(j\)</span>个叶子的输出，<span class="math inline">\(R_{tj}\)</span>代表第<span class="math inline">\(j\)</span>个叶子对应的样本集合），确定每个叶子节点的输出</li><li>更新强学习器<span class="math inline">\(F_t=F_{t-1}+f_t\)</span>，回到步骤2直到达到迭代轮数</li><li>最终得到强学习器的表达式：<span class="math inline">\(f(x)=f_0(x)+\sum\limits_{t=1}^T\sum\limits_{j=1}^J c_{tj}\mathrm I(x\in R_{tj})\)</span></li></ol></blockquote><p>于是我们就得到了最终模型<span class="math inline">\(F_T\)</span>。</p><h2 id="gradient-boosting-tree-for-classification">Gradient Boosting Tree for Classification</h2><p>在处理分类任务时，由于输出是离散的值</p><p>一种方法是使用指数损失函数，此时GBDT退化为AdaBoost；另一种方法是借鉴逻辑回归的方法，去建模真实值的概率</p><h3 id="binary-classification">Binary Classification</h3><h3 id="multi-class-classfication">Multi-class Classfication</h3><h2 id="gbdt-sumarry">GBDT Sumarry</h2><p>优点：</p><ol type="1"><li>可以灵活处理</li><li>相对SVM，调参较少</li><li>使用某些损失函数对异常值的鲁棒性高</li></ol><p>缺点：</p><ol type="1"><li>难以并行训练</li></ol><h1 id="xgboost">XGBoost</h1><p>前面我们讲了梯度下降和牛顿法，刚才又讨论了GBDT和梯度下降的关系，那么XGBoost是否和牛顿法有什么关系呢？答案是肯定的。GBDT利用了损失函数在<span class="math inline">\(F_{t-1}\)</span>的一阶展开（即一阶导数信息），而XGBoost则利用了损失函数在<span class="math inline">\(F_{t-1}\)</span>的二阶展开，这也是XGBoost和GBDT最根本的区别。下面我们将详细讲解XGBoost算法。</p><table><thead><tr class="header"><th></th><th>牛顿法</th><th>XGBoost</th></tr></thead><tbody><tr class="odd"><td>损失函数</td><td><span class="math inline">\(L(\theta)\)</span></td><td><span class="math inline">\(L(F_t)\)</span></td></tr><tr class="even"><td>参数</td><td><span class="math inline">\(\theta^t\)</span></td><td><span class="math inline">\(F_t\)</span></td></tr><tr class="odd"><td>增量</td><td><span class="math inline">\(\Delta \theta_t=-\alpha_t H^{-1}_tg_t\)</span></td><td><span class="math inline">\(f_t=-\alpha_t H^{-1}_tg_t\)</span></td></tr><tr class="even"><td>步长</td><td><span class="math inline">\(\alpha_t\)</span></td><td><span class="math inline">\(\alpha_t\)</span></td></tr><tr class="odd"><td>初始值</td><td><span class="math inline">\(\theta_0\)</span></td><td><span class="math inline">\(f_0\)</span></td></tr></tbody></table><h2 id="regularization">Regularization</h2><p>XGBoost相比GBDT的另一大改进是加入了正则化项，即控制每个树的复杂度。衡量树的复杂度的度量有很多，XGBoost采用的是每棵树叶子节点的个数<span class="math inline">\(T\)</span>和每个叶子节点输出<span class="math inline">\(w\)</span>的平方和： <span class="math display">\[\Omega(f)=\gamma T+\frac{1}{2}\lambda\parallel w\parallel^2\]</span></p><p>这一步主要是为了进一步降低每个弱学习器的方差。</p><h2 id="objective-function">Objective Function</h2><p>加上正则项之后总的损失函数变为： <span class="math display">\[L=\sum_{i=1}^N \ell(y_i, F_T(x_i))+\Omega(F_T)\]</span> 和GBDT类似，我们来推导第<span class="math inline">\(t\)</span>步的优化公式，对于第<span class="math inline">\(t\)</span>步，我们的损失函数为： <span class="math display">\[\begin{align}L_t&amp;=\sum_{i=1}^N \ell(y_i,F_t(x_i))+\Omega(F_t)\\&amp;=\sum_{i=1}^N \ell(y_i, F_{t-1}(x_i) + f_t(x_i))+\Omega(F_t)\end{align}\]</span> 将损失函数在<span class="math inline">\(F_{t-1}\)</span>处进行二阶泰勒展开，得到 <span class="math display">\[L_t \approx \left[\sum_{i=1}^N \ell(y_i, F_{t-1}) + g_i f_t(x_i) + \frac{1}{2}h_i f_t^2(x_i) \right] + \Omega(F_t)\]</span> 其中<span class="math inline">\(g_i=\frac{\partial \ell(y_i, F_{t-1})}{\partial F_{t-1}}\)</span>，<span class="math inline">\(h_i=\frac{\partial \ell(y_i, F_{t-1}) ^2}{\partial^2 F_{t-1}}\)</span>，分别代表损失函数对<span class="math inline">\(F_{t-1}\)</span>的一阶导和二阶导。</p><p>由于我们要优化的是本轮的基模型<span class="math inline">\(f_t\)</span>，<span class="math inline">\(\ell(y_i, F_{t-1})\)</span>已经是固定的了，相当于常数，把常数项去掉，得到： <span class="math display">\[\begin{align}\tilde L_t &amp;= \left[\sum_{i=1}^N  g_i f_t(x_i) + \frac{1}{2}h_i f_t^2(x_i) \right] + \Omega(f_t)\\&amp;=\left[\sum_{i=1}^N  g_i f_t(x_i) + \frac{1}{2}h_i f_t^2(x_i) \right] + \gamma T + \frac{1}{2}\lambda \parallel w \parallel^2\end{align}\]</span> 我们都知道样本<span class="math inline">\(x_i\)</span>在树<span class="math inline">\(f_t\)</span>上的输出取决于<span class="math inline">\(x_i\)</span>在哪个叶子节点。假设树<span class="math inline">\(f_t\)</span>一共有<span class="math inline">\(J\)</span>个叶节点，记<span class="math inline">\(q(x_i)=j\)</span>代表样本<span class="math inline">\(x_i\)</span>经过决策树对应的叶节点是<span class="math inline">\(j\)</span>，<span class="math inline">\(I_j\)</span>代表叶子节点<span class="math inline">\(j\)</span>的所有样本下标集合，<span class="math inline">\(w_j\)</span>代表叶子节点<span class="math inline">\(j\)</span>的输出，我们可以将损失函数改写为： <span class="math display">\[\begin{align}\tilde L_t &amp;= \sum_{j=1}^J\left[\sum_{i\in I_j}g_i w_j+\frac{1}{2}(\sum_{i\in I_j}h_i +\lambda)w_j^2\right]+\gamma T\\&amp;= \sum_{j=1}^J\left[G_j w_j + \frac{1}{2}(H_j+\lambda)w_j^2 \right] + \gamma T\end{align}\]</span> 其中<span class="math inline">\(G_j=\sum_{i\in I_j}g_i\)</span>和<span class="math inline">\(H_j=\sum_{i\in I_j}h_i\)</span>为简记，分别代表损失函数在叶子节点<span class="math inline">\(j\)</span>对应的所有样本上的一阶导之和与二阶导之和。</p><p>到现在，我们还剩两个问题需要解决，一个是确定树<span class="math inline">\(f_t\)</span>的最优结构，也就是怎么去分裂节点，另一个是确定每个叶子节点的最优输出。我们可以先确定下一个问题，找到另一个问题的最优答案，再来确定剩下的问题。</p><p>这里先去寻找树<span class="math inline">\(f_t\)</span>每一个叶子节点对应的最优输出。和牛顿法的推导类似，为了使损失函数下降的最快，我们令<span class="math inline">\(G_j w_j + \frac{1}{2}(H_j+\lambda)w_j^2\)</span>的导数为<span class="math inline">\(0\)</span>，得到： <span class="math display">\[w_j^*=-\frac{G_j}{H_j + \lambda}\]</span> 加上正则项有： <span class="math display">\[\tilde L_t^*=-\frac{1}{2}\sum_{j=1}^J\frac{G_j^2}{H_j+\lambda}+\gamma T\]</span></p><h2 id="splitting-strategy">Splitting Strategy</h2><p>现在来确定树<span class="math inline">\(f_t\)</span>的最优结构。最优结构的确定实际上使用了一种类似贪心的策略，和决策树类似，我们从一个只有根节点的树出发（所有样本都在根节点这一叶子节点上），不断分裂节点来降低<span class="math inline">\(\tilde L_t^*\)</span>。在每一步的分裂中，我们会希望<span class="math inline">\(\frac{G_j^2}{H_j+\lambda}\)</span>越大越好，于是： <span class="math display">\[Gain = \frac{G_L^2}{H_L+\lambda} + \frac{G_R^2}{H_R+\lambda} - \frac{(G_L+G_R)^2}{H_L+H_R+\lambda} - \gamma\]</span></p><p>我们希望挑选能使得<span class="math inline">\(Gain\)</span>最大的特征和特征分裂点，而选择的策略又有很多种，下面介绍三种。</p><h3 id="exact-greedy-algorithm-for-split-finding">Exact Greedy Algorithm for Split Finding</h3><p>最简单的方法是枚举所有特征，然后对于这个特征下的所有可能取值进行排序，然后遍历分裂点，找到使得<span class="math inline">\(gain\)</span>最高的那个。这样做的好处是找到的分裂点确定是最好的，不过坏处是时间复杂度过高。</p><h3 id="approximate-algorithm-for-split-finding">Approximate Algorithm for Split Finding</h3><p>一个比较容易想到的优化方案是不去遍历所有可能的分裂点，而是只考察其中的分位数，如下图展示了三分位数方法：</p><p><img src="https://i.loli.net/2020/09/10/HoPR9XlpZSm1Gju.png" srcset="/img/loading.gif" /></p><p>这样需要考察的点就大大减少。</p><p>同时分位数的选择由有global和local之分，global是指在训练之前我们就可以提前对每个特征的分位数进行预处理，local是指每次分裂前计算分位数点。直观上来说global需要更多的分位点数，而local则需要更多的计算量。</p><p>实际上，XGBoost还会使用二阶导信息<span class="math inline">\(h_i\)</span>对样本进行夹权，如下图所示：</p><p><img src="https://i.loli.net/2020/09/15/nxloKNmTHwJRqI9.png" srcset="/img/loading.gif" /></p><h3 id="sparsity-aware-split-finding">Sparsity-aware Split Finding</h3><p>稀疏感知分裂算法 (Sparsity-aware Split Finding)</p><h2 id="other-features">Other Features</h2><p>除了上面提到的之外，XGBoost还有很多工程优化。</p><h3 id="block-structure-and-parallelism">Block Structure and Parallelism</h3><p>XGBoost预先对特征进行了排序，</p><p>每个特征的增益的计算可以并行进行</p><h3 id="column-sample">Column Sample</h3><p>借鉴随机森林，即每次只用一部分特征进行特征选择，进一步降低过拟合</p><h3 id="shrinkage">Shrinkage</h3><p>在每次迭代会对叶子节点的权总乘以一个系数，让后面的树有更大的学习空间。</p><h3 id="custom-loss-function">Custom Loss Function</h3><h3 id="missing-values">Missing Values</h3><h1 id="lightgbm">LightGBM</h1><p><a href="https://zhuanlan.zhihu.com/p/227782064">parameter tuning</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;在学习本文内容之前建议先学习&lt;a href=&quot;http://qfxiao.me/2020/09/02/Decision-Tree-Machine-Learning-Classification</summary>
      
    
    
    
    <category term="Technical Notes" scheme="http://qfxiao.me/categories/Technical-Notes/"/>
    
    <category term="Machine Learning" scheme="http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"/>
    
    
    <category term="GBDT" scheme="http://qfxiao.me/tags/GBDT/"/>
    
    <category term="XGBoost" scheme="http://qfxiao.me/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Representation Learning by Predicting Random Distances</title>
    <link href="http://qfxiao.me/2020/08/24/Unsupervised-Representation-Learning-by-Predicting-Random-Distances/"/>
    <id>http://qfxiao.me/2020/08/24/Unsupervised-Representation-Learning-by-Predicting-Random-Distances/</id>
    <published>2020-08-24T08:17:36.000Z</published>
    <updated>2020-08-24T10:25:42.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>针对高维表格数据的表示学习，作者提出了基于预测预计变换后的距离的无监督表示学习框架RDP，并进行了理论上的讨论。To be finished...</p><p><a href="https://arxiv.org/abs/1912.12186">论文地址</a> <a href="https://github.com/billhhh/RDP">代码地址</a></p><h1 id="proposed-method">Proposed Method</h1><h2 id="random-distance-prediction-model">Random Distance Prediction Model</h2><p>对于很多下游任务来说，高维数据对模型效率和性能都很大，所以学习低维的有意义（能够最大限度保存原始空间的信息）的表示十分重要。本文的大致思想是给定一个确定的随机映射将样本映射到一个新的空间，然后构造数据集，输入时任意一对样本，标签是两个样本在新的空间的距离，之后训练一个模型来学习这个距离。作者认为通过该任务的训练，模型能够学到有意义的低维表示。模型的框架如下图：</p><p><img src="https://i.loli.net/2020/07/19/vRV32EgLiYkWaQN.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p><p>其中<span class="math inline">\(\phi(\mathbf x;\Theta):\mathbb R^D\mapsto\mathbb R^M\)</span>为孪生神经网络（Siamese Neural Network），将数据映射到<span class="math inline">\(M\)</span>的新空间。损失函数为：</p><p><span class="math display">\[\mathcal L_{rdp}(\mathbf x_i,\mathbf x_j)=l(\langle \phi(\mathbf x_i;\Theta),\phi(\mathbf x_j;\Theta)\rangle,\langle\eta(\mathbf x_i),\eta(\mathbf x_j)\rangle)\]</span></p><p>其中<span class="math inline">\(\eta(\cdot)\)</span>为已知的映射，<span class="math inline">\(l(\cdot)\)</span>为衡量两个输入相似程度的度量。具体的来说，文中选取了简单的实现方案，即采用内积作为映射后的样本的距离度量：</p><p><span class="math display">\[\mathcal L_{rdp}(\mathbf x_i,\mathbf x_j)=\left(\phi(\mathbf x_i;\Theta)\cdot\phi(\mathbf x_j;\Theta)-\eta(\mathbf x_i)\cdot\eta(\mathbf x_j)\right)^2\]</span></p><p><span class="math inline">\(\eta(\cdot)\)</span>为现成的映射。至于为什么要这么做，可以先接着看下面原文给出的理论分析，然后我再说说我自己的理解。</p><h2 id="incorporating-task-dependent-complementary-auxiliary-loss">Incorporating Task-Dependent Complementary Auxiliary Loss</h2><p>对于特定的下游任务，作者提出可以整合额外的误差函数来提高模型行性能。比如说针对聚类任务可以使用重构误差：</p><p><span class="math display">\[\mathcal L_{aux}^{clu}(\mathbf x)=(\mathbf x-\phi^\prime(\phi(\mathbf x;\Theta); \Theta^\prime))^2\]</span></p><p>其中<span class="math inline">\(\phi(\cdot)\)</span>和<span class="math inline">\(\phi^\prime(\cdot):\mathbb R^M\mapsto\mathbb R^D\)</span>分别为编码器和解码器。</p><p>对于异常检测任务，可以使用下式： <span class="math display">\[\mathcal L_{aux}^{ad}(\mathbf x)=(\phi(\mathbf x;\Theta)-\eta(\mathbf x))^2\]</span></p><p>这一个Loss本来是出现在强化学习的论文中，用来检测一个状态<span class="math inline">\(\mathbf x\)</span>出现的频率，如果预测误差较小，说明这个样本之前见过或见过类似的，否则没怎么见过，可以认为是异常。由于本文的目的主要是降维加保留原始空间信息，可以认为使用线性变换的话此目的已经达到了。</p><h2 id="theoretical-analysis">Theoretical Analysis</h2><h3 id="using-linear-projection">Using Linear Projection</h3><p>这里讨论使用线性映射的情况，设数据集<span class="math inline">\(\mathcal X\subset\mathbb R^{N\times D}\)</span>，映射矩阵<span class="math inline">\(\mathbf A\subset\mathbb R^{K\times D}\)</span>为一随机矩阵，映射之后的数据为<span class="math inline">\(\mathbf A\mathcal X^\top\)</span>。对于<span class="math inline">\(\epsilon\in(0,\frac{1}{2})\)</span>和<span class="math inline">\(K=\frac{20\log n}{\epsilon^2}\)</span>，存在<span class="math inline">\(f:\mathbb R^D\mapsto\mathbb R^K\)</span>使得对于所有的<span class="math inline">\(\mathbf x_i,\mathbf x_j\in\mathcal X\)</span>有：</p><p><span class="math display">\[(1-\epsilon)\parallel\mathbf x_i-\mathbf x_j \parallel^2\leq \parallel f(\mathbf x_i)-f(\mathbf x_j)\parallel^2\leq (1+\epsilon)\parallel\mathbf x_i-\mathbf x_j\parallel^2\]</span></p><p>如果<span class="math inline">\(\mathbf A\)</span>的每个元素独立采样自标准正态分布那么有：</p><p><span class="math display">\[\text{Pr}\left((1-\epsilon)\parallel\mathbf x\parallel^2\leq\parallel\frac{1}{\sqrt{K}}\mathbf A\mathbf x\parallel^2\leq(1+\epsilon)\parallel\mathbf x\parallel^2\right)\geq 1-2e^{\frac{-(\epsilon^2-\epsilon^3)K}{4}}\]</span></p><p>在该随机映射下有：</p><p><span class="math display">\[\text{Pr}(|\hat{\mathbf x}_i\cdot\hat{\mathbf x}_j-f(\hat{\mathbf x}_i)\cdot f(\hat{\mathbf x}_j)|\geq\epsilon)\leq 4e^{\frac{-(\epsilon^2-\epsilon^3)\cdot K}{4}}\]</span></p><p>直观的解释就是说使用线性映射的情况下，只要使用的变换矩阵采样自标准正态分布，那么变换之后样本对之间的距离信息能够以一定的概率保留。</p><h3 id="using-non-linear-projection">Using Non-Linear Projection</h3><p>这里作者试图说明，在某些条件下，非线性随机映射的作用和核函数接近。对于一个确定的随机映射函数<span class="math inline">\(g:\mathbb R^D\mapsto\mathbb R^K\)</span>，在某些特定的条件下，函数<span class="math inline">\(g\)</span>和核函数存在下列关系：</p><p><span class="math display">\[k(\mathbf x_i,\mathbf x_j)=\langle\psi(\mathbf x_i),\psi(\mathbf x_j)\rangle\approx g(\mathbf x_i)\cdot g(\mathbf x_j)\]</span></p><p>这个条件是函数<span class="math inline">\(g\)</span>为一个乘以一个线性矩阵<span class="math inline">\(\mathbf A\)</span>然后在经过一个具备平移不变性的傅里叶基函数（如cosine）。由于核函数能够保留原始空间的信息，所以作者认为使用非线性函数也能保留原始空间的信息。</p><blockquote><p>PS: 感觉作者在理论部分的讨论还是有点模糊，因为把一个随机的映射作为（伪）监督信息来进行学习，神经网络学到的不也就是随机噪声信息吗？对于这个方法work的原因，我在这里不负责任的分析一下。</p></blockquote><h3 id="learning-class-structure-by-random-distance-prediction">Learning Class Structure by Random Distance Prediction</h3><p>这一节主要解释为什么神经网络<span class="math inline">\(\phi(\cdot)\)</span>学到的要比随机映射<span class="math inline">\(\eta(\cdot)\)</span>要好。模型的优化目标可以写成如下的形式：</p><p><span class="math display">\[\mathop{\arg\min}_{\Theta}\sum_{\mathbf x_i,\mathbf x_j\in\mathcal X}(\phi(\mathbf x_i;\Theta)\cdot\phi(\mathbf x_j;\Theta)-y_{ij})^2\]</span></p><p>其中<span class="math inline">\(y_{ij}=\eta(\mathbf x_i)\cdot\eta(\mathbf x_j)\)</span>。设<span class="math inline">\(\mathbf Y_\eta\in\mathbb R^{N\times N}\)</span>为距离矩阵。这个目标函数是在最小化每一对样本在经过<span class="math inline">\(\phi(\cdot)\)</span>和<span class="math inline">\(\eta(\cdot)\)</span>映射后之间的距离的差距。通过公式(7)和公式(8)我们知道，在合适的条件下，随机映射<span class="math inline">\(\eta(\cdot)\)</span>能够保留原始空间的距离信息（即原始空间相近的样本在映射后也相近）。不过，上述公式的成立都依赖于对数据分布的一定假设，当真实的数据不满足条件时，结论就会有所偏差。</p><h1 id="experiments">Experiments</h1><h2 id="performance-evaluation-in-anomaly-detection">Performance Evaluation in Anomaly Detection</h2><h3 id="experimental-settings">Experimental Settings</h3><p><img src="https://i.loli.net/2020/07/20/3G7DNKjwfQkiIz4.png" srcset="/img/loading.gif" /></p><p>异常分数定义为<span class="math inline">\(\mathcal S(\mathbf x)=(\phi(\mathbf x;\Theta)-\eta(\mathbf x))^2\)</span>。</p><h3 id="comparison-to-the-state-of-the-art-competing-methods">Comparison to the State-of-the-art Competing Methods</h3><p><img src="https://i.loli.net/2020/07/20/8Ie2Q3mpdPHtrYF.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/07/20/OEcQSvZmfBz1ACt.png" srcset="/img/loading.gif" /></p><h3 id="ablation-study">Ablation Study</h3><p><img src="https://i.loli.net/2020/07/20/7GtKlN8q5Mvygre.png" srcset="/img/loading.gif" /></p><h2 id="performance-evaluation-in-clustering">Performance Evaluation in Clustering</h2><h3 id="experimental-settings-1">Experimental Settings</h3><p><img src="https://i.loli.net/2020/07/20/9xW12MVkoXgFZ6J.png" srcset="/img/loading.gif" /></p><h3 id="comparison-to-the-state-of-the-art-competing-methods-1">Comparison to the State-of-the-art Competing Methods</h3><p><img src="https://i.loli.net/2020/07/20/pUZ64aX1xWiLf2q.png" srcset="/img/loading.gif" /></p><figure><img src="https://i.loli.net/2020/07/20/VrnXuJsymiMItUf.png" srcset="/img/loading.gif" alt="" /><figcaption>image-20200720014002063</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;针对高维表格数据的表示学习，作者提出了基于预测预计变换后的距离的无监督表示学习框架RDP，并进行了理论上的讨论。To be finished...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Representation Learning" scheme="http://qfxiao.me/categories/Research/Representation-Learning/"/>
    
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/tags/Anomaly-Detection/"/>
    
    <category term="Representation Learning" scheme="http://qfxiao.me/tags/Representation-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Effective End-to-end Unsupervised Outlier Detection via Linear Priority of Discriminative Network</title>
    <link href="http://qfxiao.me/2020/07/14/Effective-End-to-end-Unsupervised-Outlier-Detection-via-Linear-Priority-of-Discriminative-Network/"/>
    <id>http://qfxiao.me/2020/07/14/Effective-End-to-end-Unsupervised-Outlier-Detection-via-Linear-Priority-of-Discriminative-Network/</id>
    <published>2020-07-14T10:46:13.000Z</published>
    <updated>2020-07-21T12:35:42.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>本文针对无监督异常检测提出了<span class="math inline">\(E^3\space{Outlier}\)</span>。作者使用自监督学习的方法，通过构建有监督任务在没有标签的情况下学习高层语义特征。PS：这篇文章的方法和NIPS18上的<em>Deep Anomaly Detection Using Geometric Transformations</em>（后面简称GEOM）颇为相似，但是不知为啥没有在实验中进行比较。后面我会分析一些两篇文章方法上的异同。</p><h1 id="proposed-method">Proposed Method</h1><h2 id="surrogate-supervision-based-effective-representation-learning-for-uod">Surrogate Supervision Based Effective Representation Learning for UOD</h2><p>这里作者提到了使用重构的模型来进行异常检测的不足：重构模型采用像素级别的损失函数（如mean square error），而这太过于严格和细节，并不能学到高层语义特征。</p><p>为此，作者提出了<em>surrogate supervision based discriminative network</em> (SSD)。具体操作和GEOM类似，首先预定义大小为<span class="math inline">\(K\)</span>的几何变换集合<span class="math inline">\(\mathcal O=\{O(\cdot|y)\}_{y=1}^K\)</span>。对每一个样本<span class="math inline">\(\mathbf x\)</span>，在经过<span class="math inline">\(K\)</span>个集合变换之后会得到<span class="math inline">\(K\)</span>个变换后的样本（第<span class="math inline">\(y\)</span>个变换产生的样本即记为<span class="math inline">\(\mathbf x^{(y)}=O(\mathbf x|y)\)</span>），每个样本对应的pseudo label即为变换的序号或者说种类。之后在新的数据集上（大小为原来的<span class="math inline">\(K\)</span>倍）训练<span class="math inline">\(K\)</span>分类网络。网络的输出为<span class="math inline">\(P(\mathbf x^{(y^\prime)}|\boldsymbol\theta)=[P^{(y)}(\mathbf x^{(y^\prime)}|\boldsymbol\theta)]_{y=1}^K\)</span>，每个维度代表输入样本对应的变换的概率。总的损失函数为： <span class="math display">\[\min_\theta\frac{1}{N}\sum_{i=1}^{N}\mathcal L_{SS}(\mathbf x_i|\theta)\]</span></p><p>其中<span class="math inline">\(\mathcal L_{SS}(\mathbf x_i|\theta)\)</span>代表每个样本对应的Loss，这个Loss可以由分类器在<span class="math inline">\(K\)</span>个变换上的交叉熵损失来确定：</p><p><span class="math display">\[\mathcal L_{SS}(\mathbf x_i|\boldsymbol\theta)=-\frac{1}{K}\sum_{y=1}^K\log(P^{(y)}(\mathbf x_i^{(y)}|\boldsymbol\theta))=-\frac{1}{K}\sum_{y=1}^K\log(P^{(y)}(O(\mathbf x_i|y)|\boldsymbol\theta))\]</span> <img src="https://i.loli.net/2020/07/14/ULAdYpzsoGfFwtD.png" srcset="/img/loading.gif" /></p><p>变换集合<span class="math inline">\(\mathcal O\)</span>由一系列基本变换的组合确定。作者将这些基本变换分为了：1) 旋转 2) 翻转 3) 平移，包括横向和纵向 4) Patch置换（参考图1(a)中的Patch Re-arranging）。最终的变换集合<span class="math inline">\(\mathcal O\)</span>由三个子集组成，分别是<span class="math inline">\(\mathcal O_{RA}\)</span>（代表Regular Affine，其中每个变换为旋转<span class="math inline">\(90°\)</span>的倍数、翻转、横向平移和纵向平移这四个基本变换的叠加），<span class="math inline">\(\mathcal O_{IA}\)</span>（代表Irregular Affine，其中每个变换为进行<span class="math inline">\(30°\)</span>的倍数且不为<span class="math inline">\(90°\)</span>的倍数角度的旋转、翻转这两个基本变换的叠加）和<span class="math inline">\(\mathcal O_{PR}\)</span>（只包含Patch Re-arranging）。</p><p>为了验证SSD学到的特征的有效性，作者将CAE提取的特征和SSD提取的特征分别用孤立森林进行异常检测，发现SSD效果更好（见图1(b)）。</p><p>到这里为止本文和GEOM基本没有大的区别。值得注意的是在所采用的几何变换中，采用了非线性变换（进行<span class="math inline">\(30°\)</span>的倍数且不为<span class="math inline">\(90°\)</span>的倍数角度的旋转）。而在GEOM中，提到过使用非线性变换的话效果会比较差，至于具体的影响如何，可能需要实验来确定。</p><h2 id="inlier-priority-the-foundation-of-end-to-end-uod">Inlier Priority: The Foundation of End-to-end UOD</h2><p>在这里作者主要对在训练集包含少量异常的情况下做出的理论分析，作者将其称为<em>Inlier Priority</em>，原句如下：</p><blockquote><p><em>Inlier Priority</em>: Despite that inliers/outliersare indiscriminately fed into SSD for training, SSD will prioritize the minimization of inliers’ loss.</p></blockquote><h3 id="priority-by-gradient-magnitude">Priority by Gradient Magnitude</h3><p>对于第<span class="math inline">\(c\)</span>个类来说，设<code>softmax</code>层和倒数第二层之间的权重矩阵为<span class="math inline">\(\mathbf w_c=[w_{s,c}]^{(L+1)}_{s=1}\)</span>，损失函数记为<span class="math inline">\(\mathcal L\)</span>，梯度记为<span class="math inline">\(\nabla_{\mathbf w_c}\mathcal L=[\nabla_{w_{s,c}}\mathcal L]^{(L+1)}_{s=1}\)</span>。设训练集<span class="math inline">\(X^{(c)}\)</span>包含<span class="math inline">\(N_{in}\)</span>个正常样本，<span class="math inline">\(N_{out}\)</span>个异常样本。记正常样本和异常样本对应的梯度分别为<span class="math inline">\(\parallel\nabla^{(in)}_{\mathbf w_c}\mathcal L\parallel\)</span>和<span class="math inline">\(\parallel\nabla^{(out)}_{\mathbf w_c}\mathcal L\parallel\)</span>，在网络只有一个隐层且采用<code>Sigmoid</code>作为激活函数时，两者梯度的期望之比有如下关系：</p><p><span class="math display">\[\frac{E(\parallel\nabla^{(in)}_{\mathbf w_c}\mathcal L\parallel^2)}{E(\parallel\nabla^{(out)}_{\mathbf w_c}\mathcal L\parallel^2)}\approx\frac{N^2_{in}}{N^2_{out}}\]</span></p><p>在训练集中，正常样本和异常样本的数量是极不均衡的，<span class="math inline">\(N_{in}\gg N_{out}\)</span>，所以有<span class="math inline">\(E(\parallel\nabla^{(in)}_{\mathbf w_c}\mathcal L\parallel^2)\gg E(\parallel\nabla^{(out)}_{\mathbf w_c}\mathcal L\parallel^2)\)</span>。</p><p>在使用更复杂的网络时，作者通过实验展示了正常样本和异常样本对应的梯度大小的比较：</p><p><img src="https://i.loli.net/2020/07/16/iPa7h9HWqrnZvgx.png" srcset="/img/loading.gif" /></p><h3 id="priority-by-network-updating-direction">Priority by Network Updating Direction</h3><p>这里作者通过梯度更新的方向来进行了理论上的解释。对于一个Batch的数据<span class="math inline">\(X\)</span>，梯度为<span class="math inline">\(-\nabla_\theta\mathcal L(X)=-\frac{1}{N}\sum_i\nabla_\theta\mathcal L(\mathbf x_i)\)</span>，如果将该梯度在Batch中某一样本<span class="math inline">\(\mathbf x_i\)</span>对应的梯度的方向上进行分解<span class="math inline">\(-\nabla_\theta\mathcal L(\mathbf x_i):d_i=-\nabla_\theta\mathcal L(X)\cdot\frac{-\nabla_\theta\mathcal L(\mathbf x_i)}{\parallel -\nabla_\theta\mathcal L(\mathbf x_i)\parallel}\)</span>，这代表了总的Loss在多大程度上减小样本<span class="math inline">\(\mathbf x_i\)</span>对应的Loss，由于一个Batch即包含正常样本，也可能包含异常样本，所以作者将两者对应的梯度方向贡献进行了可视化：</p><p><img src="https://i.loli.net/2020/07/16/U5fVk8YOEGPx3Q7.png" srcset="/img/loading.gif" /></p><p>可以看到随着训练的进行，正常样本对应的贡献更高。</p><p>PS: 我以为作者会对基于几何变换的异常检测为什么有效做一些理论上的解释，不过却没有。这里只是对在训练集包含少量异常的情况下做出的理论分析，而这个实际上直觉上就很显然了。</p><h2 id="scoring-strategies-for-uod">Scoring Strategies for UOD</h2><p>作者采用了三种方法来计算异常分数：</p><h3 id="pseudo-label-based-score-pl">Pseudo Label based Score (PL)</h3><p>对于一个测试样本<span class="math inline">\(\mathbf x\)</span>，对其进行<span class="math inline">\(K\)</span>个几何变换，通过分类器会得到<span class="math inline">\(K\)</span>个输出，对于第<span class="math inline">\(k\)</span>个输出，我们只取其第<span class="math inline">\(k\)</span>个分量，最后把他们加起来除以<span class="math inline">\(K\)</span>：</p><p><span class="math display">\[S_{pl}(\mathbf x)=\frac{1}{K}\sum_{y=1}^K P^{(y)}(\mathbf x^{(y)}|\boldsymbol\theta)\]</span></p><h3 id="maximum-probability-based-score-mp">Maximum Probability based Score (MP)</h3><p>这里稍有不同，对于第<span class="math inline">\(k\)</span>个输出，我们取其值最大的分量，而不是第<span class="math inline">\(k\)</span>个分量：</p><p><span class="math display">\[S_{mp}(\mathbf x)=\frac{1}{K}\sum_{y=1}^K\max_t P^{(t)}(\mathbf x^{(y)}|\boldsymbol\theta)\]</span></p><h3 id="negative-entropy-based-score-ne">Negative Entropy based Score (NE)</h3><p>作者认为，标签为One-Hot向量，分类器的输出分布越“尖峰”就越接近于正常样本，而越“平均”就越接近于异常样本，所以作者提出使用熵来描述分类器输出的“尖锐度”： <span class="math display">\[S_{ne}(\mathbf x)=-\frac{1}{K}\sum_{y=1}^K H(P(\mathbf x^{(y)}|\boldsymbol\theta))=\frac{1}{K}\sum_{y=1}^K\sum_{t=1}^K P^{(t)}(\mathbf x^{(y)}|\boldsymbol\theta)\log(P^{(t)}(\mathbf x^{(y)}|\boldsymbol\theta))\]</span> 这里作者对第一种方法得到的结果进行了可视化：</p><p><img src="https://i.loli.net/2020/07/16/PgzqXIdJ67s3BtG.png" srcset="/img/loading.gif" /></p><p>PS：对比NIPS18 的Dirichlet Normality Score</p><ol type="1"><li>也用到了全部<span class="math inline">\(K\)</span>个维度的信息</li><li>相当于对分类器的输出做了迪利克雷分布的先验假设，然后通过训练集的输出估计分布参数。因为直觉上对于正常分布来说，分类器的输出分布形状上都类似一个尖峰，但对于不同的数据集来说具体形状还是会有所差异</li></ol><h1 id="experiments">Experiments</h1><h2 id="experiment-setup">Experiment Setup</h2><p>数据集用到了MNIST, Fashion-MNIST (F-MNIST) , CIFAR10, SVHN和CIFAR100。为了模拟无监督异常检测的环境，人为在训练集中加入异常样本，异常的比例<span class="math inline">\(\rho\)</span>从<span class="math inline">\(5\%\)</span>到<span class="math inline">\(25\%\)</span>以<span class="math inline">\(5\%\)</span>的步长递增。评测标准采用AUPR和AUROC。</p><h2 id="uod-performance-comparison-and-discussion">UOD Performance Comparison and Discussion</h2><p>下表展示了模型性能对比结果：</p><p><img src="https://i.loli.net/2020/07/16/G3agKPuJBowFmIW.png" srcset="/img/loading.gif" /></p><p>下图展示了在不同的Outlier Ratio下的性能对比：</p><p><img src="https://i.loli.net/2020/07/16/h6iYjBkrwQdFvMJ.png" srcset="/img/loading.gif" /></p><p>下图展示了在不同的变换集合，网络结构，异常分数的条件下的性能：</p><p><img src="https://i.loli.net/2020/07/16/waWAi7zI3QpOcf6.png" srcset="/img/loading.gif" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;本文针对无监督异常检测提出了&lt;span class=&quot;math inline&quot;&gt;\(E^3\space{Outlier}\)&lt;/span&gt;。作者使用自监督学习的方法，通过构建有监督任务在没有标</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/categories/Research/Anomaly-Detection/"/>
    
    
    <category term="Self-Supervised Learning" scheme="http://qfxiao.me/tags/Self-Supervised-Learning/"/>
    
  </entry>
  
  <entry>
    <title>PRML Notes 1.1: Probability Distributions - Binary and Multinomial Variables</title>
    <link href="http://qfxiao.me/2020/06/22/PRML-Notes-1-1-Probability-Distributions-Binary-and-Multinomial-Variables/"/>
    <id>http://qfxiao.me/2020/06/22/PRML-Notes-1-1-Probability-Distributions-Binary-and-Multinomial-Variables/</id>
    <published>2020-06-22T05:43:58.000Z</published>
    <updated>2020-06-27T10:19:50.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1><p>这是PRML (Pattern Recognition and Machine Learning) 第二章<code>Probability Distributions</code>笔记的第一部分，主要包括<code>2.1. Binary Variables</code>和<code>2.2. Multinomial Variables</code>这两节。</p><h1 id="probability-distributions-for-binary-variables">Probability Distributions for Binary Variables</h1><h2 id="intro">Intro</h2><p>这一节主要针对二值随机变量的建模，即<span class="math inline">\(x\in\{0,1\}\)</span>。这里可以想象为我们有一个硬币，<span class="math inline">\(x=1\)</span>代表正面朝上，而<span class="math inline">\(x=0\)</span>代表反面朝上，并且正面朝上的概率为<span class="math inline">\(\mu\)</span>，即： <span class="math display">\[p(x=1|\mu)=\mu\]</span> 其中<span class="math inline">\(0\leqslant \mu \leqslant 1\)</span>。<span class="math inline">\(x\)</span>的概率分布可以写为： <span class="math display">\[\text{Bern}(x|\mu)=\mu^x(1-\mu)^{1-x}\]</span> 也就是我们熟知的<strong>伯努利分布 (Bernoulli Distribution)</strong>。其均值和方差分别为： <span class="math display">\[\begin{align}\mathbb E[x]&amp;=\mu\\\text{var}[x] &amp;= \mu(1-\mu)\end{align}\]</span> 现在来考虑参数估计任务。假设我们正在进行一个投硬币的实验，每一次投币都服从伯努利分布且相互独立，我们将每次采集到的观测值组成数据集<span class="math inline">\(\mathcal D=\{x_1,\cdots,x_N\}\)</span>，则似然函数为： <span class="math display">\[p(\mathcal D|\mu)=\prod_{n=1}^N p(x_n|\mu)=\prod_{n=1}^N \mu^{x_n}(1-\mu)^{1-x_n}\]</span> 如果采用极大似然估计的话，我们可以最大化似然函数，这等价于最大化对数似然： <span class="math display">\[\ln p(\mathcal D|\mu)=\sum_{n=1}^{N}\ln p(x_n|\mu)=\sum_{n=1}^N\{x_n\ln\mu+(1-x_n)\ln(1-\mu)\}\]</span> 令其导数为0得到极值点： <span class="math display">\[\mu_{ML}=\frac{1}{N}\sum_{n=1}^N x_n\]</span> 这相当于样本均值，不过这样做会有严重的问题。假设我们的数据集为<span class="math inline">\(\mathcal D=\{1,1,1\}\)</span>，也就是说我们只收集到了三个样本，并且都是正例，我们会得到<span class="math inline">\(\mu_{ML}=1\)</span>，而这显然是严重过拟合的。稍后我们会说说如何应对这种情况（加入先验）。</p><h2 id="binomial-distribution">Binomial Distribution</h2><p>我们同样可以对多次伯努利实验进行概率建模。记<span class="math inline">\(m\)</span>为成功的次数，<span class="math inline">\(N\)</span>为数据集大小，可知这个概率应该与<span class="math inline">\(\mu^m(1-\mu)^{N-m}\)</span>成正比。乘以标准化系数后即我们熟知的<strong>二项分布 (Binomial Distribution)</strong>： <span class="math display">\[\text{Bin}(m|N,\mu)=\binom{N}{m}\mu^m(1-\mu)^{N-m}\]</span></p><p>其中： <span class="math display">\[\binom{N}{m}=\frac{N!}{(N-m)!m!}\]</span> 其均值和方差分别为： <span class="math display">\[\begin{align}\mathbb E[m]&amp;=N\mu\\\text{var}[m]&amp;=N\mu(1-\mu)\end{align}\]</span></p><h2 id="beta-distribution">Beta Distribution</h2><p>现在我们来讨论如何解决刚才提到的最大似然估计过拟合问题。为了解决这个问题，我们使用贝叶斯的思路，对<span class="math inline">\(\mu\)</span>引入了先验分布<span class="math inline">\(p(\mu)\)</span>。而这个分布需要具有良好的解释性和数学性质。</p><p>根据贝叶斯定理： <span class="math display">\[p(\mu|\mathcal D)=\frac{p(\mathcal D|\mu)p(\mu)}{p(\mathcal D)}\]</span> 而<span class="math inline">\(p(\mathcal D)=\int_0^1 p(\mathcal D|\mu)p(\mu)\mathrm d\mu\)</span>只受数据集影响，而数据集是固定的，所以为常数，因此<span class="math inline">\(p(\mu|\mathcal D)\propto p(\mathcal D|\mu)p(\mu)\)</span>。而似然函数为<span class="math inline">\(\mu^x(1-\mu)^{1-x}\)</span>的乘积，如果先验也采用<span class="math inline">\(\mu\)</span>和<span class="math inline">\(1-\mu\)</span>的幂的乘积的形式，那么后验分布也将和先验形式相同，这种性质在统计学中被称为<strong>先验共轭 (conjugacy)</strong>。</p><p>这里我们直接给出这个先验分布，再来分析它的性质。这个分布叫做<strong>Beta分布 (Beta Distribution)</strong><span class="math inline">\(P(\mu|a,b)\sim \text{Beta}(a,b)\)</span>： <span class="math display">\[\begin{align}\text{Beta}(\mu|a,b) &amp;= \frac{\Gamma(a+b)}{\Gamma(a\Gamma(b)}\mu^{a-1}(1-\mu)^{b-1}\\ &amp;= \frac{1}{B(a,b)}\mu^{a-1}(1-\mu)^{b-1}\end{align}\]</span> <span class="math inline">\(B(\boldsymbol \alpha,\beta)\)</span>称为B函数，为一个标准化函数： <span class="math display">\[\begin{align}B(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}\end{align}\]</span> 其目的是为了使整个概率分布积分等于1而存在的。Gamma函数的定义为： <span class="math display">\[\Gamma(x)=\int_0^{\infty}s^{x-1}e^{-s}\mathrm d s\]</span> Gamma函数有一个性质：</p><p><span class="math display">\[\Gamma(x+1)=x\Gamma(x)\]</span> 证明为： <span class="math display">\[\begin{align*}\Gamma(x+1) &amp;= \int_{0}^{\infty} {s^{x} e^{-s} ds} \\&amp;= \big[s^{x} (-e^{-s})\big] \big|_{0}^{\infty} - \int_{0}^{\infty} {(x s^{x-1}) (-e^{-s}) ds} \\&amp;= (0 - 0) + x \int_{0}^{\infty} {s^{x-1} e^{-s} ds} \\&amp;= x \Gamma(x)\end{align*}\]</span></p><p>除此之外：</p><p><span class="math display">\[\Gamma(1)=1\\\Gamma(\frac{1}{2})=\sqrt{\pi}\]</span></p><p>可以验证： <span class="math display">\[\int_0^1\text{Beta}(\mu|a,b)\mathrm d\mu=1\]</span></p><p>Beta分布的均值和方差为：</p><p><span class="math display">\[\mathbb E[\mu]=\frac{a}{a+b}\\\text{var}[\mu]=\frac{ab}{(a+b)^2(a+b+1)}\]</span></p><p>因为后验分布与先验和似然函数的乘积成比例，那么： <span class="math display">\[p(\mu|m,l,a,b)\propto\mu^{m+a-1}(1-\mu)^{l+b-1}\]</span></p><p>其中<span class="math inline">\(l=N-m\)</span>。乘上标准化因子，就得到： <span class="math display">\[p(\mu|m,l,a,b)=\frac{\Gamma(m+a+l+b)}{\Gamma(m+a)\Gamma(l+b)}\mu^{m+a-1}(1-\mu)^{l+b-1}\]</span> 得到的仍然是Beta分布，相当于把<span class="math inline">\(a\rightarrow{m+a}\)</span>，<span class="math inline">\(b\rightarrow{l+b}\)</span>。同时不难发现，参数<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>都有比较直观的意义。<span class="math inline">\(a\)</span>可以看作是历史记录中，成功的次数，<span class="math inline">\(b\)</span>可以看作是历史记录中失败的次数，比如<span class="math inline">\(a=2\)</span>，<span class="math inline">\(b=3\)</span>，根据经验成功的概率应该在<span class="math inline">\(\frac{2}{2+3}=0.4\)</span>左右，即我们的先验为成功的概率为<span class="math inline">\(0.4\)</span>（见下图左下角的子图）。如果在实验中，又进行了<span class="math inline">\(7\)</span>次实验，其中<span class="math inline">\(m=6\)</span>，<span class="math inline">\(l=1\)</span>，由于成功的次数变多了，<span class="math inline">\(a=2+6=8\)</span>，<span class="math inline">\(b=3+1=4\)</span>，直觉上来说我们对成功概率的估计应当相应提高，大概为<span class="math inline">\(\frac{8}{8+4}\approx 0.67\)</span>左右。这时的Beta分布如右下角的图的样子，也印证了我们的直觉。</p><p><img src="https://i.loli.net/2020/06/25/3hcj18ELXl4iWy6.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>以下为不同参数对应的Beta分布的互动演示：</p><div><iframe width="650px" height="450px" frameborder="0" style="dispaly:block；" src="http://qfxiao.me/html/beta_distribution_vis.html"></iframe></div><p>最后，Beta还有一个有趣的应用就是，如果我们不断接收到新的观测数据，那么旧的后验分布则可以作为新的先验分布将参数更新下去 。这相当于说，基于已有的观测数据，我们提出一个先验Beta分布，然后根据新得到的一批观测数据，用先验Beta分布计算一个似然函数，将似然函数和先验Beta分布乘起来，归一化后得到了新的后验分布，只要不断有新的观测数据接收到，就可以把后验分布作为新的先验，不断更新下去。这样做的优势是对于大数据集，我们不需要整个数据集，而是只需要一批一批的更新即可。</p><h1 id="probability-distributions-for-multinomial-variables">Probability Distributions for Multinomial Variables</h1><h2 id="intro-1">Intro</h2><p>前面我们讨论了二值随机变量，现在我们将其扩展到多值变量。设一个<span class="math inline">\(K\)</span>维向量<span class="math inline">\(\mathbf x\)</span>，当<span class="math inline">\(x_k\)</span>为<span class="math inline">\(1\)</span>的时候其他元素都为<span class="math inline">\(0\)</span>，如<span class="math inline">\(K=6,x_3=1\)</span>时<span class="math inline">\(\mathbf x\)</span>表示为<span class="math inline">\(\mathbf x=(0,0,1,0,0,0)^\top\)</span>。如果<span class="math inline">\(p(x_k=1)=\mu_k\)</span>，那么<span class="math inline">\(\mathbf x\)</span>的概率分布为： <span class="math display">\[p(\mathbf x|\boldsymbol \mu)=\prod_{k=1}^{K}\mu_k^{x_k}\]</span> <span class="math inline">\(\mu_k\)</span>满足<span class="math inline">\(\sum_k \mu_k=1\)</span>和<span class="math inline">\(\mu_k\geqslant 0\)</span>，该分布被称作是<strong>Categorical Distribution</strong>。易知其均值为： <span class="math display">\[\begin{align}\mathbb E[\mathbf x|\boldsymbol \mu]=\sum_{\mathbf x}p(\mathbf x|\boldsymbol \mu)\mathbf x=\boldsymbol \mu\end{align}\]</span> 假设我们有大小为<span class="math inline">\(N\)</span>的数据集<span class="math inline">\(\mathcal D\)</span>，每个样本服从该分布且相互独立，那么似然函数： <span class="math display">\[p(\mathcal D|\boldsymbol \mu)=\prod_{n=1}^N\prod_{k=1}^K \mu_k^{x_{nk}}=\prod_{k=1}^K \mu_k^{\sum_n x_{nk}}=\prod_{k=1}^K\mu_k^{m_k}\]</span> 其中<span class="math inline">\(m_k=\sum_n x_{nk}\)</span>，即<span class="math inline">\(x_k=1\)</span>的数量。为了最大化对数似然同时保证<span class="math inline">\(\sum_k \mu_k=1\)</span>，我们可以用拉格朗日乘子法： <span class="math display">\[\sum_{k=1}^K m_k\ln \mu_k+\lambda\left(\sum_{k=1}^K\mu_k-1\right)\]</span> 我们得到<span class="math inline">\(\mu_k=-m_k/\lambda\)</span>。通过<span class="math inline">\(\sum_k \mu_k=1\)</span>得出<span class="math inline">\(\lambda=-N\)</span>，故最后我们有： <span class="math display">\[\mu_k^{ML}=\frac{m_k}{N}\]</span></p><p>这相当于是<span class="math inline">\(x_k=1\)</span>的数量除以总数。</p><h2 id="multinomial-distribution">Multinomial Distribution</h2><p>类似的，我们可以对多次实验进行建模，假设进行<span class="math inline">\(N\)</span>次独立实验，概率分布可以写为：</p><p><span class="math display">\[\text{Mult}(m_1,m_2,\cdots,m_K|\boldsymbol\mu,N)=\binom{N}{m_1m_2\cdots m_K}\prod_{k=1}^K\mu_k^{m_k}\]</span></p><p>这也是我们熟知的<strong>多项分布 (Multinomial Distribution)</strong>，其中<span class="math inline">\(\binom{N}{m_1m_2\cdots m_K}\)</span>为正则化因子： <span class="math display">\[\binom{N}{m_1m_2\cdots m_K}=\frac{N!}{m_1!m_2!\cdots m_K!}\]</span> 注意<span class="math inline">\(\sum\limits_{k=1}^K m_k=N\)</span>。</p><h2 id="dirichlet-distribution">Dirichlet Distribution</h2><p>有了前面Beta的启发，我们同样可以对多项分布的参数<span class="math inline">\(\mu_k\)</span>建立共轭先验。首先根据似然函数，我们知道先验应当与<span class="math inline">\(\mu_k\)</span>的幂的乘积成比例：</p><p><span class="math display">\[p(\boldsymbol \mu|\boldsymbol \alpha) \propto \prod_{k=1}^{K}\mu_k^{a_{k-1}}\]</span></p><p>其中<span class="math inline">\(0\leqslant \mu_k\leqslant 1\)</span>且<span class="math inline">\(\sum_k\mu_k=1\)</span>。和Beta分布不同，由于要满足<span class="math inline">\(\sum\mu_k=1\)</span>，所以<span class="math inline">\(\{\mu_k\}\)</span>的取值会位于<span class="math inline">\(K-1\)</span>的单纯型上，如下图所示：</p><p><img src="https://i.loli.net/2020/06/25/N8CSMvmlRz91Gqy.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>加上标准化因子，我们就得到了所谓的先验分布，称之为<strong>迪利克雷分布 (Dirichlet Distribution)</strong>： <span class="math display">\[\text{Dir}(\boldsymbol \mu|\boldsymbol\alpha)=\frac{\Gamma(\alpha_0)}{\Gamma(\alpha_1)\cdots\Gamma(\alpha_K)}\prod_{k=1}^K\mu_k^{a_{k-1}}\]</span></p><p>其中<span class="math inline">\(\Gamma(\cdot)\)</span>为Gamma函数，<span class="math inline">\(\alpha_0=\sum\limits_{k=1}^K\alpha_k\)</span>。下图为不同条件下的迪利克雷分布的可视化：</p><p><img src="https://i.loli.net/2020/06/25/amGtuvPNoOM7kWZ.png" srcset="/img/loading.gif" /></p><p><span class="math inline">\(\boldsymbol \mu\)</span>的后验与先验和似然函数的乘积成正比：</p><p><span class="math display">\[p(\boldsymbol\mu|\mathcal D,\boldsymbol\alpha)\propto p(\mathcal D|\boldsymbol\mu)p(\boldsymbol\mu|\boldsymbol\alpha)\propto\prod_{k=1}^K \mu_k^{\alpha_k+m_k-1}\]</span></p><p>不难验证：</p><p><span class="math display">\[\begin{align}p(\boldsymbol\mu|\mathcal D,\boldsymbol\alpha) &amp;= \text{Dir}(\boldsymbol\mu|\boldsymbol\alpha+\mathbf m)\\&amp;=\frac{\Gamma(\alpha_0+N)}{\Gamma(\alpha_1+m_1)\cdots\Gamma(\alpha_K+m_K)}\prod_{k=1}^K\mu_k^{\alpha_k+m_k-1}\end{align}\]</span></p><p>即后验同样为迪利克雷分布。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;
&lt;p&gt;这是PRML (Pattern Recognition and Machine Learning) 第二章&lt;code&gt;Probability Distributions&lt;/code&gt;笔记的第一部分，主要包括&lt;</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Notes" scheme="http://qfxiao.me/categories/Research/Notes/"/>
    
    
    <category term="Statistics" scheme="http://qfxiao.me/tags/Statistics/"/>
    
    <category term="Probability" scheme="http://qfxiao.me/tags/Probability/"/>
    
  </entry>
  
  <entry>
    <title>Time2Graph: Revisiting Time Series Modeling with Dynamic Shapelets</title>
    <link href="http://qfxiao.me/2020/06/13/Time2Graph-Revisiting-Time-Series-Modeling-with-Dynamic-Shapelets/"/>
    <id>http://qfxiao.me/2020/06/13/Time2Graph-Revisiting-Time-Series-Modeling-with-Dynamic-Shapelets/</id>
    <published>2020-06-13T08:42:04.000Z</published>
    <updated>2020-07-07T03:15:36.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>本文旨在提供一种可解释的高效的时间序列建模（表示学习）方法来更好地服务分类任务。Shapelet在时间序列分类任务上体现了良好的可解释性。不过传统的基于Shapelet的方法忽略了Shapelet在不同时间片段上的动态性，即整个时间维度上不同的时间片段可能适合用不同的Shapelet。作者基于此设计了动态的<em>time-aware shapelet</em>，并且定义了<em>shapelet evolution graph</em>来捕获Shapelet在时间维度上的动态变化。</p><p><a href="https://arxiv.org/abs/1911.04143">📰Get Paper</a></p><h1 id="preliminaries">Preliminaries</h1><p>时间序列集合<span class="math inline">\(T=\{t_1,\cdots,t_{|T|}\}\)</span>包含若干条时序数据<span class="math inline">\(t=\{x_1,\cdots,x_n\}\)</span>。一个<span class="math inline">\(t\)</span>的片段<span class="math inline">\(s\)</span>是<span class="math inline">\(t\)</span>的一个连续子序列。如果<span class="math inline">\(t\)</span>能被切分成<span class="math inline">\(m\)</span>个长度都为<span class="math inline">\(l\)</span>的片段，那么我们就有<span class="math inline">\(t=\{\{x_{l*k+1},\cdots,x_{l*k+l}\},0\leq k\leq m-1\}\)</span>。两个长度相等的片段之间距离很好度量，直接计算欧式距离即可，那么两个片段长度不相等的情况呢？这就需要对其（Alignment）的概念。</p><blockquote><p><strong>Definition 1 </strong> <strong><em>Alignment</em></strong>. 给定两个长度分别为<span class="math inline">\(l_i\)</span>和<span class="math inline">\(l_j\)</span>的序列<span class="math inline">\(s_i\)</span>和<span class="math inline">\(s_j\)</span>，一个<em>alignment</em> <span class="math inline">\(a=(a_1,a_2)\)</span>是一个满足以下条件的长度为<span class="math inline">\(p\)</span>的下标序列： <span class="math display">\[1\leq a_k(1)\leq\cdots\leq a_k(p)=l_k,\\a_k(n+1)-a_k(n)\leq 1,\\\text{for }k=i,j,\text{ and }1\leq n\leq p-1\]</span></p></blockquote><p>上述公式可能比较抽象，其实看了下图就不难理解：</p><p><img src="https://i.loli.net/2020/07/07/UE2GtoYK1vhDpLi.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>片段<span class="math inline">\(s_i\)</span>中的某个点<span class="math inline">\(a\)</span>，与片段<span class="math inline">\(s_j\)</span>中的某个点<span class="math inline">\(b\)</span>形成对应，然后在<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>之间连一条虚拟的线（不能与已有的线交叉），一直这么做直到短的那个片段中的每个点都找到对应，就是一个合理的<em>alignment</em>。对于两个长度不一样的片段<span class="math inline">\(s_i\)</span>和<span class="math inline">\(s_j\)</span>，会有很多种<em>alignment</em>。我们把<span class="math inline">\(s_i\)</span>和<span class="math inline">\(s_j\)</span>所有可能的<em>alignment</em>记为<span class="math inline">\(\mathcal{A}(s_i,s_j)\)</span>。在定义了<em>alignment</em>之后就可以定义DTW了。DTW (<em>Dynamic Time Warping</em>) 定义为在给定一个预定义的距离度量<span class="math inline">\(\tau\)</span>和所有可能的<em>alignment</em> <span class="math inline">\(\mathcal{A}(s_i,s_j)\)</span>的情况下，最小的距离<span class="math inline">\(\tau\)</span>： <span class="math display">\[d_\text{DTW}(s_i,s_j)=\min_{a\in\mathcal{A}(s_i,s_j)}\tau(s_i,s_j|a)\]</span></p><p>进一步的，因为时间序列<span class="math inline">\(t\)</span>也可以看作是一个片段，我们可以定义一个子序列<span class="math inline">\(s\)</span>和时间序列<span class="math inline">\(t\)</span>之间的距离度量： <span class="math display">\[D(s,t)=\min_{1\leq k\leq m} d(s,s_k)\]</span></p><p>这里<span class="math inline">\(\boldsymbol s_k\)</span>为时序<span class="math inline">\(\boldsymbol t\)</span>分解成的片段。之后Shapelet可以通过片段与时序的距离定义为最具有辨识度的有代表性的片段：</p><blockquote><p><strong>Definition 2 </strong> <strong>Shapelet. </strong>一个Shapelet <span class="math inline">\(\boldsymbol v\)</span>是对于特定类别时序的最具有代表性的片段。考虑时序分类任务，给定时序集合<span class="math inline">\(T\)</span>，可以通过与<span class="math inline">\(\boldsymbol v\)</span>相似或不相似而分成两个子集合，与<span class="math inline">\(\boldsymbol v\)</span>相似的集合与<span class="math inline">\(\boldsymbol v\)</span>的距离应当尽量小，与<span class="math inline">\(\boldsymbol v\)</span>不相似的集合与<span class="math inline">\(\boldsymbol v\)</span>的距离应当尽量大，此时损失函数可以形式化为： <span class="math display">\[\mathcal L=-g(S_{pos}(\boldsymbol v,T),S_{neg}(\boldsymbol v,T))\]</span></p></blockquote><p><span class="math inline">\(\mathcal L\)</span>描述了在shapelet <span class="math inline">\(\boldsymbol v\)</span>下正负样本集的相异性。<span class="math inline">\(S_{*}(\boldsymbol v,T)\)</span>表示特定时序集合与<span class="math inline">\(\boldsymbol v\)</span>的距离集合，<span class="math inline">\(g(\cdot,\cdot)\)</span>为接受两个有限集合为输入的可微函数，并且能够度量两个集合的距离。</p><h1 id="framework">Framework</h1><p>本文主要是提出了一种时间序列表示学习方法。基于Shapelet在不同的时间片段上的作用是不同的观察，作者为不同的时间片段赋予了不同的Shapelet，而不是像传统方法一样整个时序对应一个Shapelet。接着基于这些Shapelet作者构造了图，并通过图嵌入得到了嵌入向量，作为时序的表示。</p><p><img src="https://i.loli.net/2020/06/25/mKJH4c2EMAljavG.png" srcset="/img/loading.gif" style="zoom:80%;" /></p><h2 id="time-aware-shapelet-extraction">Time-Aware Shapelet Extraction</h2><p>第一步是捕获Shapelet在时间维度上的动态影响。我们定义了两个参数来定量的测量shapelet在不同时间上的动态性。第一个是局部因子<span class="math inline">\(\boldsymbol w_n\)</span>，用来控制shapelet内部<span class="math inline">\(n\)</span>个元素的权重，那么shapelet <span class="math inline">\(\boldsymbol v\)</span>和片段<span class="math inline">\(\boldsymbol s\)</span>的距离为： <span class="math display">\[\begin{align}\hat{d}(\boldsymbol v,\boldsymbol s|\boldsymbol w) &amp;= \tau(\boldsymbol v,\boldsymbol s|\boldsymbol a^*,\boldsymbol w)\\&amp; = \left(\sum_{k=1}^{p}\boldsymbol w_{\boldsymbol a^*_1(k)}\cdot(\boldsymbol v_{\boldsymbol a^*_1(k)}-\boldsymbol s_{\boldsymbol a^*_2(k)})^2\right)^{\frac{1}{2}}\end{align}\]</span> 其中<span class="math inline">\(\boldsymbol a^*\)</span>为DTW距离下的最佳对齐。</p><p>第二个是全局因素<span class="math inline">\(\boldsymbol u_m\)</span>，这主要是通过对不同片段<span class="math inline">\(\boldsymbol s\)</span>施加不同的权重实现的，于是shapelet <span class="math inline">\(\boldsymbol v\)</span>和时间序列<span class="math inline">\(\boldsymbol t\)</span>的距离可以重写为： <span class="math display">\[\hat{D}(\boldsymbol v,\boldsymbol t|\boldsymbol w,\boldsymbol u)=\min_{1\leq k\leq m}\boldsymbol u_k\cdot\hat{d}(\boldsymbol v,\boldsymbol s_k|\boldsymbol w)\]</span> 其中<span class="math inline">\(\boldsymbol t\)</span>被分割为<span class="math inline">\(m\)</span>个片段：<span class="math inline">\(\boldsymbol t=\{\boldsymbol s_1,\cdots,\boldsymbol s_m\}\)</span>。对于分类任务，具体的来说，我们先生成一堆Shapelet候选集，然后通过有监督的方法来挑选最佳的Shapelet和对应的参数<span class="math inline">\(\boldsymbol w\)</span>和<span class="math inline">\(\boldsymbol u\)</span>。</p><p>计算shapelet候选集的算法如下：</p><p><img src="https://i.loli.net/2020/06/25/srW4Shk79XBFL3U.png" srcset="/img/loading.gif" /></p><p>在获取了Shapelet候选集合之后，我们有带有标签的时序集合<span class="math inline">\(T\)</span>，对于每一个Shapelet我们可以优化：</p><p><span class="math display">\[\hat{\mathcal L}=-g(S_{pos}(\boldsymbol v,T),S_{neg}(\boldsymbol v,T))+\lambda\parallel \boldsymbol w\parallel+\epsilon\parallel \boldsymbol u\parallel\]</span></p><p>来获取最优的<span class="math inline">\(\hat{\boldsymbol w}\)</span>和<span class="math inline">\(\hat{\boldsymbol u}\)</span>。然后，我们可以挑选出使得<span class="math inline">\(\hat{\mathcal L}\)</span>最小的前<span class="math inline">\(K\)</span>个Shapelet。整个过程的算法流程如下：</p><p><img src="https://i.loli.net/2020/06/25/5b2TcjuBzlIFrPm.png" srcset="/img/loading.gif" /></p><h2 id="shapelet-evolution-graph">Shapelet Evolution Graph</h2><p>在获取了Shapelet之后，为了捕获Shapelet之间的相关性，我们定义了<em>Shapelet Evolution Graph</em>。</p><blockquote><p><strong>Definition 3 Shapelet Evolution Graph. </strong> <em>Shapelet Evolution Graph</em>为一个有向带权图<span class="math inline">\(G=(V,E)\)</span>，<span class="math inline">\(V\)</span>为<span class="math inline">\(K\)</span>个Shapelet，每条带有权重<span class="math inline">\(w_{ij}\)</span>的边<span class="math inline">\(e_{ij}\in E\)</span>代表两个Shapelet <span class="math inline">\(\boldsymbol v_i \in V\)</span>和<span class="math inline">\(\boldsymbol v_j \in V\)</span>被分配给相邻片段的概率。</p></blockquote><h3 id="graph-construction">Graph Construction</h3><p>这里来说一下，建图的具体过程。首先顶点为Shapelet，之后来进行边的构造。对于每一个片段<span class="math inline">\(\boldsymbol s_i\)</span>，我们会计算Shapelet到该片段的距离，距离越近代表这个Shapelet与片段越匹配。之后会设定一个阈值<span class="math inline">\(\delta\)</span>，然后将与片段的距离低于这个阈值的Shapelet分配给这个片段（一个Shapelet可能会分配给多个不同片段）。对于<span class="math inline">\(\boldsymbol s_i\)</span>的所有shapetlet我们记为<span class="math inline">\(\boldsymbol v_{i,*}\)</span>，我们会按照Shape到片段的距离进行归一化：</p><p><span class="math display">\[\boldsymbol p_{i,j}=\frac{\max(\hat{d}_{i,*}(\boldsymbol v_{i,*},\boldsymbol s_i))-\hat{d}_{i,j}(\boldsymbol v_{i,j},\boldsymbol s_i)}{\max(\hat{d}_{i,*}(\boldsymbol v_{i,*},\boldsymbol s_i))-\min(\hat{d}_{i,*}(\boldsymbol v_{i,*},\boldsymbol s_i))}\]</span></p><p>其中<span class="math inline">\(\hat{d}_{i,*}(\boldsymbol v_{i,*},\boldsymbol s_i)=\boldsymbol u_*[i]*\hat{d}(\boldsymbol v_{i,*},\boldsymbol s_i|\boldsymbol w_*)&lt;\delta\)</span>。这样对于每个片段<span class="math inline">\(\boldsymbol s_i\)</span>所分配的Shapelet对应的<span class="math inline">\(\boldsymbol p\)</span>之和会等于<span class="math inline">\(1\)</span>。对每一对相邻的片段<span class="math inline">\((\boldsymbol s_i,\boldsymbol s_{i+1})\)</span>的Shapelet <span class="math inline">\(\boldsymbol v_{i,j}\)</span>和<span class="math inline">\(\boldsymbol v_{i+1,k}\)</span>，我们创建一条连接<span class="math inline">\(\boldsymbol v_{*,j}\)</span>和<span class="math inline">\(\boldsymbol v_{*,k}\)</span>的边<span class="math inline">\(e_{j,k}\)</span>，权重为<span class="math inline">\(\boldsymbol p_{i,j}\cdot\boldsymbol p_{i+1,k}\)</span>。最后，所有重复的边会被合并。</p><p><img src="https://i.loli.net/2020/07/07/FzGEbWJflHmQa9R.png" srcset="/img/loading.gif" style="zoom: 33%;" /></p><p>如上图所示，假设有两个片段，每个片段分配了<span class="math inline">\(3\)</span>个Shapelet，Shapelet <span class="math inline">\(B\)</span>在片段<span class="math inline">\(1\)</span>对应的概率是<span class="math inline">\(p_{12}\)</span>，Shapelet <span class="math inline">\(C\)</span>在片段<span class="math inline">\(2\)</span>对应的概率是<span class="math inline">\(p_{23}\)</span>，那么由于片段<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>是相邻片段，会在<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>之间连一条边，边的权重为<span class="math inline">\(p_{12}*p_{23}\)</span>。</p><p>建图的算法流程图如下：</p><p><img src="https://i.loli.net/2020/06/25/aq9tGuApSbiC67c.png" srcset="/img/loading.gif" /></p><h2 id="representation-learning">Representation Learning</h2><p>之后，我们使用DeepWalk算法来获取获取每个结点（Shapelet）的嵌入表示。对于时序<span class="math inline">\(\boldsymbol t=\{\boldsymbol s_1,\cdots,\boldsymbol s_m\}\)</span>即对应的Shapelet <span class="math inline">\(\{\boldsymbol v_{1,*},\cdots, v_{m,*}\}\)</span>和对应的概率<span class="math inline">\(\{\boldsymbol p_{1,*},\cdots,\boldsymbol p_{m,*}\}\)</span>，每个Shaplet <span class="math inline">\(\boldsymbol v_{i,j}\)</span>的表示记为<span class="math inline">\(\boldsymbol \mu(\boldsymbol v_{i,j})\)</span>。片段<span class="math inline">\(\boldsymbol s_i\)</span>对应的嵌入向量为对应的Shapelet嵌入向量与对应的概率值加权求和：</p><p><span class="math display">\[\boldsymbol\Phi_i=\left(\sum_j p_{i,j}\cdot\boldsymbol \mu(\boldsymbol v_{i,j})\right),\space 1\leq i \leq m\]</span></p><p>算法流程如下：</p><p><img src="https://i.loli.net/2020/06/25/O5exTgsVLuRWQ42.png" srcset="/img/loading.gif" /></p><h1 id="experiments">Experiments</h1><h2 id="experimental-setup">Experimental Setup</h2><p>文中用了<em>Earthquakes</em> (EQS)、<em>WormsTwoClass</em> (WTC)、<em>Strawberry</em> (STB)、<em>Electricity Consumption Records</em> (ECR)和<em>Network Traffic Flow</em> (NTF) 这五个数据集，其中后两个为作者自己收集的数据集。五个数据集对应的统计信息如下：</p><p><img src="https://i.loli.net/2020/06/25/zHjTKkUJB8fGwdi.png" srcset="/img/loading.gif" /></p><p>文中与多个Baseline进行了比较，包括:</p><ul><li><strong>Distance-based Models: </strong>文中使用了不同的距离度量与基于1-NN的模型进行组合，包括Euclidean Distance (ED)、Dynamic Time Warping (DTW)、Weighted DTW (WDTW)、Complexity-Invariant Distance (CID) 和 Derivative DTW (DDTW)；</li><li><strong>Feature-based Models: </strong>文中分别使用了提取特征（均值、标准差等）和原始序列来训练XGBoost。除此之外，还使用了 Bag-of-Patterns (BoP)、Time Series Forest (TSF)、Elastic Ensembles (EE) 和 基于SAX的 Vector Space Model (SAXVSM)；</li><li><strong>Shapelet-based Models: </strong>这部分模型包括 Learn Time Series Shapelets (LS)、Fast Shapelets (FS)、和 Learned Pattern Similarity (LPS)；</li><li><strong>Deep Learning Models: </strong>这部分模型包括MLP、LSTM和VAE。</li></ul><h2 id="comparison-results">Comparison Results</h2><p>对于前三个公共数据集评测标准采用Accuracy，后两个数据集因为样本类比不均衡，所以采用了Precision、Recall和F1作为评测标准。结果如下：</p><p><img src="https://i.loli.net/2020/06/25/jxKFpDVXdmc5tbE.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>在EQS数据集上，Time2Graph打败了所有Baseline，而在WTC和STB这两个数据集上也达到了较好的效果。在ECR和NTF这两个真实数据集上，Time2Graph在F1上打败了所有Baseline。</p><h2 id="parameter-analysis">Parameter Analysis</h2><p>本节对Shapelet的数量<span class="math inline">\(K\)</span>、嵌入维度<span class="math inline">\(B\)</span>和片段长度<span class="math inline">\(l\)</span>进行了参数分析。结果如下：</p><p><img src="https://i.loli.net/2020/06/25/hPfqAvNnOlEBQuw.png" srcset="/img/loading.gif" /></p><h2 id="case-study-of-time-aware-shapelets">Case Study of Time-Aware Shapelets</h2><p>本节作者对提出的<em>Time-Aware Shapetlet</em>进行了细致的探究。第一个问题是不同Shapelet的区分能力是否不同？下图(a)里，作者在使用Shapelet进行二分类的任务中，将Shapelet按Loss（图中灰色的线）进行排序，并且绘制了对应的正负样本距离的KL散度（橘红色的点）。可以看到，在Loss曲线和KL散度呈反比关系。KL散度越高，我们可以认为该Shapelet的区分度越高，这说明不同Shapelet的区分度的确不同，并且这会与最终效果直接挂钩。图(b)展示了不同Shapelet的均值和方差（原文没有说清楚是什么的均值和方差）。</p><p>除此之外，作者和流行的Shapelet提取算法<em>LS</em>进行了比较，如图(c)和图(d)。从图中可以看到对于不同时间，本文的算法提取的Shapelet的确是具有时间动态性的。</p><p><img src="https://i.loli.net/2020/06/25/ed5PwksC2l3OWE8.png" srcset="/img/loading.gif" /></p><h2 id="case-study-of-the-shapelet-evolution-graph">Case Study of the Shapelet Evolution Graph</h2><p>本节作者对<em>Shapelet Evolution Graph</em>进行了细致的探究。下图分别为一月份和七月份的<em>Shapelet Evolution Graph</em>。在一月，45号Shapelet的度较大，而且对应的时间因素在一月和二月也较大（图中深色部分）。说明45号Shapelet在一月份具有代表性。而在七月，45号Shapelet的重要性降低，而42号Shapelet在七月的重要性很高。</p><p><img src="https://i.loli.net/2020/06/25/N2Vij8ODQaRuALJ.png" srcset="/img/loading.gif" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;本文旨在提供一种可解释的高效的时间序列建模（表示学习）方法来更好地服务分类任务。Shapelet在时间序列分类任务上体现了良好的可解释性。不过传统的基于Shapelet的方法忽略了Shapel</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Time Series Modeling" scheme="http://qfxiao.me/categories/Research/Time-Series-Modeling/"/>
    
    
    <category term="Time Series" scheme="http://qfxiao.me/tags/Time-Series/"/>
    
    <category term="Shapelet" scheme="http://qfxiao.me/tags/Shapelet/"/>
    
  </entry>
  
  <entry>
    <title>Generative Probabilistic Novelty Detection with Adversarial Autoencoders</title>
    <link href="http://qfxiao.me/2020/06/06/Generative-Probabilistic-Novelty-Detection-with-Adversarial-Autoencoders/"/>
    <id>http://qfxiao.me/2020/06/06/Generative-Probabilistic-Novelty-Detection-with-Adversarial-Autoencoders/</id>
    <published>2020-06-06T04:03:27.000Z</published>
    <updated>2020-06-25T08:14:29.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>这篇文章介绍了一种基于概率分布的异常检测方法。其基本思想是假设正常样本服从定义在流形<span class="math inline">\(M\)</span>上的分布，而对于任意一点<span class="math inline">\(\bar x\)</span>，通过投影到流形<span class="math inline">\(M\)</span>上<span class="math inline">\(x^\parallel\)</span>，可以分解为平行于切空间的部分<span class="math inline">\(x^\parallel\)</span>和正交与切空间的部分<span class="math inline">\(x^\bot\)</span>。原始的坐标<span class="math inline">\(\bar x\)</span>被转换到<span class="math inline">\(x^\parallel\)</span>局部坐标系中，然后似然通过转换后的坐标系进行计算。</p><h1 id="methodology">Methodology</h1><h2 id="generative-probabilistic-novelty-detection">Generative Probabilistic Novelty Detection</h2><p>我们假设训练数据<span class="math inline">\(x_1,\cdots,x_N\)</span>，其中<span class="math inline">\(x_i\in\mathbb{R}^m\)</span>，从一个分布采样的来，并带有随机噪声<span class="math inline">\(\xi\)</span>： <span class="math display">\[x_i=f(z_i)+\xi_i, \space\space\space i=1,\cdots,N\]</span> 其中<span class="math inline">\(z_i\in\mathbb{R}^n\)</span>，<span class="math inline">\(f:\Omega\mapsto\mathbb{R}^m\)</span>定义了一个<span class="math inline">\(n\)</span>维带参流形<span class="math inline">\(\mathcal{M}\equiv f(\Omega)\)</span>。注意这里噪声的加入使得样本的值域扩展到了整个实数空间。同时假设存在<span class="math inline">\(g:\mathbb{R}^m\mapsto\mathbb{R}^n\)</span>，对任意<span class="math inline">\(x\in\mathcal{M}\)</span>都有<span class="math inline">\(f(g(x))=x\)</span>。<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>后面会通过神经网络实现。</p><p>对于一个测试样本<span class="math inline">\(\bar{x}\in\mathbb{R}^m\)</span>，我们可以得到其在<span class="math inline">\(M\)</span>上的投影，这是通过逆变换<span class="math inline">\(\bar z = g(\bar x)\)</span>得到对应<span class="math inline">\(z\)</span>的然后再通过<span class="math inline">\(\bar x^{\parallel}=f(\bar z)\)</span>得到。<span class="math inline">\(f\)</span>在<span class="math inline">\(\bar z\)</span>的一阶泰勒展开为： <span class="math display">\[f(z)=f(\bar z)+J_f(\bar z)(z-\bar z)+O(\parallel z-\bar z\parallel ^2)\]</span> <img src="https://i.loli.net/2020/06/25/oi9xKMO3ID7jANJ.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p>其中<span class="math inline">\(J_f(\bar z)\)</span>为<span class="math inline">\(f\)</span>在点<span class="math inline">\(\bar z\)</span>的雅各比矩阵。<span class="math inline">\(\mathcal T=\text{span}(J_f(\bar z))\)</span>代表点<span class="math inline">\(\bar z\)</span>处由<span class="math inline">\(J_f(\bar z)\)</span>的<span class="math inline">\(n\)</span>个独立向量组成的切空间。通过对<span class="math inline">\(J_f(\bar z)\)</span>进行奇异值分解<span class="math inline">\(J_f(\bar z)=U^\parallel SV^\top\)</span>。 <span class="math display">\[\bar w=U^\top\bar x=\left[\begin{matrix}U^{\parallel^\top}\bar x\\ U^{\bot^\top}\bar x\end{matrix}\right]=\left[\begin{matrix}\bar w^\parallel\\ \bar w^\bot\end{matrix}\right]\]</span> 坐标<span class="math inline">\(\bar w\)</span>可以分解为平行于<span class="math inline">\(\mathcal T\)</span>和正交于<span class="math inline">\(\mathcal T\)</span>两部分。</p><p>定义在施加变换前后的坐标系上的概率分布<span class="math inline">\(p_X(x)\)</span>和<span class="math inline">\(p_W(w)\)</span>是等价的，不过对于<span class="math inline">\(p_W(w)\)</span>，我们假设平行部分和正交部分是独立的，即： <span class="math display">\[p_X(x)=p_W(w)=p_W(w^\parallel,w^\bot)=p_{W^\parallel}(w^\parallel)p_{W^\bot}(w^\bot)\]</span> 这一假设的依据是随机噪声部分假设主要是往流形之外偏离的，即与<span class="math inline">\(\mathcal T\)</span>正交，所以<span class="math inline">\(W^\bot\)</span>主要是反映噪声的部分。而噪声与样本分布相独立的假设是合理的。于是，异常分数可以定义为： <span class="math display">\[p_X(\bar x)=p_{W^\parallel}(\bar w^\parallel)p_{W^\bot}(\bar w^\bot)=\begin{cases}\geq \gamma \Rightarrow \text{Inlier}\\&lt;\gamma\Rightarrow\text{Outlier}\end{cases}\]</span></p><h2 id="computing-the-distribution-of-data-samples">Computing the Distribution of Data Samples</h2><p>上面的异常分数需要计算<span class="math inline">\(p_{W^\parallel}(\bar w^\parallel)\)</span>和<span class="math inline">\(p_{W^\bot}(\bar w^\bot)\)</span>。给定测试样本<span class="math inline">\(\bar x\)</span>，投影到流形<span class="math inline">\(\bar x^\parallel=f(g(\bar x))\)</span>。<span class="math inline">\(\bar w^\parallel\)</span>可以重写为<span class="math inline">\(\bar w^\parallel=U^{\parallel^\top}\bar x=U^{\parallel^\top}(\bar x-\bar x^{\parallel})+U^{\parallel^\top}\bar x^\parallel=U^{\parallel^\top}\bar x^\parallel\)</span>，即我们假设<span class="math inline">\(U^{\parallel^\top}(\bar x-\bar x^\parallel)\approx 0\)</span>。于是有<span class="math inline">\(w^\parallel(z)=U^{\parallel^\top}f(\bar z)+SV^\top(z-\bar z)+O(\parallel z-\bar z\parallel^2)\)</span>。</p><p>如果<span class="math inline">\(Z\)</span>为定义在流形上的概率分布，那么： <span class="math display">\[p_{W^\parallel}(w^\parallel)=|\text{det}S^{-1}|p_Z(z)\]</span> <span class="math inline">\(p_{W^\bot}(w^\bot)\)</span>由半径为<span class="math inline">\(\parallel w^\bot\parallel\)</span>的超球体<span class="math inline">\(\mathcal S^{m-n-1}\)</span>来进行估计： <span class="math display">\[p_{W^\bot}(w^\bot)\approx\frac{\Gamma(\frac{m-n}{2})}{2\pi^{\frac{m-n}{2}}\parallel w^\bot\parallel^{m-n}}p_{\parallel W^\bot\parallel}(\parallel w^\bot\parallel)\]</span></p><p>其中<span class="math inline">\(\Gamma(\cdot)\)</span>代表Gamma函数。</p><h2 id="manifold-learning-with-adversarial-autoencoders">Manifold Learning with Adversarial Autoencoders</h2><p>为了学习映射<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>，我们使用了AAE框架，如下图所示：</p><p><img src="https://i.loli.net/2020/06/25/sQhO3D4gKJqBPXv.png" srcset="/img/loading.gif" style="zoom: 67%;" /></p><p>除了常规的AAE外，我们还为<span class="math inline">\(x\)</span>添加了一个额外的判别器。</p><h3 id="adversarial-losses">Adversarial Losses</h3><p>对于隐变量<span class="math inline">\(z\)</span>，对抗损失函数为： <span class="math display">\[\mathcal L_{adv-d_z}(x,g,D_z)=E[\log(D_z(\mathcal N(0,1)))]+E[\log(1-D_z(g(x)))]\]</span> 对于样本<span class="math inline">\(x\)</span>，对抗损失函数为： <span class="math display">\[\mathcal L_{adv-d_x}(x,D_x,f)=E[\log(D_x(x))]+E[\log(1-D_x(f(\mathcal N(0,1))))]\]</span></p><h3 id="autoencoder-loss">Autoencoder Loss</h3><p><span class="math display">\[\mathcal L_\text{error}(x,g,f)=-E_z[\log(p(f(g(x))|x))]\]</span></p><h3 id="full-objective">Full Objective</h3><p><span class="math display">\[\mathcal L(x,g,D_z,D_x,f)=\mathcal L_{adv-d_z}+\mathcal L_{adv-d_x}+\lambda \mathcal L_\text{error}\]</span></p><p>下图为模型重构的例子：</p><p><img src="https://i.loli.net/2020/06/25/i7ytlgjoIbYV6uF.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h1 id="experiments">Experiments</h1><h2 id="datasets">Datasets</h2><ul><li><strong>MNIST. </strong> 手册数字识别数据集。</li><li><strong>The Coil-100. </strong>包含7200张100个不同物体的不同角度的图片。</li><li><strong>Fashion-MNIST. </strong> 手册数字识别数据集彩色版。</li><li><strong>Others. </strong> 前三个数据集都是采用一个类作为inlier，而其他类作为outlier。在这一设置中inlier采样自数据集CIFAR-10(CIFAR-100)，而outlier采样自TinyImageNet、LSUN和iSUN。</li></ul><h2 id="results">Results</h2><h3 id="mnist-dataset">MNIST Dataset</h3><p><img src="https://i.loli.net/2020/06/25/5a71oidmK2ZGLyh.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/06/25/4lcGeHDrhbdKN5W.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h3 id="coil-100-dataset">Coil-100 Dataset</h3><p><img src="https://i.loli.net/2020/06/25/ofVGBgR7a3WmyvU.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h3 id="fashion-mnist">Fashion-MNIST</h3><p><img src="https://i.loli.net/2020/06/25/avURoBw6ny8SIEq.png" srcset="/img/loading.gif" /></p><h3 id="cifar-10-cifar-100">CIFAR-10 (CIFAR-100)</h3><p><img src="https://i.loli.net/2020/06/25/piteKy1m9kvQ6EU.png" srcset="/img/loading.gif" style="zoom: 67%;" /></p><h3 id="ablation">Ablation</h3><p><img src="https://i.loli.net/2020/06/25/xgni9wBtYkheGZq.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/06/25/idhqkCbAKvzMt68.png" srcset="/img/loading.gif" style="zoom:67%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;这篇文章介绍了一种基于概率分布的异常检测方法。其基本思想是假设正常样本服从定义在流形&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;上的分布，而对于任意一点&lt;spa</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/categories/Research/Anomaly-Detection/"/>
    
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/tags/Anomaly-Detection/"/>
    
    <category term="GAN" scheme="http://qfxiao.me/tags/GAN/"/>
    
    <category term="Novelty Detection" scheme="http://qfxiao.me/tags/Novelty-Detection/"/>
    
  </entry>
  
  <entry>
    <title>Estimate the Implicit Likelihoods of GANs with Application to Anomaly Detection</title>
    <link href="http://qfxiao.me/2020/06/06/Estimate-the-Implicit-Likelihoods-of-GANs-with-Application-to-Anomaly-Detection/"/>
    <id>http://qfxiao.me/2020/06/06/Estimate-the-Implicit-Likelihoods-of-GANs-with-Application-to-Anomaly-Detection/</id>
    <published>2020-06-06T02:57:38.000Z</published>
    <updated>2020-06-25T10:59:03.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h1 id="preliminaries">Preliminaries</h1><h2 id="flow-based-models-recap">Flow-based Models Recap</h2><h3 id="jacobian-matrix-and-determinant">Jacobian Matrix and Determinant</h3><p>设函数<span class="math inline">\(f:\mathbb{R}^n\mapsto\mathbb{R}^m\)</span>，由<span class="math inline">\(f\)</span>的一阶偏导数组成的矩阵叫做Jacobian矩阵： <span class="math display">\[\mathbf J=\left[\begin{matrix}\frac{\partial f_1}{\partial x_1} &amp;\cdots &amp;\frac{\partial f_1}{\partial x_n}\\\vdots &amp;\ddots &amp;\vdots\\\frac{\partial f_m}{\partial x_1}&amp; \dots&amp; \frac{\partial f_m}{\partial x_n}\end{matrix}\right]\]</span></p><h3 id="change-of-variable-theorem">Change of Variable Theorem</h3><p>给定已知概率分布的随机变量<span class="math inline">\(z\sim\pi(z)\)</span>，新随机变量由可逆映射<span class="math inline">\(f\)</span>给出<span class="math inline">\(x=f(z)\)</span>，<span class="math inline">\(z=f^{-1}(x)\)</span>。由于： <span class="math display">\[\int p(x)\mathrm{d}x=\int \pi(z)\mathrm d z=1\]</span> 所以<span class="math inline">\(p(x)\)</span>可以由下式得到： <span class="math display">\[p(x)=\pi(z)\left|\frac{\mathrm d z}{\mathrm d x}\right|=\pi(f^{-1}(x))\left|\frac{\mathrm d f^{-1}}{\mathrm d x}\right|=\pi(f^{-1}(x))|(f^{-1})^\prime(x)|\]</span> <span class="math inline">\(\frac{\mathrm d f^{-1}}{\mathrm d x}\)</span>相当于对逆函数<span class="math inline">\(f^{-1}\)</span>求导，而<span class="math inline">\(z=f^{-1}(x)\)</span>。</p><p>对于多变量的情况： <span class="math display">\[\mathbf z\sim \pi(\mathbf z), \mathbf x=f(\mathbf z),\mathbf z = f^{-1}(\mathbf x)\\p(\mathbf x) = \pi(\mathbf z)\left|\text{det}\frac{\mathrm d \mathbf z}{\mathrm d \mathbf x}\right|= \pi(f^{-1}(\mathbf x))\left|\text{det}\frac{\mathrm d f^{-1}}{\mathrm d \mathbf x}\right|\]</span> <span class="math inline">\(\left|\text{det}\frac{\mathrm d f^{-1}}{\mathrm d \mathbf x}\right|\)</span>为逆函数Jacobian矩阵行列式的绝对值。</p><h2 id="deep-generative-models-as-manifolds">Deep Generative Models as Manifolds</h2><p>一个深度生成模型可以表示为从低维隐空间<span class="math inline">\(\mathcal Z \subseteq R^d\)</span>映射到流形<span class="math inline">\(\mathcal M\subseteq R^D\)</span>的嵌入函数<span class="math inline">\(g:\mathcal Z\rightarrow \mathcal X\)</span>，<span class="math inline">\(D \ll d\)</span>。通常假设<span class="math inline">\(g\)</span>为光滑映射，那么<span class="math inline">\(\mathcal M\)</span>为一个嵌入流形。<span class="math inline">\(g\)</span>在<span class="math inline">\(z\in\mathcal Z\)</span>的雅各比矩阵<span class="math inline">\(\mathbf J_g(z)\)</span>提供了在<span class="math inline">\(x=g(z)\in\mathcal X\)</span>处的切空间，即<span class="math inline">\(\mathbf J_g:T_z\mathcal Z\rightarrow T_x\mathcal X\)</span>。这个映射不是满射，并且值域限制在流形<span class="math inline">\(\mathcal M\)</span>在<span class="math inline">\(x=g(z)\)</span>的切空间，记为<span class="math inline">\(T_x\mathcal M\)</span>。<span class="math inline">\(\mathcal M\)</span>与真实数据流形接近，即<span class="math inline">\(\mathcal M_{data}\)</span>。</p><p>考虑一个定义在隐空间<span class="math inline">\(\mathcal Z\)</span>每一点<span class="math inline">\(z\)</span>上的Riemannian metric： <span class="math display">\[\mathbf M(z)=\mathbf J_g(z)^\top\mathbf J_g(z)\]</span> 给定两个切空间向量<span class="math inline">\(u,v\in T_z\in\mathcal Z\)</span>，他们的内积定义为<span class="math inline">\(&lt;u,v&gt;=u^\top \mathbf M(z)v\)</span>。</p><p>考虑一个光滑曲线<span class="math inline">\(\gamma:t\in[a,b]\rightarrow\mathcal Z\)</span>， <span class="math display">\[L(\gamma)=\int^b_a\sqrt{\hat{\gamma}(t)^\top M_{\gamma(t)}\hat{\gamma}(t)}\mathrm d t\]</span></p><h2 id="change-of-variable-on-manifolds">Change of Variable on Manifolds</h2><p>在流形上的<strong>Change of Variable Theorem</strong>是类似的：</p><p><span class="math display">\[p_\mathcal{X}(x)=p_\mathcal{Z}(g^{-1}(x))\text{det}(\mathbf J_g(g^{-1}(x))^\top\mathbf J_g(g^{-1}(x)))^{-\frac{1}{2}}\]</span></p><p>我们假设隐空间分布<span class="math inline">\(p_\mathcal{Z}\)</span>服从标准正态先验分布<span class="math inline">\(N(0,\mathbf I_d)\)</span>，于是我们可以计算出<span class="math inline">\(x\)</span>的似然：</p><p><span class="math display">\[\log(p_\mathcal{X}(g(z)))=\log(p_\mathcal{Z}(z))-\frac{1}{2}\log(\text{det}(\mathbf J_g(z)^\top\mathbf J_g(z)))\]</span></p><p>通常我们没法知道真实世界中<span class="math inline">\(\mathcal M_{data}\)</span>的切空间维度是多少，设定<span class="math inline">\(d=\text{dim}\mathcal Z&gt;T_x\mathcal M_{data}\)</span>会导致<span class="math inline">\(\mathbf J_g\)</span>不是满秩矩阵，这时<span class="math inline">\(\text{det}(\mathbf J_g(z)^\top\mathbf J_g(z))=0\)</span>，即无法应用上式计算似然。</p><h2 id="density-estimation-with-neural-networks">Density Estimation with Neural Networks</h2><h2 id="anomaly-detection-with-generative-models">Anomaly Detection with Generative Models</h2><h1 id="proposed-method">Proposed Method</h1><p>对于GAN模型，给定隐变量<span class="math inline">\(z\)</span>和生成器<span class="math inline">\(g\)</span>，我们可以通过公式(8)计算生成样本<span class="math inline">\(g(z)\)</span>的对数似然，为了保证Jacobian矩阵为满秩，我们可以选定较低的隐变量维度<span class="math inline">\(d\)</span>，不过这样会伤害GAN模型的性能。为了解决这个问题，我们需要使用一个<em>inference network</em>来将<span class="math inline">\(x\)</span>映射回<span class="math inline">\(z\)</span>，</p><h2 id="the-variance-network-of-the-generator">The Variance Network of the Generator</h2><p>文中对生成器<span class="math inline">\(g\)</span>进行了扩展：</p><p><span class="math display">\[f(z) = g(z) + \sigma(z)\odot\epsilon,\\g:\mathcal Z\rightarrow\mathcal X, \sigma:\mathcal Z\rightarrow\mathbb{R},\epsilon\sim N(0,\mathbf I_D)\]</span></p><p><span class="math inline">\(g\)</span>代表均值，<span class="math inline">\(\sigma\)</span>代表方差，实际上<span class="math inline">\(\mathbb E_{\epsilon\sim N(0,\mathbf I_D)}f(z)=g(z)\)</span>。为了保证方差在少样本或无样本的区域更大，方差网络采用RBF网络实现。</p><blockquote><p>RBF网络： <span class="math display">\[h(x)=\exp\left(-\frac{(x-c)^2}{r^2}\right)\]</span> <img src="https://i.loli.net/2020/06/25/ho5FJsOBjxi2G78.png" srcset="/img/loading.gif" style="zoom: 80%;" /></p><p><img src="https://i.loli.net/2020/06/25/rtRLwyK2VigOvTh.png" srcset="/img/loading.gif" style="zoom: 50%;" /></p></blockquote><p>首先，从隐空间采样大量的样本，之后使用<strong>K-means</strong>算法将其分为<span class="math inline">\(K\)</span>个聚簇，<span class="math inline">\(c_k\)</span>为第<span class="math inline">\(k\)</span>个簇的中心，<span class="math inline">\(C_k\)</span>为第<span class="math inline">\(k\)</span>个簇的样本数量。对于任何样本<span class="math inline">\(x\)</span>，为了计算其对应的方差，需要用一个<em>inference network</em> <span class="math inline">\(h\)</span>来将其映射到隐空间，即<span class="math inline">\(z=h(x)\)</span>。RBF网络通过输入<span class="math inline">\(z\)</span>到每个簇中心的距离来返回<span class="math inline">\(x\)</span>对应的方差，RBF函数由下式给出： <span class="math display">\[\sigma(z)=(\mathbf W^2\mathbf v(z))^{-\frac{1}{2}},\\v_k(z) = \exp(-\lambda_k\parallel z-c_k\parallel^2_2), \space k=1,\cdots,K\\\lambda_k=\frac{1}{2}\left(\frac{a}{|C_k|}\sum_{z_j\in C_k}\parallel z_j-c_k\parallel_2\right)^{-2}\]</span></p><p>其中<span class="math inline">\(\alpha\)</span>为核的超参数，<span class="math inline">\(\mathbf W\)</span>为模型参数。给定生成器<span class="math inline">\(g\)</span>，我们可以通过最小化<span class="math inline">\(f(z)\)</span>和<span class="math inline">\(x\)</span>之间的距离来优化参数<span class="math inline">\(\mathbf W\)</span>。</p><p><span class="math display">\[\begin{align}\bar{\mathbf M}^z_f&amp;=\mathbb E_{\epsilon\sim N(0,\mathbf I_D)}\mathbf J_f^\top(z)\mathbf J_f(z)\\&amp;=\mathbf J_g^\top(z)\mathbf J_g(z)+\mathbf J_\sigma^\top(z)\mathbf J_\sigma(z)\end{align}\]</span></p><blockquote><p><strong>LEMMA 1. </strong> 对于<span class="math inline">\(K\geq \text{dim}(\mathcal Z)+1\)</span>和满秩矩阵<span class="math inline">\(\mathbf W^2\)</span>，<span class="math inline">\(\bar{\mathbf M}_f^z\)</span>为一个满秩矩阵。生成样本的对数似然由下式给出： <span class="math display">\[\mathbb E_{\epsilon\sim N(0,\mathbf I_D)}\log(p_\mathcal{X}(f(z)))=\log(p_\mathcal{Z}(z))-\frac{1}{2}\log(\text{det}(\bar{\mathbf M}_f^z))\]</span></p></blockquote><h2 id="the-inference-network-learning">The Inference Network Learning</h2><p><img src="https://i.loli.net/2020/06/25/AZfIrq2v8RVipj1.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><span class="math display">\[\max_{h,\sigma}\mathbb E_{x\sim p_{data}(x)}\left[\log(p(x|z))|_{z=h(x)}\right]\]</span></p><p><span class="math inline">\(p(x|z)\)</span></p><p><span class="math display">\[\max_{h,\sigma}\mathbb E_{x\sim p_{data}(x), z=h(x)}\left[\log(p(x|z))-\text{KL}\right]\]</span></p><blockquote><p><strong>LEMMA 2. </strong> <span class="math display">\[f(z)\sim GP(g(z), \Lambda_\sigma)\]</span></p></blockquote><p><span class="math display">\[L_{h,\sigma}=\mathbb E_{x\sim p_{data}}\left[\sum_{i=1}^D[-\frac{1}{2}(g_i(h(x))-x_i)^2/\sigma_i^2(h(x))-\log\sigma_i(h(x))]-\text{KL}(q(z|x)\parallel p(z))\right]\]</span></p><h2 id="stabilize-training">Stabilize Training</h2><p><span class="math display">\[\min_{g,h}\mathbb E_{z\sim p(z)}[\parallel z-h(g(z))\parallel^2]\]</span></p><h2 id="algorithm">Algorithm</h2><p><img src="https://i.loli.net/2020/06/25/PjJF9wBM2XS38TQ.png" srcset="/img/loading.gif" style="zoom: 80%;" /></p><blockquote><p><strong>LEMMA 3. </strong></p></blockquote><h1 id="experiments">Experiments</h1><p><img src="https://i.loli.net/2020/06/25/GlqvJFOtEnbNoUP.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/25/Z8yDQU9McsT5GXI.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/25/NmBten8igTUV76L.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/25/8phKZkiRxdLyBT6.png" srcset="/img/loading.gif" /></p><p><img src="https://i.loli.net/2020/06/25/noBqN9gWfPuFy8w.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/25/sJnwi5RzLAU3D6x.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/25/OvtLenWDSEi37lX.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/25/TIJbpsvGkwz3rVF.png" srcset="/img/loading.gif" style="zoom:67%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;h1 id=&quot;preliminaries&quot;&gt;Preliminaries&lt;/h1&gt;
&lt;h2 id=&quot;flow-based-models-recap&quot;&gt;Flow-based Models Recap</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/categories/Research/Anomaly-Detection/"/>
    
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/tags/Anomaly-Detection/"/>
    
    <category term="GAN" scheme="http://qfxiao.me/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>Classification-based Anomaly Detection for General Data</title>
    <link href="http://qfxiao.me/2020/06/02/Classification-based-Anomaly-Detection-for-General-Data/"/>
    <id>http://qfxiao.me/2020/06/02/Classification-based-Anomaly-Detection-for-General-Data/</id>
    <published>2020-06-02T15:01:34.000Z</published>
    <updated>2020-06-26T12:55:43.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>本文主要是对<a href="http://qfxiao.me/2020/06/01/Deep-Anomaly-Detection-Using-Geometric-Transformations/">NIPS18这篇异常检测文章</a>的改进，首先是利用了标签信息来提升算法的表现，其次是将算法扩展到了非图像数据。作者对现有的异常检测算法进行了回顾：</p><ul><li><strong>Reconstruction Methods： </strong>这一部分方法假设异常样本和正常样本能够通过重构任务来进行区分。通过在正常样本上学习重构任务，之后对于正常样本，模型能够很好地进行重构，而异常样本则会有较高的重构误差。</li><li><strong>Distributional Methods： </strong>这一部分方法将异常检测看作是密度估计问题。通过对正常样本的分布进行估计，异常样本在该正常分布下的似然将会很低。</li><li><strong>Classification-based Methods： </strong>这一部分方法主要是指的单分类方法和通过几何变换构造分类任务的方法。本文使用的就是这类方法。</li></ul><h1 id="proposed-method">Proposed Method</h1><h2 id="classification-based-anomaly-detection">Classification-based Anomaly Detection</h2><p>假设所有数据位于空间<span class="math inline">\(R^L\)</span>内，而正常数据位于子空间<span class="math inline">\(X\subset R^L\)</span>内。我们假设所有的异常样本位于<span class="math inline">\(X\)</span>之外。为了检测异常，我们希望学习一个分类器<span class="math inline">\(C\)</span>使得对于所有的<span class="math inline">\(x\in X\)</span>有<span class="math inline">\(C(x)=1\)</span>，而对所有的<span class="math inline">\(x\in R^L\backslash X\)</span>有<span class="math inline">\(C(x)=0\)</span>。</p><p>单分类方法的思想是直接学习<span class="math inline">\(P(x\in X)\)</span>，代表的方法有One-Class SVM，DSVDD等。传统的OC-SVM直接在原始空间或者核空间学习分类器。比较新的方法，如Deep-SVDD则是先将样本转换到一个特征空间，然后在这个特征空间上学习使得半径<span class="math inline">\(R\)</span>最小的超球体（球心<span class="math inline">\(c_0\)</span>），来覆盖住所有正常样本。异常的判定则通过计算<span class="math inline">\(\parallel f(x)-c_0\parallel^2-R^2\)</span>来实现。不过学习一个好的样本到特征空间的变换并不是一件容易的事情，比如说<span class="math inline">\(f(x)=0, \forall x \in X\)</span>就是一个使得超球体最小的解。所以需要很多trick来避免诸如此类的情况。</p><p><em>Geometric-transformation classification</em> (GEOM) 则将数据空间<span class="math inline">\(X\)</span>通过<span class="math inline">\(M\)</span>个几何变换转换到一系列子空间<span class="math inline">\(X_1,\cdots,X_M\)</span>。之后训练一个分类器来预测样本<span class="math inline">\(T(x,m)\)</span>对应的几何变换的种类<span class="math inline">\(m\)</span>。转换后的正常图片空间记为<span class="math inline">\(\cup_m X_m\)</span>，所以该方法尝试估计以下条件概率： <span class="math display">\[P(m^\prime|T(x,m))=\frac{P(T(x,m)\in X_{m^\prime})P(m^\prime)}{\sum_{\bar{m}}P(T(x,m)\in X_{\bar{m}})P(\tilde{m})}-\frac{P(T(x,m)\in X_{m^\prime})}{\sum_{\bar{m}}P(T(x,m)\in X_{\bar{m}})}\]</span></p><p>对于异常的样本<span class="math inline">\(x\in R^L\backslash X\)</span>，在经过几何变换之后，都不会位于正确的子空间中，即<span class="math inline">\(T(x,m)\in R^L\backslash X_m\)</span>。之后，使用<span class="math inline">\(P(m|T(x,m))\)</span>来判定异常。</p><p>作者认为，这种方法的问题是分类器<span class="math inline">\(P(m^\prime|T(x,m))\)</span>只在正常数据上训练，而对于异常样本的异常分数会出现方差很大的问题。</p><p>一种解决方式是加入异常样本进行训练，但是作者认为在有的任务中标签很难获取，于是作者使用了另外一种方法来解决这个问题。</p><h2 id="distance-based-multiple-transformation-classification">Distance-based Multiple Transformation Classification</h2><p>和GEOM一样，先对每个样本进行<span class="math inline">\(M\)</span>个几何变换，然后学习一个特征提取器<span class="math inline">\(f(x)\)</span>，将<span class="math inline">\(X_m\)</span>映射到特征空间。之后和OC-SVM类似，假设特征<span class="math inline">\(\{f(x)|x\in X_m\}\)</span>为球心为<span class="math inline">\(c_m=\frac{1}{N}\sum_{x\in X} f(T(x,m))\)</span>的超球体。样本属于某一类<span class="math inline">\(m^\prime\)</span>的概率由下式给出：</p><p><span class="math display">\[P(m^\prime|T(x,m))=\frac{e^{-\parallel f(T(x,m))-c_{m^\prime}\parallel^2}}{\sum_{\bar m}e^{-\parallel f(T(x,m))-c_{\bar m}\parallel^2}}\]</span></p><p>目标函数采用的是Triplet Loss：</p><p><span class="math display">\[L=\sum_i\max(\parallel f(T(x_i,m))-c_m\parallel^2+s-\min_{m^\prime\neq m}\parallel f(T(x_i,m))-c_{m^\prime}\parallel^2,0)\]</span></p><p><span class="math inline">\(\parallel f(T(x_i,m))-c_m\parallel^2\)</span>相当于最小化了类内距离，<span class="math inline">\(\min_{m^\prime\neq m}\parallel f(T(x_i,m))-c_{m^\prime}\parallel^2\)</span>最大化了每个类对应的集簇间距离。在检测阶段，为了避免一些数值问题，作者做了一些平滑操作：</p><p><span class="math display">\[\tilde P(m^\prime|T(x,m))=\frac{e^{-\parallel f(T(x,m))-c_{m^\prime}\parallel^2+\epsilon}}{\sum_{\tilde m}e^{-\parallel f(T(x,m))-c_{\tilde m}\parallel^2+M\cdot\epsilon}}\]</span></p><p>最后的评判分数由下式给出：</p><p><span class="math display">\[Score(x)=-\log P(x\in X)=-\sum_m\log \tilde{P}(T(x,m)\in X_m)=-\sum_m\log\tilde{P}(m|T(x,m))\]</span></p><p>算法流程图如下：</p><p><img src="https://i.loli.net/2020/06/24/r48h1RJxcXF6YDM.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h2 id="parameterizing-the-set-of-transformations">Parameterizing the Set of Transformations</h2><p>在GEOM中，由于使用的几何变换都是针对图像的，所以对于其他类型的数据并不适用。本文中作者对非图像数据设计了以下变换：</p><p><span class="math display">\[T(x,m)=W_mx+b_m\]</span></p><p>不同的参数<span class="math inline">\(W_m\)</span>和<span class="math inline">\(b_m\)</span>即为不同的几何变换，可以考虑采用随机采样的方式。</p><h1 id="experiments">Experiments</h1><h2 id="image-experiments">Image Experiments</h2><p>对于图像数据的异常检测实验，作者采用了CIFAR10、FasionMNIST这两个数据集，实验结果如下：</p><p><img src="https://i.loli.net/2020/06/24/j4Y29tB6k1Aipgo.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2020/06/24/D3opwrLnSGmcsyM.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h2 id="tabular-data-experiments">Tabular Data Experiments</h2><p>对于非图像数据，作者采用了几个小的数据集：Arrhythmia、Thyroid、KDD和KDDRev。采用的Baseline包括OC-SVM、E2E-AE、LOF、DAGMM和FB-AE (Feature Bagging Autoencoder)。对于几何变换的参数，采样自标准正态分布。结果如下：</p><p><img src="https://i.loli.net/2020/06/24/e6PfIDOVwlzrSWi.png" srcset="/img/loading.gif" style="zoom:67%;" /></p><h1 id="remark">Remark</h1><p>结合<a href="https://openreview.net/forum?id=H1lK_lBtvS">OpenReview</a>上的一些讨论，这里提出一些问题和总结：</p><ul><li>KDD数据集太简单了，正常、异常样本能够很容易被分开；</li><li>对于图像数据作者只使用了CIFAR10和FashionMNIST这两个比较小的数据集，而在GEOM中还使用了CIFAR100和CatsVsDogs。并且GEOM原文中提到数据集（指图像大小）越大，GEOM的优势就越明显，所以在本文的实验中只使用这两个数据集说服力略显不够；</li><li>关于评测标准的问题，作者在图像数据中用的是AUROC，而非图像数据用的是F1 score。像AUPR、AUROC这种评测标准往往更加全面，而F1 score依赖于阈值的选取。如果是遍历阈值找到最好的那个F1 score，则无法全面考察模型的鲁棒性，模型有可能只是在特定的阈值下表现很好，而阈值稍微偏差一下性能可能就会大幅下降。我看到的大多数异常检测文章都是使用AUROC或者F1加上AUROC作为评测指标；</li><li>文中在第二节“CLASSIFICATION-BASED ANOMALY DETECTION”的末尾两段关于GEOM方法的缺点说的很模糊。异常分数的方差大到底指的是什么；</li><li>关于作者提出的变换<span class="math inline">\(T(x,m)=W_mx+b_m\)</span>并没有用到图像数据的实验上，而且在实验中<span class="math inline">\(b_m\)</span>这个参数实际上是被忽略掉了的，<span class="math inline">\(b_m\)</span>的作用究竟如何不得而知。而且GEOM中的几何变换的Motivation在原文中是做了实验充分讨论了的，GEOM的作者认为这些几何变换保留了图像的高阶语义信息。而本文中的变换中的参数只是随机采样而来，并不存在说保留原始数据中的结构信息。如果忽略掉这一层变换，那就类似于加了神经网络提取特征的OC-SVM。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;本文主要是对&lt;a href=&quot;http://qfxiao.me/2020/06/01/Deep-Anomaly-Detection-Using-Geometric-Transformation</summary>
      
    
    
    
    <category term="Research" scheme="http://qfxiao.me/categories/Research/"/>
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/categories/Research/Anomaly-Detection/"/>
    
    
    <category term="Anomaly Detection" scheme="http://qfxiao.me/tags/Anomaly-Detection/"/>
    
  </entry>
  
</feed>
