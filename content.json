{"meta":{"title":"Hanzawa の 部屋","subtitle":null,"description":null,"author":"Hanzawa","url":"http://qfxiao.me","root":"/"},"pages":[{"title":"","date":"2020-05-27T10:57:23.346Z","updated":"2020-05-27T10:57:23.346Z","comments":false,"path":"css/custom.css","permalink":"http://qfxiao.me/css/custom.css","excerpt":"","text":"/* .navbar-custom { color: #f6ad8f } */"},{"title":"about me","date":"2020-05-27T09:44:48.000Z","updated":"2021-08-30T03:55:20.847Z","comments":false,"path":"about/index.html","permalink":"http://qfxiao.me/about/index.html","excerpt":"","text":"About Me Hi there, I am Xiao Qinfeng (肖钦峰)! 👋 🔭 I’m currently pursuing a Master degree in Computer Science at Beijing Jiaotong University. 🌱 My research interests include: Anomaly Detection Deep Learning for Physiological Signals Unsupervised Learning Self-supervised Learning 📫 You can contact me by: Email: qfxiao@bjtu.edu.cn Recent Researches Deep Anomaly Detection for Time-series Self-supervised Learning for Physiological Time-series Publications Qinfeng Xiao, Jing Wang, et al. Unsupervised Anomaly Detection with Distillated Teacher-Student Network Ensemble. Entropy. 2021; 23(2):201. Qinfeng Xiao, Jing Wang, et al. Self-Supervised Learning for Sleep Stage Classification with Predictive and Discriminative Contrastive Coding, ICASSP 2021 - 2021 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Toronto, Canada, 2021. Yunxiao Liu, Youfang Lin, Qinfeng Xiao, et al. Self-adversarial Variational Autoencoder with Spectral Residual for Time Series Anomaly Detection, Neurocomputing, 2021."}],"posts":[{"title":"Unsupervised Feature Learning via Non-Parametric Instance Discrimination","slug":"Unsupervised-Feature-Learning-via-Non-Parametric-Instance-Discrimination","date":"2020-09-23T12:36:57.000Z","updated":"2021-02-28T04:58:08.309Z","comments":true,"path":"2020/09/23/Unsupervised-Feature-Learning-via-Non-Parametric-Instance-Discrimination/","link":"","permalink":"http://qfxiao.me/2020/09/23/Unsupervised-Feature-Learning-via-Non-Parametric-Instance-Discrimination/","excerpt":"","text":"Introduction 本文基于样本分类和噪声对比估计提出了一个无监督表示学习算法。下图展示了一个Intuition Example： 对于一个有监督的分类器，输入一张图片，作者观察到分类器的Softmax Response中较高的那些类都是在视觉上看起来比较接近的（美洲豹Leopard，美洲虎Jaguar，印度豹Cheetah），也就是说网络捕捉到了类间的视觉相似性，不过这是在有标签的情况下。对于无监督表示学习任务，作者将这个观察推广到了一个极端情况，就是把每一个样本都视作不同的类，然后让分类器来学习样本（类）间的视觉相似性。不过直接这么做会有严重的效率问题，所以作者还利用了Memory Bank机制和噪声对比估计来提高效率。 Proposed Method 学习一个嵌入表示函数\\(\\mathbf v=f_\\theta(x)\\)。在表示空间中\\(d_\\theta(x,y)=\\parallel f_\\theta(x)-f_\\theta(y)\\parallel\\) Non-Parametric Softmax Classifier Parametric Classifier 在经过嵌入表示函数之后，得到表示向量\\(\\mathbf v_i=f_\\theta(\\mathbf x_i)\\)。要基于这个向量进行分类， \\[ P(i|\\mathbf v)=\\frac{\\exp(\\mathbf w_i^\\top\\mathbf v)}{\\sum_j\\exp(\\mathbf w_j^\\top\\mathbf v)} \\] ### Non-Parametric Classifier \\[ P(i|\\mathbf v)=\\frac{\\exp(\\mathbf v_i^\\top\\mathbf v/\\tau)}{\\sum_j\\exp(\\mathbf v_j^\\top\\mathbf v/\\tau)} \\] 同时约束\\(\\parallel \\mathbf v\\parallel=1\\) 最后的损失函数为负对数似然损失（negative log-likelihood）： \\[ J(\\theta)=-\\sum_{i=1}^n\\log P(i|f_\\theta(x_i)) \\] 到这里，算法的大框架就确定下来了，剩下的就是解决两个效率上的问题。一个是损失函数的计算每次都需要计算整个训练集的表示，同时Softmax函数由于分母对应的项目很多（等于训练集大小）在效率上也有问题。 Learning with A Memory Bank 这里解决第一个效率问题。要计算损失函数，需要遍历整个训练集获得对应的表示，而在训练的时候是一批一批的数据，每次重新计算表示效率很低。为了解决这个问题，作者引入了缓存机制，即加入一个memory bank \\(V\\)，用来保存计算好的表示\\(\\mathbf f_i=f_\\theta(x_i)\\)。一开始\\(V\\)采用单位随机向量初始化，之后在训练的时候不断更新\\(\\mathbf f_i\\rightarrow \\mathbf v_i\\)。 Noise Contrastive Estimation 第二个效率问题很容易想到使用噪声对比估计（Noise Contrastive Estimation, NCE）来做。NCE主要是将计算复杂的分母作为一个参数来进行优化： \\[ P(i|\\mathbf v)=\\frac{\\exp(\\mathbf v^\\top\\mathbf f_i/\\tau)}{Z_i} \\] 其中\\(Z_i=\\sum_{j=1}^n\\exp(\\mathbf v^\\top_j\\mathbf f_i/\\tau)\\)，噪声分布\\(P_n=1/n\\)，如果噪声样本数量是真实数据的\\(m\\)倍，那么随意给定一个样本，其属于真实样本的后验概率为： \\[ h(i,\\mathbf v)=P(D=1|i,\\mathbf v)=\\frac{P(i|\\mathbf v)}{P(i|\\mathbf v)+mP_n(i)}=\\sigma\\left(s(\\mathbf v)-\\log \\{m P_n(i)\\}\\right) \\] 其中\\(\\Delta s=s(\\mathbf v)-\\log [m P_n(i)]\\)。这里的真实数据分布\\(P_d\\)为。NCE的损失函数就是要最大化\\(h(i,\\mathbf v)\\)，最小化\\(h(i,\\mathbf v^\\prime)\\) \\[ J_{NCE}(\\theta)=-E_{P_d}[\\log h(i,\\mathbf v)]-m\\cdot E_{P_n}[\\log(1-h(i,\\mathbf v^\\prime))] \\] 为了计算\\(Z_i\\) \\[ Z\\simeq Z_i\\simeq nE_j[\\exp(\\mathbf v_j^\\top\\mathbf f_i/\\tau)]=\\frac{n}{m}\\sum_{k=1}^m\\exp(\\mathbf v_{j_k}^\\top\\mathbf f_i/\\tau) \\] Proximal Regularization 每个类别只有一个样本 \\[ -\\log h(i,\\mathbf v_i^{(t-1)})+\\lambda\\parallel\\mathbf v_i^{(i)}-\\mathbf v_i^{(i-1)}\\parallel^2_2 \\] 最终的损失函数： \\[ J_{NCE}(\\theta)=-E_{P_d}\\left[\\log h(i,\\mathbf v_i^{(t-1)})-\\lambda\\parallel\\mathbf v_i^{(t)}-\\mathbf v_i^{(t-1)}\\parallel^2_2\\right]\\\\ -m\\cdot E_{P_n}\\left[\\log(1-h(i,\\mathbf v^{\\prime(t-1)}))\\right] \\] Weighted k-Nearest Neighbor Classifier \\(s_i=\\cos(\\mathbf v_i,\\hat{\\mathbf f})\\)。记\\(\\mathcal N_k\\)。\\(w_c=\\sum_{i\\in\\mathcal N_k}\\alpha_i\\cdot 1(c_i=c)\\)。 Experiments","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Self-supervised Learning","slug":"Research/Self-supervised-Learning","permalink":"http://qfxiao.me/categories/Research/Self-supervised-Learning/"}],"tags":[{"name":"Representation Learning","slug":"Representation-Learning","permalink":"http://qfxiao.me/tags/Representation-Learning/"},{"name":"Self-supervised Learning","slug":"Self-supervised-Learning","permalink":"http://qfxiao.me/tags/Self-supervised-Learning/"}]},{"title":"Representation Learning with Contrastive Predictive Coding","slug":"Representation-Learning-with-Contrastive-Predictive-Coding","date":"2020-09-17T12:08:53.000Z","updated":"2021-02-19T10:20:26.291Z","comments":true,"path":"2020/09/17/Representation-Learning-with-Contrastive-Predictive-Coding/","link":"","permalink":"http://qfxiao.me/2020/09/17/Representation-Learning-with-Contrastive-Predictive-Coding/","excerpt":"","text":"Introduction 这篇文章算是Contrastive Learning的开山之作之一了，本文提出了表示学习框架：Contrastive Predictive Coding（CPC）和InfoNCE Loss。 原文 Proposed Method Contrastive Predictive Coding N-pair Loss: \\[ \\mathcal L=-\\log\\frac{\\exp(f^+\\cdot f^\\top)}{\\exp(f^+\\cdot f^\\top)+\\sum_{f_j\\neq f^\\top}\\exp(f^+\\cdot f_j)} \\] 你有N个样本\\(\\{x_1,x_2,\\cdots,x_N\\}\\)，然后对应的表示为\\(f_j\\)。假设当前样本为\\(f^+\\)，在所有的\\(f_j\\)中只有一个表示与\\(f^+\\) match，记为\\(f^\\top\\)（可以理解为属于同一类，或者两个相似），其他的都是负样本。我们优化上面的优化公式就会拉近\\(f^+\\)和\\(f^\\top\\)之间的距离（拉近同类），疏远\\(f^+\\)和所有其他负样本\\(f_j\\)的距离（疏远异类）。不过在N-pair Loss中，正负样本是根据标签来选取的，然而在这里我们没有标签。 下图展示了Contrastive Predictive Coding的结构： 对比学习 \\[ \\mathcal L(f_i)=-\\log\\frac{\\exp(f_i\\cdot f^\\top)}{\\sum_j\\exp(f_i\\cdot f_j)} \\] 设数据集（一个Batch）为\\(\\mathbf X=\\{x_1,x_2,\\cdots,x_N\\}\\)，正样本对为，负样本对。 至于\\(f(\\cdot,\\cdot)\\)的具体形式，其实\\(\\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\\)这个式子我们也是没法直接优化的，因为这个Density Ratio无法直接算出来。在这里，作者使用了一个替代的办法，就是用\\(\\mathbf c_t\\)来预测未来的隐变量\\(\\hat{\\mathbf z}_{t+1},\\hat{\\mathbf z}_{t+2},\\cdots\\)，而真实的隐变量\\(\\mathbf z_{t+1},\\mathbf z_{t+2},\\cdots\\)我们是知道的。这里预测直接使用权重矩阵和\\(\\mathbf c_t\\)相乘： \\[ f_k(\\mathbf x_{t+k},\\mathbf c_t)=\\exp\\left(\\mathbf z_{t+k}^T \\cdot \\mathbf W_k\\mathbf c_t\\right) \\] 上式有点难以理解，实际上预测值\\(\\hat{\\mathbf z}_{t+k}=\\mathbf W_k\\mathbf c_t\\)，而\\(\\mathbf z_{t+k}\\hat{\\mathbf z}_{t+k}\\)相当于计算两者的距离，即相似性。所以\\(f_k(\\cdot,\\cdot)\\)其实是在计算预测值和真实值的相似性。现在大家先接受这个\\(f(\\cdot,\\cdot)\\)的定义，因为后面会证明优化这个\\(f(\\cdot,\\cdot)\\)就相当于在优化Density Ratio \\(\\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\\)。 一个来自\\(p(x_{t+k}|c_t)\\)的正例和\\(N-1\\)个来自\\(p(x_{t+k})\\)的负例，目标函数（文中称为CPC Loss）为： \\[ \\mathcal L_N=-\\mathop{\\mathbb E}\\limits_X\\left[\\log\\frac{f_k(x_{t+k},c_t)}{\\sum_{x_j\\in X}f_k(x_j,c_t)}\\right] \\] 这里相当于做了个\\(N\\)分类，因为这里损失函数等价于\\(N\\)分类交叉熵损失函数。 两个离散随机变量的交叉熵的定义为： \\[ H(p,q) = -\\sum_{x\\in\\mathcal X}p(x)\\log q(x) \\] 对于交叉熵损失函数，设\\(i\\)为真实标签，\\(\\hat{\\boldsymbol y}\\)为分类器的输出。\\(\\frac{\\exp(\\hat y_i)}{\\sum_j\\exp(\\hat y_j)}\\)为经过Softmax归一化之后的输出，其每个分量\\(\\hat y_j\\)相当于输入样本\\(x\\)的预测类别为\\(j\\)的概率。不过由于对于真实标签\\(y\\)来说，只有\\(y_i=1\\)，其他的分量都为\\(0\\)，所以最后交叉熵只剩下一项： \\[ \\mathcal L=-\\log\\left(\\frac{\\exp(\\hat y_i)}{\\sum_j\\exp(\\hat y_j)}\\right) \\] \\[ I(x;c)=\\sum_{x,c}p(x,c)\\log\\frac{p(x|c)}{p(x)} \\] 编码器\\(g_{enc}\\)将观测值\\(\\boldsymbol x_t\\)编码到隐变量\\(\\boldsymbol z_t=g_\\text{enc}(\\boldsymbol x_t)\\)（对应于局部信息），之后自回归模型\\(g_{ar}\\)将所有\\(t\\)之前的（包括\\(t\\)）隐变量\\(z_{\\leq t}\\)压缩到一个上下文隐变量\\(\\boldsymbol c_t=g_\\text{ar}(\\boldsymbol z_{\\leq t})\\)（希望具有预测性质，捕获了长时依赖性）。不过本文并不是基于\\(\\boldsymbol c_t\\)来预测未来的观测值\\(\\boldsymbol x_{t+k}\\)，即估计分布\\(p_k(\\boldsymbol x_{t+k}|\\boldsymbol c_t)\\)，而这样的话又要用到MSE之类的Loss。文中利用的是最大化\\(\\boldsymbol c_t\\)和\\(\\boldsymbol x_{t+k}\\)之间的互信息\\(\\log \\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\\)（这种形式的互信息被称为是点互信息，详见维基）。定义一个度量函数\\(f(\\cdot,\\cdot)\\)，要求其具有与\\(\\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}\\)成比例的性质： \\[ f_k(x_{t+k},c_t)\\propto\\frac{p(x_{t+k}|c_t)}{p(x_{t+k})} \\] 这时最大化\\(f(\\cdot,\\cdot)\\)就相当于最大化两者的互信息。 Mutual Information Estimation Explanation 现在回到公式\\(I(x;c)=\\sum_{x,c}p(x,c)\\log\\frac{p(x|c)}{p(x)}\\)， Multual Information 互信息是衡量已知一个变量时，另一个变量不确定性的减少程度的度量。对于离散随机变量，互信息的定义为： \\[ I(X,Y)=\\sum_{y\\in\\mathcal Y}\\sum_{x\\in\\mathcal X}p(x,y)\\log\\frac{p(x,y)}{p(x)p(y)}=\\sum_{y\\in\\mathcal Y}\\sum_{x\\in\\mathcal X}p(x,y)\\log\\frac{p(y|x)}{p(y)} \\] 对于连续随机变量，互信息的定义为： \\[ I(X,Y)=\\int_{\\mathcal Y}\\int_{\\mathcal X}p(x,y)\\log\\frac{p(x,y)}{p(x)p(y)}\\mathrm dx\\mathrm d y=\\int_{\\mathcal Y}\\int_{\\mathcal X}p(x,y)\\log\\frac{p(y|x)}{p(y)}\\mathrm dx\\mathrm d y \\] 互信息与熵之间的关系： \\[ \\begin{align} I(X,Y)&amp;=H(X)-H(X|Y)\\\\ &amp;=H(Y)-H(Y|X)\\\\ &amp;=H(X)+H(Y)-H(X,Y)\\\\ &amp;=H(X,Y)-H(X|Y)-H(Y|X) \\end{align} \\] 互信息与KL散之间的关系： \\[ I(X,Y)=\\mathbb E_Y[D_{KL}(p(x|y)\\parallel p(x))] \\] 从图中可以很容易看出互信息相当于\\(X\\)和\\(Y\\)两者的熵的“重叠”的部分： 在表示学习中，互信息的应用越来越广泛。对于输入的数据\\(X\\)，表示学习的目的是尽可能学到“好“的表示\\(Z\\)，保留原始数据尽可能多的重要信息。如果使用基于重构的模型，我们就会要求最小化重构误差\\(\\parallel X-\\hat{X}\\parallel^2_2\\)，但是这种”逐像素“式的损失函数过于严苛，不利于模型学习高层语义信息。如果加入一个判别器来自动学习一个度量，首先增大了计算开销，同时GAN本身也有诸多问题。 现阶段很多工作使用互信息来判定学到的表示\\(Z\\)的好坏，即最大化原始数据\\(X\\)与表示\\(Z\\)之间的互信息： \\[ Z^*=\\mathop{\\arg\\max}_{p(z|x)}I(X,Z) \\] 互信息越大意味着\\(\\log\\frac{p(z|x)}{p(z)}\\)越大，即\\(p(z|x)\\)要大于\\(p(z)\\)。\\(p(z)\\)可以看作是\\(Z\\)的先验，而\\(p(z|x)\\gg p(z)\\)可以理解为在得知输入\\(X\\)之后，我们能找到专属\\(X\\)的那个编码\\(Z\\)。 接下来作者证明优化\\(\\mathcal L_N\\)会使得\\(f_k(\\mathbf x_{t+k},\\mathbf c_t)\\)和互信息接近。这里的\\(p(\\mathbf x_{t+k}|\\mathbf c_t)\\)。设\\(p(d=i|X,c_t)\\)为给定数据集（或者Batch）\\(X\\)和context向量\\(c_t\\)的条件下，样本\\(x_i\\)为正样本的概率，有： \\[ \\begin{align} p(d=i|X,c_t)&amp;=\\frac{p(x_i|c_t)\\prod_{l\\neq i}p(x_l)}{\\sum^N_{j=1} p(x_j|c_t)\\prod_{l\\neq j}p(x_l)}\\\\ &amp;=\\frac{\\frac{p(x_i|c_t)}{p(x_i)}}{\\sum^N_{j=1}\\frac{p(x_j|c_t)}{p(x_j)}} \\end{align} \\] $$ \\[\\begin{align} \\mathcal L_\\text{N}^\\text{opt}&amp;=-\\mathop{\\mathbb E}\\limits_X\\log\\left[\\frac{\\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}}{\\frac{p(x_{t+k}|c_t)}{p(x_{t+k})}+\\sum_{x_j\\in X_\\text{neg}}\\frac{p(x_j|c_t)}{x_j}}\\right]\\\\ \\end{align}\\] $$ \\[ I(x_{t+k},c_t)\\geq \\log(N)-\\mathcal L_N \\] 可以说\\(\\mathcal L_N\\)作为互信息\\(I(x_{t+k},c_t)\\)的一个下界。 Implementation Details Experiments Audio Vision Natural Language Reinforcement Learning","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Self-supervised Learning","slug":"Research/Self-supervised-Learning","permalink":"http://qfxiao.me/categories/Research/Self-supervised-Learning/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Contrastive Learning","slug":"Contrastive-Learning","permalink":"http://qfxiao.me/tags/Contrastive-Learning/"},{"name":"Self-supervised Learning","slug":"Self-supervised-Learning","permalink":"http://qfxiao.me/tags/Self-supervised-Learning/"}]},{"title":"Model Selection and Evaluation: Machine Learning Basics","slug":"Model-Selection-and-Evaluation-Machine-Learning-Basics","date":"2020-09-09T03:33:25.000Z","updated":"2021-02-19T10:21:57.175Z","comments":true,"path":"2020/09/09/Model-Selection-and-Evaluation-Machine-Learning-Basics/","link":"","permalink":"http://qfxiao.me/2020/09/09/Model-Selection-and-Evaluation-Machine-Learning-Basics/","excerpt":"","text":"Overfitting 我们将模型输出与真实值之间的差异称为误差，如对于分类问题，我们可以使用模型分类错误的样本数量占总样本数的比例。模型在训练集（我们收集到的数据）上的误差称作是训练误差 (training error)，而在新样本（这里指的是新的样本而不是测试集，训练集测试集是从我们收集到的数据上人为划分出来的）上的误差称作是泛化误差 (generalization error)。对于机器学习算法，我们希望算法能学到数据背后的普遍规律，所以我们总是希望模型的泛化误差越小越好。 不过测试集对训练过程来说是未知的，所以模型只能尽量从训练集中发掘数据的普遍规律，要是模型把训练集学得”太好“了，很可能把训练集中不属于普遍规律的部分特点作为了一般性质，这就会导致泛化性能下降，我们称这种情况为过拟合 (overfitting)。反之，模型对训练集的特性学得不够，就会出现欠拟合 (underfitting)。关于过拟合和欠拟合，周志华老师的《机器学习》中有一张很好的图： 一般来说，欠拟合比较容易克服，可以通过增加模型的复杂度来实现。而过拟合则比较难解决，一般而言可以通过增加数据量、加正则化约束来改善。 Model Selection 对于一个机器学习任务，一般我们有多种模型供我们选择，并且模型也有不同的超参数，我们希望得到泛化性能尽可能高的模型。不过根据前面的讨论，新样本是未知的，所以没法直接得到泛化误差，而过拟合的存在使得我们不能贸然的根据模型在我们收集到的数据上的表现来选择模型（训练误差低不代表泛化误差低）。 我们假设无论是我们收集到的数据还是新样本都是从数据的真实分布中独立同分布采样得来，为此我们可以从数据中划分出一部分”测试集“，然后将模型在测试集上的表现作为泛化误差的近似，而剩下的部分用来模型训练。 那么如何划分训练集和测试集呢？比较常见的方法是”\\(k\\)折交叉验证法“ (\\(k\\)-fold cross validation)，一般\\(k\\)常取\\(10\\)，其基本思想如下图所示： \\(k\\)折交叉验证法首先将数据集均匀地划分为\\(k\\)个部分，然后进行\\(k\\)个循环，在每个循环中将第\\(k\\)份作为测试集，其余的作为训练集，最后得到的结果进行平均。 Evaluation Metrics 前面我们讨论了评测的框架，但是没有说具体的评测指标。实际上评测指标要根据任务来确定，并且不同的评测指标也有自己的特点。 Regression 回归任务比较常用的评测标准是均方误差 (Mean Squared Error)： \\[ \\text{MSE}(f;D)=\\frac{1}{m}\\sum_{i=1}^m (f(x_i)-y_i)^2 \\] 和平均绝对误差 (Mean Absolute Error)： \\[ \\text{MAE}(f;D)=\\frac{1}{m}\\sum_{i=1}^m |f(x_i)-y_i| \\] Classification Binary Classification 对于分类任务，最简单的想法是使用模型分类正确的比例来作为评测标准，我们称之为准确率 (Accuracy)： \\[ \\text{ACC}(f;D)=\\frac{1}{m}\\sum_{i=1}^m \\mathbb{I}(f(x_i)=y_i) \\] 但准确率并不能满足我们的所有要求，比如说对于新冠病毒的分类任务，我们可能会更关注于对于所有患有新冠的病人，模型到底查出来了多少，而对于模型误把正常病人当作是患病的情况没有那么关注。对于二分类问题，我们可以将样例根据其真实类别与模型预测的类别划分为真正例 (true positive, TP)、假正例 (false positive, FP)、真反例 (true negative, TN) 和假反例 (false negative, FN) 四种，形成混淆矩阵 (Confusion Matrix)： 下面给一个具体的例子： 比如我们的任务是预测一张手写数字图片是不是\\(5\\)，根据上图，右下角就是我们正确预测的是\\(5\\)的图片，左下角就是本来是\\(5\\)，但被预测成不是\\(5\\)的图片；左上角是本来不是\\(5\\)，我们也正确地预测出其不是\\(5\\)的，右上角是本来不是\\(5\\)却被预测成是\\(5\\)的。是不是有点被绕晕了😀，只要记住T和F代表的是预测结果对还是不对，P和N代表的是模型预测当前样本是正例还是负例。 基于混淆矩阵，我们可以定义查准率 (Precision) 和查全率 (Recall) 这两个评测标准。 查准率，顾名思义，对于检测出来的正例，有多少是真正的正例，即查的准不准，公式为： \\[ \\text{Precision}=\\frac{TP}{TP+FP} \\] 分母就是模型预测为正例的样本总数。 查全率，就对应刚才举的新冠的例子，我们比较在乎对于数据集中的正例，有多少被查出来了，公式为： \\[ \\text{Recall} = \\frac{TP}{TP+FN} \\] 分母就是真实类别为正例的样本总数。一般来说，查准率和查全率是相互矛盾的，除非是特别简单的任务，很难兼顾查准率和查全率。 F1分数 (F1 Score) 综合了查准率和查全率： \\[ \\text{F}1=\\frac{2\\cdot\\text{Precision}\\cdot\\text{Recall}}{\\text{Precision}+\\text{Recall}} \\] 查准率和查全率中任意一项较低都会导致F1分数较低。有时候我们对待查准率和查全率的权重不同，这时候可以使用F\\(_\\beta\\)分数： \\[ \\text{F}_\\beta=\\frac{(1+\\beta^2)\\cdot \\text{Precision}\\cdot\\text{Recall}}{(\\beta^2\\cdot\\text{Precision})+\\text{Recall}} \\] \\(\\beta=1\\)时等价于F1分数，\\(\\beta&gt;1\\)代表偏重查全率，\\(\\beta&lt;1\\)代表偏重查准率。 Multi-classification 前面的讨论都是基于二分类任务，如果是多分类任务的话， 对于每一类，我们将该类作为正例，其他类别作为负例，都能得到一个混淆矩阵。如果我们在每个混淆矩阵上计算评测指标，然后进行平均，这样就得到宏查准率 (macro-Precision)、宏查全率 (macro-Recall) 和宏F1分数 (macro-F1)。如果我们事先将混淆矩阵的TP、FP、TN、FN先进行平均，再计算评测指标，就得到了微查准率 (micro-Precision)、微查全率 (micro-Recall) 和微F1分数 (micro-F1)。 PR-Curve 很多情况下模型的输出是样本为正例的“概率值”或者是分数，分数越高的样本代表越可能是正例。这种时候需要人为划定阈值，规定高于阈值的样本是正例。不过阈值的划分相当于超参数的选取，同时我们会认为一个鲁棒的模型的性能应该不受阈值选取的左右。这个时候我们可以使用PR曲线 (Precision-Recall Curve)，即遍历所有可能的阈值，对于每个阈值，计算其对应的Precision和Recall，然后画在图上，最后会得到一系列离散的点（理论上应该是连续曲线，不过阈值是连续值，我们只能取离散值），形成PR-曲线。 模型性能越好，曲线就会越接近右上角的点，我们可以把PR曲线的曲线下面积 (PR-AUC) 作为评测标准。 ROC-Curve ROC全称是受试者工作特征 (Receiver Operating Characteristic) 曲线, 和PR曲线类似，ROC曲线也是遍历不同的阈值计算点，不过ROC曲线计算的是真正例率 (True Positive Rate, TPR) 和假正例率 (False Positive Rate, FPR)，两者定义分别是： \\[ \\begin{align} \\text{TPR}=\\frac{TP}{TP+FN}\\\\ \\text{FPR}=\\frac{FP}{TN+FP} \\end{align} \\] 其中TPR就是查全率，而FPR是所有负例中没有检测出来的比例，这一项是越低越好。 模型性能越好，曲线就会越接近左上角的点，我们可以把ROC曲线的曲线下面积 (ROC-AUC) 作为评测标准。 下面来总结一下PR曲线和ROC曲线之间的优缺点。 纵轴 横轴 PR \\(\\text{Precision}=\\frac{TP}{TP+FP}\\) \\(\\text{Recall} = \\frac{TP}{TP+FN}\\) ROC \\(\\text{TPR}=\\frac{TP}{TP+FN}\\) \\(\\text{FPR}=\\frac{FP}{TN+FP}\\) ROC的优点： 相比PR仅关注正例，ROC同时关注正例和负例 相比PR不易受到正负例相对数量的影响，ROC的两个指标的计算都只涉及到P、N中的一列，正例或负例增加对总体影响不大。而PR曲线就不一样，两个指标的计算都涉及到了P、N两列，那么正例或负例样本数量的变化会造成较大影响。如负例突然增大，那么FP也会增大，这样Precision会降低，而Recall却不变。 ROC的缺点： 对于类别不平衡问题，存在大量负例，这样会带来大量的FP，而ROC的FPR却不会因为FP的大幅增长而剧烈改变，结果是这一类错误很难在ROC曲线中体现出来。所以ROC会呈现出一个过于乐观的评价。 我们来尝试下是否如此，下面是用随机森林分类器，测试样本正负例数量比为1:1的情况下的ROC曲线和PR曲线： 在我们将正负例数量比调整为1:9之后（总数量相同），可以看到ROC曲线比较稳定，没出现较大变化，而PR曲线则出现了剧烈变化： Bias and Variance 在机器学习中，偏差-方差分解是解释学习算法泛化性能的重要工具。假设我们要预测某一个地区的房子的房价，每一套房子都是一个样本，我们认为每个样本都是从总体分布\\(P(X)\\)独立同分布采样得来的。不过我们不可能得到所有的样本，我们采样得到的训练集只是其中一个子集。那么，即使对于同样的测试样本，使用不同的训练集（训练集大小相同）训练出来的模型对测试样本的预测也是不一样的，我们将这一部分模型自身的不稳定性用方差 (Variance) 来描述：\\(\\text{Var}(X)=E_D\\left[(\\hat f(X)-E[\\hat f(X)])^2\\right]\\)，方差越小代表模型稳定性越强。模型输出的期望与真实值之间的差距我们用偏差 (Bias) 来描述：\\(\\text{Bias}(X)=E[\\hat f(X)]-f(X)\\)。 泛化误差与方差、偏差有下列关系： \\[ \\begin{align} \\text{Err}(X)&amp;=E\\left[(y-\\hat f(X))^2\\right]\\\\ &amp;=E\\left[(f(X)+\\varepsilon-\\hat f(X))^2\\right]\\\\ &amp;= (E[\\hat f(X)]-f(X))^2 + E\\left[(\\hat f(X)-E[\\hat f(X)])^2\\right]+\\sigma_{\\varepsilon}^2\\\\ &amp;=\\text{Bias}^2 + \\text{Variance} + \\text{Random Error} \\end{align} \\] 也就是说泛化误差可以分解为方差、偏差和随机噪声之和。偏差刻画了模型的期望预测与真实值之间的偏离程度，方差刻画了不同训练集对模型性能的影响，他们之间的关系如下图所示： 图中左上角的部分是比较理想的情况，即方差和偏差都较小。但实际上方差和偏差往往是相互冲突的，如下图所示： 模型复杂度不足的时候，模型的拟合能力不够强，偏差主导了泛化误差，而随着模型复杂度的提高，模型的拟合能力逐渐提高，训练数据的扰动会造成模型发生显著变化，这时方差逐渐主导了泛化误差。","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Machine Learning","slug":"Technical-Notes/Machine-Learning","permalink":"http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"}],"tags":[{"name":"Overfitting","slug":"Overfitting","permalink":"http://qfxiao.me/tags/Overfitting/"},{"name":"Bias","slug":"Bias","permalink":"http://qfxiao.me/tags/Bias/"},{"name":"Variance","slug":"Variance","permalink":"http://qfxiao.me/tags/Variance/"}]},{"title":"Machine Learning Classification Algorithms: Decision Trees","slug":"Machine-Learning-Classification-Algorithms-Decision-Trees","date":"2020-09-02T10:47:55.000Z","updated":"2021-02-19T10:22:31.857Z","comments":true,"path":"2020/09/02/Machine-Learning-Classification-Algorithms-Decision-Trees/","link":"","permalink":"http://qfxiao.me/2020/09/02/Machine-Learning-Classification-Algorithms-Decision-Trees/","excerpt":"","text":"Introduction （PS：本文内容是学习高级树模型（GBDT，XGBoost）的基础，强烈建议在看那些内容之前先了解本文的内容！） 本文主要是介绍常用的三种决策树模型：ID3、C4.5和CART。决策树（Decision Tree）是一种有监督分类模型（稍加改造可进行回归任务）。 比如我们要判断一个瓜是不是好瓜，对于人来说，要判断一个瓜是不是好瓜，可能会先去看看色泽，然后看看根蒂，然后再敲一敲听听声音，这样经过一系列的决策过程。 决策树正是模拟了这样的过程。给定数据集，决策树会不断地选择最佳的特征将数据集进行切分（如选择色泽，然后将数据分为青绿、乌黑、浅白这几个子集），然后递归地进行下去，直到达到停止条件： 每个叶子节点的样本都属于同一个类别 没有可供划分的特征，或者集合中每个样本所有特征取值都相同 决策树达到预先指定的最大深度 所以决策树算法要解决的关键问题就是如何去选择当前最好的划分特征。 ID3 ID3算法根据信息熵来进行特征的划分。信息熵是衡量一个随机变量信息量的度量，如果把数据集的标签\\(y\\)看作是随机变量，那么\\(y\\)的熵越小代表不确定性越小（集合里几乎都是一种类别的样本），熵越大代表不确定性越大（集合包含不同类别的样本），其公式为： \\[ Ent(D)=-\\sum_{k=1}^{|\\mathcal Y|}p_k\\log p_k \\] \\(Ent(D)\\)代表集合\\(D\\)对应的熵，\\(|\\mathcal Y|\\)是类别数量，二分类就是\\(|\\mathcal Y|=2\\)，\\(p_k\\)为第\\(k\\)个类别对应的概率（频率）。很自然的，我们可以根据划分前后熵的变化来确定划分特征的选择，如果划分之后熵减小的最多，那么这个特征也是最好的。假设我们选定特征\\(a\\)来对集合进行划分，特征\\(a\\)共有\\(V\\)个离散取值，那么划分之后将会产生\\(V\\)个子集，我们记每个子集为\\(D^v, v=1,\\cdots, V\\)。那么，信息增益可以写为： \\[ Gain(D,a)=Ent(D)-\\sum_{v=1}^V \\frac{|D^v|}{|D|}Ent(D^v) \\] 不过，ID3存在两个致命的缺点： 无法对连续取值的特征进行计算 对取值较多的特征具有很大的偏向性（极端的情况，把样本编号作为特征，由于每个样本的编号都不同，分裂之后每个自己只有一个样本/类别，熵是最小的） C4.5 C4.5算法在ID3的基础上做了诸多改进。C4.5解决了ID3对于取值数目较多的特征的偏向性问题，其采用的方案很直观，即对信息增益除以一个系数，特征取值数目越多的特征系数越大，该划分标准被称作是信息增益率： \\[ Gain\\_ratio(D,a)=\\frac{Gain(D,a)}{IV(a)} \\] 其中\\(IV(a)=-\\sum_{v=1}^V\\frac{|D^v|}{|D|}\\log \\frac{|D^v|}{|D|}\\)。其实\\(IV(a)\\)可以看作是“划分之后每个样本属于集合\\(v\\)的概率”这个随机变量的熵，划分的子集越多，划分之后属于哪个集合就越不确定，所以熵就越大。 不过信息增益率反而会对特征取值数目少的特征有所偏好，所以C4.5算法是先计算信息增益，确定信息增益高于平均值的候选集，再从中选择信息增益率最高的特征。 除此之外，C4.5还能处理连续取值的特征，其做法是“离散化”，即将连续取值划分为若干个离散的区间，一般二分比较常用。设连续特征\\(a\\)，假设其出现了\\(n\\)个取值，将其排序得到\\(\\{a^1,a^2,\\cdots,a^n\\}\\)，我们考虑每两个相邻节点的中点集合\\(T_a=\\{\\frac{a^i+a^{i+1}}{2}|1\\leq i \\leq n-1\\}\\)，之后我们就可以像考察离散属性值一样选择最优划分。 下图是在breast cancer数据上决策树的可视化（图片太大了，可以点开放大🔍看）： CART CART (Classification and Regression Trees) 是一种应用广泛的决策树模型，既可应用于分类任务也可应用于回归任务。 CART Regression 我们先来说说CART怎么进行回归。在回归问题中，CART使用了MSE作为划分准则： \\[ \\frac{1}{N}\\sum_{i=1}^N (f(x_i)-y_i)^2 \\] 如果CART有\\(M\\)片叶子，那么相当于CART将输入划分成了\\(M\\)个单元\\(R_m, m=1,\\cdots,M\\)，也即有\\(M\\)个输出，那么该CART在数据集上的MSE为： \\[ \\frac{1}{N}\\sum_{m=1}^M\\sum_{x_i\\in R_m} (c_m-y_i)^2 \\] 这里\\(c_j\\)为叶子节点\\(j\\)的输出，一般选为对应样本的均值\\(c_m=\\text{avg}(y_i|x_i\\in R_m)\\)。这样，剩下的问题就是如何确定每次的切分特征和切分点了。假设选择的特征是\\(j\\)，切分点\\(s\\)，那么该划分方案对应的损失为： \\[ \\min_{c_1}\\sum_{x_i\\in R_1\\{j,s\\}}(y_i-c_1)^2+\\min_{c_2}\\sum_{x_i\\in R_2\\{j,s\\}}(y_i-c_2)^2 \\] 遍历所有的\\(j\\)和\\(s\\)，我们就能找到最佳的特征和切分点： \\[ \\min_{j,s}\\left[\\min_{c_1}\\sum_{x_i\\in R_1\\{j,s\\}}(y_i-c_1)^2+\\min_{c_2}\\sum_{x_i\\in R_2\\{j,s\\}}(y_i-c_2)^2\\right] \\] 算法流程大致如下： CART Decision Tree Algorithm INPUT: 数据集 \\(D=\\{(x_1,y_1),\\cdots,(x_N,y_N)\\}\\) OUTPUT: 预测值\\(\\{\\hat y_1,\\cdots,\\hat y_N\\}\\) PROCEDURE: 1. 选取当前最优切分特征变量\\(j^*\\)与最优切分点\\(s^*\\) 设当前选择的切分变量为\\(j\\)，切分点为\\(s\\)那么可以根据切分点将数据集分为两个子集，一个是\\(R_1(j,s)=\\left\\{x|x^{(j)}\\leq s\\right\\}\\)，另一个是\\(R_2(j,s)=\\left\\{x|x^{(j)}&gt; s\\right\\}\\)。 遍历所有的\\(j\\)，求解 \\[ \\min_{j,s}\\left[\\min_{c_1}\\sum\\limits_{x_i\\in R_1(j,s)}(y_i-c_1)^2+\\min\\limits_{c_2}\\sum\\limits_{x_i\\in R_2(j,s)}(y_i-c_2)^2\\right] \\] 注意\\(\\hat c_1=\\frac{1}{N_1}\\sum\\limits_{x_i\\in R_1(j,s)}y_i\\) 2. 用选定的\\((j^*,s^*)\\)来划分区域并计算输出值 此时，我们还需要确定这两个区域（划分到同一个区域的样本对应的输出是相同的）的输出值\\(c_1\\)和\\(c_2\\)，其确定方式是使得对应区域上的均方误差最小。这样我们相当于得到了给定\\(j,s\\)下的损失，所以只要找出使得损失最小的\\(j^*,s^*\\)即可： 3. 递归地对划分出来的两个区域重复步骤1和步骤2，直到满足停止条件 4. 最后将输入空间划分为\\(M\\)，输出\\(f(x)=\\sum_{m=1}^M \\hat c_m I(x\\in R_m)\\) 下图是在波士顿房价数据上决策树的可视化（图片太大了，可以点开放大🔍看）： CART Classification 从前面的讨论可以看到，CART回归树是一棵二叉树，对于分类任务，CART也是一棵二叉树。我们先来介绍CART的划分准则，再来介绍它是怎么进行划分的。 采用基尼系数作为准则，基尼系数的计算依赖于基尼值： \\[ \\begin{align} Gini(D)&amp;=1-\\sum_{k=1}^{|\\mathcal Y|}p_k^2 \\end{align} \\] 直观上来说，基尼值表示随机抽取两个样本，其类别不一致的概率 如果说一个特征越好，那么划分之后其每个子集对应的基尼值应该越小越好。基尼系数的定义为： \\[ Gini\\_index(D,a)=\\sum_{v=1}^V \\frac{|D^v|}{|D|}Gini(D^v) \\] 对于离散取值特征，CART不会根据不同取值个数进行划分，而是和连续值类似，会确定一个“划分点”，将样本进行二分。比如对于特征\\(a\\)，其对应取值为\\(\\{a^1,a^2,\\cdots,a^n\\}\\)，CART会考察每个取值，将样本集划分为特征\\(a\\)是不是等于\\(a^i\\)两部分，然后计算基尼系数，最终会采用基尼系数最小的取值作为划分点。 下图是在breast cancer数据上决策树的可视化（图片太大了，可以点开放大🔍看）：","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Machine Learning","slug":"Technical-Notes/Machine-Learning","permalink":"http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"}],"tags":[{"name":"ID3","slug":"ID3","permalink":"http://qfxiao.me/tags/ID3/"},{"name":"C4.5","slug":"C4-5","permalink":"http://qfxiao.me/tags/C4-5/"},{"name":"CART","slug":"CART","permalink":"http://qfxiao.me/tags/CART/"}]},{"title":"Machine Learning Classification Algorithms: Support Vector Machine","slug":"Machine-Learning-Classification-Algorithms-Support-Vector-Machine","date":"2020-08-25T18:09:24.000Z","updated":"2021-02-19T10:23:31.925Z","comments":true,"path":"2020/08/26/Machine-Learning-Classification-Algorithms-Support-Vector-Machine/","link":"","permalink":"http://qfxiao.me/2020/08/26/Machine-Learning-Classification-Algorithms-Support-Vector-Machine/","excerpt":"","text":"Introduction Still working on it😅... blog Hyperplane 超平面可以从代数和几何两方面来理解。超平面的代数定义可以看作是方程： \\[ a_1x_1+\\cdots+a_nx_n=d \\] 的所有解形成的集合，其中\\(a_1,\\cdots,a_n\\)为不全为\\(0\\)的实数，\\(d\\)也是实数。 从几何上来说，超平面可以看作是除空间\\(R^n\\)自身外维度最大的仿射空间。 Maximum Margin Classifier 要谈SVM就得先谈线性分类器，其设置是这样的。对于\\(D\\)维空间，我们有一堆数据\\(X\\)，进行二分类任务，标签记为\\(y\\)，其中\\(y=-1\\)和\\(y=1\\)分别代表不同的类别。我们的任务就是找到一个超平面，将正负例切分开来（先假设数据是线性可分的），这个超平面的方程可以表示为： \\[ w^\\top x+b=0 \\] 我们令\\(f(x)=w^\\top x+b\\)，对于\\(f(x)&lt;0\\)的样本，我们赋予其类别\\(-1\\)，对于\\(f(x)&gt;0\\)的样本，我们可以赋予其类别\\(1\\)。对于相同的分类结果，我们可以找出无限种超平面。不过，对于那些样本特别靠近超平面的情况，鲁棒性并不好。为什么呢？因为这时只要超平面有轻微的变化，样本的分类结果就会发生变化。直观上来说，我们希望样本到超平面的距离越大越好。 我们先定义函数间隔的概念，函数间隔\\(\\hat \\gamma=y(w^\\top x+b)\\)，乘以\\(y\\)的目的主要是保持非负性，表示起来方便。可见函数间隔的大小并不能表示样本距离，因为同一个超平面，法向量\\(w\\)可以任意增大，函数间隔也会相应增大。 下面来推导点\\(x\\)到超平面的距离。设\\(x\\)在超平面上的投影为\\(x_0\\)，到超平面的距离为\\(\\gamma\\)，\\(w\\)为法向量，那么有： \\[ x=x_0+\\gamma\\frac{w}{\\parallel w\\parallel} \\] 将上式带入到超平面方程可以得到 \\[ \\gamma=\\frac{w^\\top}{\\parallel w\\parallel}x+\\frac{b}{\\parallel w\\parallel} \\] 我们称\\(\\gamma\\)为几何间隔。 可以很容易看出函数间隔和几何间隔的关系： \\[ \\gamma = \\frac{\\hat \\gamma}{\\parallel w\\parallel} \\] 前面提到我们希望几何间隔越大越好，于是可以直接最大化\\(\\gamma\\)，得到： \\[ \\begin{align} \\max \\space &amp;\\gamma\\\\ s.t. \\space &amp; y_i(w^\\top x_i+b)=\\hat\\gamma_i\\geq\\hat\\gamma, \\space i=1,\\cdots,n \\end{align} \\] 这里\\(\\hat \\gamma=\\gamma \\parallel w\\parallel\\)，根据前面的分析我们知道，对于同一个超平面，函数间隔\\(\\hat\\gamma\\)可以随着\\(\\parallel w\\parallel\\)的变化而变化，所以为了找到最优的\\(\\gamma\\)，我们可以考虑固定\\(\\parallel w\\parallel\\)或者\\(\\hat\\gamma\\)，这里我们固定\\(\\hat \\gamma=1\\)，所以有： \\[ \\begin{align} \\max &amp; \\space \\frac{1}{\\parallel w\\parallel},\\\\ s.t. \\space&amp; y_i(w^\\top x_i+b)\\geq 1, \\space i=1,\\cdots,n \\end{align} \\] 下面的约束条件代表前提是所有样本分类正确，而\\(\\max\\frac{1}{\\parallel w\\parallel}\\)代表最大化间隔。为了方便，我们将其化为等价的最小化形式： \\[ \\begin{align} \\min &amp; \\space \\frac{1}{2}\\parallel w\\parallel^2,\\\\ s.t. &amp; y_i(w^\\top x_i+b)\\geq 1, \\space i=1,\\cdots,n \\end{align} \\] 其中那些\\(y_i(w^\\top x_i+b)=1\\)的样本就是“支持向量”。这个优化问题是典型的二次凸优化问题，可以调用现成的算法去解决。不过我们可以使用拉格朗日乘子法来更高效的解决。 Dual Problem 拉格朗日乘子法可以将有\\(d\\)个变量和\\(k\\)个约束条件的最优化问题转化成有\\(d+k\\)个变量的无约束最优化问题求解。 Lagrange Multiplier 对于以下有约束优化问题： \\[ \\begin{align} \\min_x \\space &amp; f(x)\\\\ \\text{s.t.} \\space &amp; h_i(x)=0 \\space (i=1,\\cdots,m),\\\\ &amp;g_j(x) \\leq 0 \\space (j=1,\\cdots,n) \\end{align} \\] 引入拉格朗日乘子\\(\\boldsymbol\\lambda = (\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)^\\top\\)和\\(\\boldsymbol\\mu=(\\mu_1,\\mu_2,\\cdots,\\mu_m)^\\top\\)，相应的广义拉格朗日函数 (generalized Lagrange function) 为： \\[ L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu)=f(\\boldsymbol x)+\\sum_{j=1}^n \\lambda_j g_j(\\boldsymbol x)+\\sum_{i=1}^m \\mu_i h_i(\\boldsymbol x) \\] 其中\\(\\lambda_j\\)，\\(\\mu_i\\)被称作是拉格朗日乘子，\\(\\lambda_j \\geq 0\\)。 Primal Problem 现在我们来讨论原问题的等价性。假设给定某个\\(x\\)，如果\\(x\\)违反约束条件，即存在某个\\(x\\)使得\\(h_i(x)\\neq 0\\)或者\\(g_j(x)&gt;0\\)，那么就有： \\[ \\max\\limits_{\\boldsymbol\\lambda,\\boldsymbol\\mu:\\lambda_j\\geq 0} L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu)=+\\infty \\] 如果存在某个\\(x\\)使得\\(h_i(x)\\neq 0\\)，那么可以令\\(\\lambda_j \\rightarrow +\\infty\\)，如果存在\\(g_j(x)&gt;0\\)，那么可令\\(\\mu_ih_i(x)\\rightarrow +\\infty\\)。 如果考虑以下极小化问题： \\[ p^*=\\min_x\\max\\limits_{\\boldsymbol\\lambda,\\boldsymbol\\mu:\\lambda_j\\geq 0} L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu) \\] 他与原始带约束最优化问题是等价的（因为不符合约束时会有\\(+\\infty\\)，而我们考虑的是极小化问题），我们将其记为原问题 (Primal problem)。 Dual Problem 如果先考虑最小化\\(x\\)，再考虑最大化\\(\\boldsymbol\\lambda\\)和\\(\\boldsymbol\\mu\\)，这时有： \\[ \\max\\limits_{\\boldsymbol\\lambda,\\boldsymbol\\mu:\\lambda_j\\geq 0}\\min_x L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu) \\] 对偶问题 (Dual problem) \\[ d^*=\\max\\limits_{\\boldsymbol\\lambda,\\boldsymbol\\mu:\\lambda_j\\geq 0}\\min_x L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu) \\] 原问题和对偶问题的关系 \\[ d^*=\\max\\limits_{\\boldsymbol\\lambda,\\boldsymbol\\mu:\\lambda_j\\geq 0}\\min_x L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu) \\leq \\min_x\\max\\limits_{\\boldsymbol\\lambda,\\boldsymbol\\mu:\\lambda_j\\geq 0} L(\\boldsymbol x,\\boldsymbol\\lambda,\\boldsymbol\\mu) = p^* \\] KKT Condition 对于原问题和对偶问题，设\\(f(x)\\)和\\(g_i(x)\\)为凸函数，\\(h_i(x)\\)为仿射函数，并且不等式约束\\(c_i(x)\\)是严格可行的，则\\(x^*\\)，\\(\\lambda^*\\)，\\(\\mu^*\\)分别是原问题和对偶问题的解的充分必要条件是满足下面的Karush-Kuhn-Tucker (KKT) 条件： \\[ \\begin{cases} \\nabla_x L(x^*,\\lambda^*,\\mu^*)=0 &amp;\\\\ \\lambda^*_j g_j(x^*)=0 &amp; j=1,\\cdots n\\\\ g_j(x^*)\\leq 0 &amp; j=1,\\cdots n\\\\ \\lambda_j^*\\geq 0 &amp; j=1,\\cdots n\\\\ h_i(x^*) = 0 &amp; i = 1, \\cdots m \\end{cases} \\] 这告诉我们 Dual Form of SVM Optimization 支持向量机优化的对偶问题可以写为： \\[ L(w,b,\\alpha)=\\frac{1}{2}\\parallel w\\parallel^2-\\sum_{i=1}^n \\alpha_i(y_i(w^\\top x_i+b)-1) \\] 我们先令： \\[ \\begin{align} \\frac{\\partial L}{\\partial w}=0&amp;\\Rightarrow w=\\sum_{i=1}^n\\alpha_i y_i x_i\\\\ \\frac{\\partial L}{\\partial b}=0&amp;\\Rightarrow \\sum_{i=1}^n\\alpha_i y_i =0 \\end{align} \\] 带回到\\(L\\)得到： \\[ \\begin{align} L(w,b,\\alpha)&amp;=\\frac{1}{2}\\sum_{i,j=1}^n\\alpha_i\\alpha_j y_i y_j x^\\top_i x_j-\\sum_{i,j=1}^n \\alpha_i\\alpha_jy_iy_jx^\\top_ix_j-b\\sum_{i=1}^n\\alpha_iy_i+\\sum_{i=1}^n\\alpha_i\\\\ &amp;=\\sum_{i=1}^n \\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^n \\alpha_i\\alpha_j y_i y_j x^\\top_i x_j \\end{align} \\] 于是得到关于\\(\\alpha\\)的对偶优化问题： \\[ \\begin{align} \\max_\\alpha &amp;\\sum_{i=1}^n \\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^n \\alpha_i\\alpha_j y_i y_j x^\\top_i x_j\\\\ \\text{s.t. }&amp; \\alpha_i\\geq 0, i=1,\\cdots,n\\\\ &amp; \\sum_{i=1}^n \\alpha_i y_i = 0 \\end{align} \\] 前面有提到我们根据\\(f(x)=w^\\top x + b\\)的输出来判定样本类别，而刚才得到\\(w=\\sum_{i=1}^n\\alpha_i y_i x_i\\)，于是： \\[ \\begin{align} f(x) &amp;= (\\sum_{i=1}^n \\alpha_iy_ix_i)^\\top x+b\\\\ &amp;= \\sum_{i=1}^n \\alpha_i y_i \\langle x_i, x\\rangle + b \\end{align} \\] 最后的\\(\\sum_{i=1}^n \\alpha_i y_i \\langle x_i, x\\rangle + b\\)值得特别注意，这意味着我们对于测试样本\\(x\\)的预测，只需要计算它与训练集的内积即可，同时由于所有非支持向量对应的\\(\\alpha\\)都是\\(0\\)，我们只需要求一小部分内积。同时这个内积计算也是后面核方法应用的前提。 Kernel 到目前为止，我们的讨论都是在数据是线性可分的前提下进行讨论的，那么对于线性不可分的情况呢？答案是使用核方法。 核方法的思想是，对于原始不可分的数据，我们假设原始数据通过一个映射\\(\\phi(\\cdot)\\)就变得线性可分了。核方法相当于对数据找到了一种新的表示，如上图没法用一个超平面直接分割，但通过\\(\\phi(\\cdot)\\)映射之后就变得可分了。原始的分类函数为： \\[ f(x)= \\sum_{i=1}^n \\alpha_i y_i \\langle x_i, x\\rangle + b \\] 加上映射之后变为： \\[ f(x)= \\sum_{i=1}^n \\alpha_i y_i \\langle \\phi(x_i), \\phi(x)\\rangle + b \\] 优化问题也变为： \\[ \\begin{align} \\max_\\alpha &amp;\\sum_{i=1}^n \\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^n \\alpha_i\\alpha_j y_i y_j \\langle\\phi(x_i), \\phi(x_j)\\rangle\\\\ \\text{s.t. }&amp; \\alpha_i\\geq 0, i=1,\\cdots,n\\\\ &amp; \\sum_{i=1}^n \\alpha_i y_i = 0 \\end{align} \\] 我们把计算两个向量在映射后的空间中的内积的函数叫做核函数 \\[ f(x)= \\sum_{i=1}^n \\alpha_i y_i k(x_i, x) + b \\] 优化问题改为： \\[ \\begin{align} \\max_\\alpha &amp;\\sum_{i=1}^n \\alpha_i - \\frac{1}{2}\\sum_{i,j=1}^n \\alpha_i\\alpha_j y_i y_j k(\\phi(x_i), \\phi(x_j))\\\\ \\text{s.t. }&amp; \\alpha_i\\geq 0, i=1,\\cdots,n\\\\ &amp; \\sum_{i=1}^n \\alpha_i y_i = 0 \\end{align} \\] 实际上，通过核函数，我们隐式地定义了一个映射\\(\\phi(\\cdot)\\) 常用核函数 名称 表达式 参数 线性核 多项式核 RBF核 拉普拉斯核 Sigmoid核 Soft Margin 数据线性不可分的情况，除了数据本身结构非线性的原因之外（核方法），还有可能是因为噪声或者离群点。为了处理这种情况，我们可以允许一部分点在一定程度上偏离超平面，具体来说就是原来的约束条件\\(y_i(w^\\top x_i+b)\\geq 1, \\space i=1,\\cdots,n\\)变成了： \\[ y_i(w^\\top x_i+b)\\geq 1-\\xi_i, \\space i=1,\\cdots,n \\] 其中\\(\\xi_i\\geq 0\\)称作是松弛变量，代表样本\\(i\\)允许的偏离程度。当然松弛变量不可能无限大，所以我们需要将\\(\\xi_i\\)加入到优化目标函数中使其尽量小，于是有： \\[ \\begin{align} \\min &amp; \\space \\frac{1}{2}\\parallel w\\parallel^2+C\\sum_{i=1}^n \\xi_i,\\\\ s.t. &amp; y_i(w^\\top x_i+b)\\geq 1-\\xi_i, \\space i=1,\\cdots,n \\end{align} \\] 其中\\(C\\)为控制最优化\\(\\parallel w\\parallel\\)和松弛变量这两项的权重。这里的优化函数还是对偶问题之前的形式，我们马上会讨论对偶问题。 Numerical Optimization 这里讨论SVM高效求解的Sequential Minimal Optimization (SMO)算法。 坐标下降法是一种非梯度优化算法，","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Machine Learning","slug":"Technical-Notes/Machine-Learning","permalink":"http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://qfxiao.me/tags/SVM/"}]},{"title":"Machine Learning Ensemble Algorithms: GBDT and XGBoost","slug":"Machine-Learning-Ensemble-Algorithms-GBDT-and-XGBoost","date":"2020-08-25T16:28:26.000Z","updated":"2021-02-28T05:38:18.079Z","comments":true,"path":"2020/08/26/Machine-Learning-Ensemble-Algorithms-GBDT-and-XGBoost/","link":"","permalink":"http://qfxiao.me/2020/08/26/Machine-Learning-Ensemble-Algorithms-GBDT-and-XGBoost/","excerpt":"","text":"Introduction 本文主要介绍GBDT和XGBoost，在学习本文内容之前建议先学习决策树相关内容。 下面是一些有用的参考链接： XGBoost Documentation AdaBoost blog GBDT blog slide 陈天奇slide blog blog Preliminaries 实际上，GBDT和梯度下降、XGBoost和牛顿法之间是存在密切关系的，这里我们先回顾一下梯度下降算法和牛顿法的基础知识。 Taylor Formulation 函数\\(f(x)\\)在点\\(x_0\\)处的泰勒展开为： \\[ f(x)=\\sum_{n=0}^\\infty\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\] 特别的，一阶展开为： \\[ f(x)\\approx f(x_0)+f^\\prime(x_0)(x-x_0) \\] 二阶展开为： \\[ f(x)\\approx f(x_0)+f^\\prime(x_0)(x-x_0) + f^{\\prime\\prime}(x_0)\\frac{(x-x_0)^2}{2} \\] 迭代形式：假设\\(x^t=x^{t-1}+\\Delta x\\)，将\\(f(x)\\)在\\(x^{t-1}\\)处进行泰勒展开 \\[ \\begin{align} f(x^t) &amp;= f(x^{t-1}+\\Delta x)\\\\ &amp;\\approx f(x^{t-1})+f^\\prime(x^{t-1})\\Delta x + f^{\\prime\\prime}(x^{t-1})\\frac{\\Delta x^2}{2} \\end{align} \\] Gradient Descend Method 设参数\\(\\theta\\)，那么参数对应的损失函数为\\(L(\\theta)\\)， 设当前步数为\\(t\\)，那么\\(t-1\\)步时的参数为\\(\\theta^{t-1}\\)，将\\(L(\\theta^t)\\)在\\(\\theta^{t-1}\\)处展开得到： \\[ L(\\theta^t) \\approx L(\\theta^{t-1})+ L^\\prime(\\theta^{t-1})\\Delta\\theta \\] 我们想求的\\(\\theta^t=\\theta^{t-1}+\\Delta \\theta\\) Newton's Method 将\\(L(\\theta^t)\\)在\\(\\theta^{t-1}\\)处进行二阶泰勒展开 \\[ \\begin{align} L(\\theta^t) &amp;= L(\\theta^{t-1}+\\Delta \\theta)\\\\ &amp;\\approx L(\\theta^{t-1})+L^\\prime(\\theta^{t-1})\\Delta \\theta + L^{\\prime\\prime}(\\theta^{t-1})\\frac{\\Delta \\theta^2}{2} \\end{align} \\] 记一阶导数和二阶导数分别为\\(g\\)和\\(H\\)，那么 \\[ L(\\theta^t)=L(\\theta^{t-1})+g\\Delta \\theta + H\\frac{\\Delta \\theta^2}{2} \\] 要使得迭代后的结果尽量小，即\\(g\\Delta \\theta + H\\frac{\\Delta \\theta^2}{2}\\)尽量小，那么有\\(\\frac{\\left(g\\Delta \\theta + H\\frac{\\Delta \\theta^2}{2}\\right)}{\\partial\\Delta\\theta}=0\\) 求得\\(\\Delta \\theta=H^{-1}g\\)，故\\(\\theta^{t}=\\theta^{t-1}+\\Delta \\theta=\\theta^{t-1}-\\frac{g}{h}\\)。如果\\(\\theta\\)是一个向量，那么\\(\\theta^{t}=\\theta^{t-1}-H^{-1}g\\)，这里\\(H\\)为海森矩阵。 Gradient Boosting Decision Tree (GBDT) 我们首先来看基于树的Boosting模型中，非常经典的梯度提升树 (Gradient Boosting Decision Tree)。 The Additive Model 首先GBDT是一个加法模型，即最终模型由一系列树模型乘以对应权重相加得来： \\[ F_T(x;w)=\\sum_{t=0}^T\\alpha_t h_t(x;w_t)=\\sum_{t=0}^T f_t(x;w_t) \\] 我们的目标是使得\\(F\\)的损失函数最小化： \\[ F_T^*=\\mathop{\\arg\\min}\\limits_{F}\\sum_{i=1}^N L(y_i, F_T(x_i;w)) \\] 直接优化这个损失函数复杂度是很高的，GBDT实际上运用了一种类似贪心的策略来优化这个函数，将优化过程分解成了迭代的步骤。 回想梯度下降算法进行优化的步骤，我们有参数\\(\\theta\\)，损失函数\\(L(\\theta)\\)是\\(\\theta\\)的函数，我们希望找到最优的\\(\\theta^*\\)使得\\(L(\\theta^*)\\)最小，于是我们使用了迭代优化的步骤。假设迭代执行到第\\(t\\)步，也就是说我们现在的参数\\(\\theta^{t-1}\\)为前面\\(t-1\\)步增量之和：\\(\\theta^{t-1}=\\sum_{j=1}^{t-1}\\Delta \\theta_j\\)，每一步的增量记为\\(\\Delta \\theta_t\\)。当前的增量\\(\\Delta \\theta_{t}\\)是怎么计算得到的呢？大家都知道是采用的损失函数在\\(\\theta^{t-1}\\)的负梯度乘以一个步长，即\\(\\Delta \\theta_t=-\\alpha_t \\frac{\\partial L(\\theta)}{\\partial \\theta^{t-1}}\\)。 梯度下降相当于是在参数空间\\(\\theta\\)找到最合适的参数\\(\\theta^*\\)使得损失函数\\(L(\\theta)\\)最小化，如果我们把模型\\(F_T\\)看作是函数空间，我们的目的是在函数空间中找到最优的\\(F_T^*\\)使得损失函数最小化，在这一个角度上GBDT和梯度下降就统一起来了。每一步的基模型\\(f_t\\)就相当于梯度下降中的增量\\(\\Delta \\theta\\)，所以我们就得到了GBDT每一的优化目标，即损失函数\\(L\\)对于\\(F_{t-1}\\)的负梯度。 梯度下降 GBDT 损失函数 \\(L(\\theta)\\) \\(L(F_t)\\) 参数 \\(\\theta^t\\) \\(F_t\\) 增量 \\(\\Delta \\theta_t=-\\alpha_t g_t\\) \\(f_t=-\\alpha_t g_t\\) 步长 \\(\\alpha_t\\) \\(\\alpha_t\\) 初始值 \\(\\theta_0\\) \\(f_0\\) Gradient Boosting Tree for Regression 我们先来讨论GBDT解决回归问题的算法。前面我们已经讨论过，在每一步GBDT的优化目标是损失函数的负梯度，那么现在的问题就是如何求得每一步最优的基模型（GBDT的基模型选用的是CART）。GBDT的算法步骤如下： Gradient Boosting Tree Algorithm INPUT: 训练样本\\(\\{(x_1,y_1),\\cdots,(x_m,y_m)\\}\\)，迭代轮数\\(T\\)，损失函数\\(L\\) OUTPUT: 强模型\\(F_T\\) 初始化弱学习器\\(f_0\\)，直接使用一个基模型在训练集上进行训练 在步骤\\(t=1...T\\)，对于每个样本计算负梯度\\(r_{ti}=\\left[\\frac{\\partial L(y_i,F_{t-1}(x_i))}{\\partial F_{t-1}}\\right]\\) 在\\((x_i,r_{ti})\\)上训练得到一个CART回归树，确定树的结构 假设一共有\\(J\\)个叶子节点，那么对每个叶子节点计算最佳输出值\\(c_{tj}=\\mathop{\\arg\\min}\\limits_{c_{tj}}\\sum_{x_i\\in R_{tj}} L(y_i,F_{t-1}(x_i)+c_{tj})\\)（其中\\(c_{tj}\\)代表第\\(j\\)个叶子的输出，\\(R_{tj}\\)代表第\\(j\\)个叶子对应的样本集合），确定每个叶子节点的输出 更新强学习器\\(F_t=F_{t-1}+f_t\\)，回到步骤2直到达到迭代轮数 最终得到强学习器的表达式：\\(f(x)=f_0(x)+\\sum\\limits_{t=1}^T\\sum\\limits_{j=1}^J c_{tj}\\mathrm I(x\\in R_{tj})\\) 于是我们就得到了最终模型\\(F_T\\)。 Gradient Boosting Tree for Classification 在处理分类任务时，由于输出是离散的值 一种方法是使用指数损失函数，此时GBDT退化为AdaBoost；另一种方法是借鉴逻辑回归的方法，去建模真实值的概率 Binary Classification Multi-class Classfication GBDT Sumarry 优点： 可以灵活处理 相对SVM，调参较少 使用某些损失函数对异常值的鲁棒性高 缺点： 难以并行训练 XGBoost 前面我们讲了梯度下降和牛顿法，刚才又讨论了GBDT和梯度下降的关系，那么XGBoost是否和牛顿法有什么关系呢？答案是肯定的。GBDT利用了损失函数在\\(F_{t-1}\\)的一阶展开（即一阶导数信息），而XGBoost则利用了损失函数在\\(F_{t-1}\\)的二阶展开，这也是XGBoost和GBDT最根本的区别。下面我们将详细讲解XGBoost算法。 牛顿法 XGBoost 损失函数 \\(L(\\theta)\\) \\(L(F_t)\\) 参数 \\(\\theta^t\\) \\(F_t\\) 增量 \\(\\Delta \\theta_t=-\\alpha_t H^{-1}_tg_t\\) \\(f_t=-\\alpha_t H^{-1}_tg_t\\) 步长 \\(\\alpha_t\\) \\(\\alpha_t\\) 初始值 \\(\\theta_0\\) \\(f_0\\) Regularization XGBoost相比GBDT的另一大改进是加入了正则化项，即控制每个树的复杂度。衡量树的复杂度的度量有很多，XGBoost采用的是每棵树叶子节点的个数\\(T\\)和每个叶子节点输出\\(w\\)的平方和： \\[ \\Omega(f)=\\gamma T+\\frac{1}{2}\\lambda\\parallel w\\parallel^2 \\] 这一步主要是为了进一步降低每个弱学习器的方差。 Objective Function 加上正则项之后总的损失函数变为： \\[ L=\\sum_{i=1}^N \\ell(y_i, F_T(x_i))+\\Omega(F_T) \\] 和GBDT类似，我们来推导第\\(t\\)步的优化公式，对于第\\(t\\)步，我们的损失函数为： \\[ \\begin{align} L_t&amp;=\\sum_{i=1}^N \\ell(y_i,F_t(x_i))+\\Omega(F_t)\\\\ &amp;=\\sum_{i=1}^N \\ell(y_i, F_{t-1}(x_i) + f_t(x_i))+\\Omega(F_t) \\end{align} \\] 将损失函数在\\(F_{t-1}\\)处进行二阶泰勒展开，得到 \\[ L_t \\approx \\left[\\sum_{i=1}^N \\ell(y_i, F_{t-1}) + g_i f_t(x_i) + \\frac{1}{2}h_i f_t^2(x_i) \\right] + \\Omega(F_t) \\] 其中\\(g_i=\\frac{\\partial \\ell(y_i, F_{t-1})}{\\partial F_{t-1}}\\)，\\(h_i=\\frac{\\partial \\ell(y_i, F_{t-1}) ^2}{\\partial^2 F_{t-1}}\\)，分别代表损失函数对\\(F_{t-1}\\)的一阶导和二阶导。 由于我们要优化的是本轮的基模型\\(f_t\\)，\\(\\ell(y_i, F_{t-1})\\)已经是固定的了，相当于常数，把常数项去掉，得到： \\[ \\begin{align} \\tilde L_t &amp;= \\left[\\sum_{i=1}^N g_i f_t(x_i) + \\frac{1}{2}h_i f_t^2(x_i) \\right] + \\Omega(f_t)\\\\ &amp;=\\left[\\sum_{i=1}^N g_i f_t(x_i) + \\frac{1}{2}h_i f_t^2(x_i) \\right] + \\gamma T + \\frac{1}{2}\\lambda \\parallel w \\parallel^2 \\end{align} \\] 我们都知道样本\\(x_i\\)在树\\(f_t\\)上的输出取决于\\(x_i\\)在哪个叶子节点。假设树\\(f_t\\)一共有\\(J\\)个叶节点，记\\(q(x_i)=j\\)代表样本\\(x_i\\)经过决策树对应的叶节点是\\(j\\)，\\(I_j\\)代表叶子节点\\(j\\)的所有样本下标集合，\\(w_j\\)代表叶子节点\\(j\\)的输出，我们可以将损失函数改写为： \\[ \\begin{align} \\tilde L_t &amp;= \\sum_{j=1}^J\\left[\\sum_{i\\in I_j}g_i w_j+\\frac{1}{2}(\\sum_{i\\in I_j}h_i +\\lambda)w_j^2\\right]+\\gamma T\\\\ &amp;= \\sum_{j=1}^J\\left[G_j w_j + \\frac{1}{2}(H_j+\\lambda)w_j^2 \\right] + \\gamma T \\end{align} \\] 其中\\(G_j=\\sum_{i\\in I_j}g_i\\)和\\(H_j=\\sum_{i\\in I_j}h_i\\)为简记，分别代表损失函数在叶子节点\\(j\\)对应的所有样本上的一阶导之和与二阶导之和。 到现在，我们还剩两个问题需要解决，一个是确定树\\(f_t\\)的最优结构，也就是怎么去分裂节点，另一个是确定每个叶子节点的最优输出。我们可以先确定下一个问题，找到另一个问题的最优答案，再来确定剩下的问题。 这里先去寻找树\\(f_t\\)每一个叶子节点对应的最优输出。和牛顿法的推导类似，为了使损失函数下降的最快，我们令\\(G_j w_j + \\frac{1}{2}(H_j+\\lambda)w_j^2\\)的导数为\\(0\\)，得到： \\[ w_j^*=-\\frac{G_j}{H_j + \\lambda} \\] 加上正则项有： \\[ \\tilde L_t^*=-\\frac{1}{2}\\sum_{j=1}^J\\frac{G_j^2}{H_j+\\lambda}+\\gamma T \\] Splitting Strategy 现在来确定树\\(f_t\\)的最优结构。最优结构的确定实际上使用了一种类似贪心的策略，和决策树类似，我们从一个只有根节点的树出发（所有样本都在根节点这一叶子节点上），不断分裂节点来降低\\(\\tilde L_t^*\\)。在每一步的分裂中，我们会希望\\(\\frac{G_j^2}{H_j+\\lambda}\\)越大越好，于是： \\[ Gain = \\frac{G_L^2}{H_L+\\lambda} + \\frac{G_R^2}{H_R+\\lambda} - \\frac{(G_L+G_R)^2}{H_L+H_R+\\lambda} - \\gamma \\] 我们希望挑选能使得\\(Gain\\)最大的特征和特征分裂点，而选择的策略又有很多种，下面介绍三种。 Exact Greedy Algorithm for Split Finding 最简单的方法是枚举所有特征，然后对于这个特征下的所有可能取值进行排序，然后遍历分裂点，找到使得\\(gain\\)最高的那个。这样做的好处是找到的分裂点确定是最好的，不过坏处是时间复杂度过高。 Approximate Algorithm for Split Finding 一个比较容易想到的优化方案是不去遍历所有可能的分裂点，而是只考察其中的分位数，如下图展示了三分位数方法： 这样需要考察的点就大大减少。 同时分位数的选择由有global和local之分，global是指在训练之前我们就可以提前对每个特征的分位数进行预处理，local是指每次分裂前计算分位数点。直观上来说global需要更多的分位点数，而local则需要更多的计算量。 实际上，XGBoost还会使用二阶导信息\\(h_i\\)对样本进行夹权，如下图所示： Sparsity-aware Split Finding 稀疏感知分裂算法 (Sparsity-aware Split Finding) Other Features 除了上面提到的之外，XGBoost还有很多工程优化。 Block Structure and Parallelism XGBoost预先对特征进行了排序， 每个特征的增益的计算可以并行进行 Column Sample 借鉴随机森林，即每次只用一部分特征进行特征选择，进一步降低过拟合 Shrinkage 在每次迭代会对叶子节点的权总乘以一个系数，让后面的树有更大的学习空间。 Custom Loss Function Missing Values LightGBM parameter tuning","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Machine Learning","slug":"Technical-Notes/Machine-Learning","permalink":"http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"}],"tags":[{"name":"GBDT","slug":"GBDT","permalink":"http://qfxiao.me/tags/GBDT/"},{"name":"XGBoost","slug":"XGBoost","permalink":"http://qfxiao.me/tags/XGBoost/"}]},{"title":"Unsupervised Representation Learning by Predicting Random Distances","slug":"Unsupervised-Representation-Learning-by-Predicting-Random-Distances","date":"2020-08-24T08:17:36.000Z","updated":"2020-08-24T10:25:42.220Z","comments":true,"path":"2020/08/24/Unsupervised-Representation-Learning-by-Predicting-Random-Distances/","link":"","permalink":"http://qfxiao.me/2020/08/24/Unsupervised-Representation-Learning-by-Predicting-Random-Distances/","excerpt":"","text":"Introduction 针对高维表格数据的表示学习，作者提出了基于预测预计变换后的距离的无监督表示学习框架RDP，并进行了理论上的讨论。To be finished... 论文地址 代码地址 Proposed Method Random Distance Prediction Model 对于很多下游任务来说，高维数据对模型效率和性能都很大，所以学习低维的有意义（能够最大限度保存原始空间的信息）的表示十分重要。本文的大致思想是给定一个确定的随机映射将样本映射到一个新的空间，然后构造数据集，输入时任意一对样本，标签是两个样本在新的空间的距离，之后训练一个模型来学习这个距离。作者认为通过该任务的训练，模型能够学到有意义的低维表示。模型的框架如下图： 其中\\(\\phi(\\mathbf x;\\Theta):\\mathbb R^D\\mapsto\\mathbb R^M\\)为孪生神经网络（Siamese Neural Network），将数据映射到\\(M\\)的新空间。损失函数为： \\[ \\mathcal L_{rdp}(\\mathbf x_i,\\mathbf x_j)=l(\\langle \\phi(\\mathbf x_i;\\Theta),\\phi(\\mathbf x_j;\\Theta)\\rangle,\\langle\\eta(\\mathbf x_i),\\eta(\\mathbf x_j)\\rangle) \\] 其中\\(\\eta(\\cdot)\\)为已知的映射，\\(l(\\cdot)\\)为衡量两个输入相似程度的度量。具体的来说，文中选取了简单的实现方案，即采用内积作为映射后的样本的距离度量： \\[ \\mathcal L_{rdp}(\\mathbf x_i,\\mathbf x_j)=\\left(\\phi(\\mathbf x_i;\\Theta)\\cdot\\phi(\\mathbf x_j;\\Theta)-\\eta(\\mathbf x_i)\\cdot\\eta(\\mathbf x_j)\\right)^2 \\] \\(\\eta(\\cdot)\\)为现成的映射。至于为什么要这么做，可以先接着看下面原文给出的理论分析，然后我再说说我自己的理解。 Incorporating Task-Dependent Complementary Auxiliary Loss 对于特定的下游任务，作者提出可以整合额外的误差函数来提高模型行性能。比如说针对聚类任务可以使用重构误差： \\[ \\mathcal L_{aux}^{clu}(\\mathbf x)=(\\mathbf x-\\phi^\\prime(\\phi(\\mathbf x;\\Theta); \\Theta^\\prime))^2 \\] 其中\\(\\phi(\\cdot)\\)和\\(\\phi^\\prime(\\cdot):\\mathbb R^M\\mapsto\\mathbb R^D\\)分别为编码器和解码器。 对于异常检测任务，可以使用下式： \\[ \\mathcal L_{aux}^{ad}(\\mathbf x)=(\\phi(\\mathbf x;\\Theta)-\\eta(\\mathbf x))^2 \\] 这一个Loss本来是出现在强化学习的论文中，用来检测一个状态\\(\\mathbf x\\)出现的频率，如果预测误差较小，说明这个样本之前见过或见过类似的，否则没怎么见过，可以认为是异常。由于本文的目的主要是降维加保留原始空间信息，可以认为使用线性变换的话此目的已经达到了。 Theoretical Analysis Using Linear Projection 这里讨论使用线性映射的情况，设数据集\\(\\mathcal X\\subset\\mathbb R^{N\\times D}\\)，映射矩阵\\(\\mathbf A\\subset\\mathbb R^{K\\times D}\\)为一随机矩阵，映射之后的数据为\\(\\mathbf A\\mathcal X^\\top\\)。对于\\(\\epsilon\\in(0,\\frac{1}{2})\\)和\\(K=\\frac{20\\log n}{\\epsilon^2}\\)，存在\\(f:\\mathbb R^D\\mapsto\\mathbb R^K\\)使得对于所有的\\(\\mathbf x_i,\\mathbf x_j\\in\\mathcal X\\)有： \\[ (1-\\epsilon)\\parallel\\mathbf x_i-\\mathbf x_j \\parallel^2\\leq \\parallel f(\\mathbf x_i)-f(\\mathbf x_j)\\parallel^2\\leq (1+\\epsilon)\\parallel\\mathbf x_i-\\mathbf x_j\\parallel^2 \\] 如果\\(\\mathbf A\\)的每个元素独立采样自标准正态分布那么有： \\[ \\text{Pr}\\left((1-\\epsilon)\\parallel\\mathbf x\\parallel^2\\leq\\parallel\\frac{1}{\\sqrt{K}}\\mathbf A\\mathbf x\\parallel^2\\leq(1+\\epsilon)\\parallel\\mathbf x\\parallel^2\\right)\\geq 1-2e^{\\frac{-(\\epsilon^2-\\epsilon^3)K}{4}} \\] 在该随机映射下有： \\[ \\text{Pr}(|\\hat{\\mathbf x}_i\\cdot\\hat{\\mathbf x}_j-f(\\hat{\\mathbf x}_i)\\cdot f(\\hat{\\mathbf x}_j)|\\geq\\epsilon)\\leq 4e^{\\frac{-(\\epsilon^2-\\epsilon^3)\\cdot K}{4}} \\] 直观的解释就是说使用线性映射的情况下，只要使用的变换矩阵采样自标准正态分布，那么变换之后样本对之间的距离信息能够以一定的概率保留。 Using Non-Linear Projection 这里作者试图说明，在某些条件下，非线性随机映射的作用和核函数接近。对于一个确定的随机映射函数\\(g:\\mathbb R^D\\mapsto\\mathbb R^K\\)，在某些特定的条件下，函数\\(g\\)和核函数存在下列关系： \\[ k(\\mathbf x_i,\\mathbf x_j)=\\langle\\psi(\\mathbf x_i),\\psi(\\mathbf x_j)\\rangle\\approx g(\\mathbf x_i)\\cdot g(\\mathbf x_j) \\] 这个条件是函数\\(g\\)为一个乘以一个线性矩阵\\(\\mathbf A\\)然后在经过一个具备平移不变性的傅里叶基函数（如cosine）。由于核函数能够保留原始空间的信息，所以作者认为使用非线性函数也能保留原始空间的信息。 PS: 感觉作者在理论部分的讨论还是有点模糊，因为把一个随机的映射作为（伪）监督信息来进行学习，神经网络学到的不也就是随机噪声信息吗？对于这个方法work的原因，我在这里不负责任的分析一下。 Learning Class Structure by Random Distance Prediction 这一节主要解释为什么神经网络\\(\\phi(\\cdot)\\)学到的要比随机映射\\(\\eta(\\cdot)\\)要好。模型的优化目标可以写成如下的形式： \\[ \\mathop{\\arg\\min}_{\\Theta}\\sum_{\\mathbf x_i,\\mathbf x_j\\in\\mathcal X}(\\phi(\\mathbf x_i;\\Theta)\\cdot\\phi(\\mathbf x_j;\\Theta)-y_{ij})^2 \\] 其中\\(y_{ij}=\\eta(\\mathbf x_i)\\cdot\\eta(\\mathbf x_j)\\)。设\\(\\mathbf Y_\\eta\\in\\mathbb R^{N\\times N}\\)为距离矩阵。这个目标函数是在最小化每一对样本在经过\\(\\phi(\\cdot)\\)和\\(\\eta(\\cdot)\\)映射后之间的距离的差距。通过公式(7)和公式(8)我们知道，在合适的条件下，随机映射\\(\\eta(\\cdot)\\)能够保留原始空间的距离信息（即原始空间相近的样本在映射后也相近）。不过，上述公式的成立都依赖于对数据分布的一定假设，当真实的数据不满足条件时，结论就会有所偏差。 Experiments Performance Evaluation in Anomaly Detection Experimental Settings 异常分数定义为\\(\\mathcal S(\\mathbf x)=(\\phi(\\mathbf x;\\Theta)-\\eta(\\mathbf x))^2\\)。 Comparison to the State-of-the-art Competing Methods Ablation Study Performance Evaluation in Clustering Experimental Settings Comparison to the State-of-the-art Competing Methods image-20200720014002063","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Representation Learning","slug":"Research/Representation-Learning","permalink":"http://qfxiao.me/categories/Research/Representation-Learning/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"Representation Learning","slug":"Representation-Learning","permalink":"http://qfxiao.me/tags/Representation-Learning/"}]},{"title":"Effective End-to-end Unsupervised Outlier Detection via Linear Priority of Discriminative Network","slug":"Effective-End-to-end-Unsupervised-Outlier-Detection-via-Linear-Priority-of-Discriminative-Network","date":"2020-07-14T10:46:13.000Z","updated":"2020-07-21T12:35:42.220Z","comments":true,"path":"2020/07/14/Effective-End-to-end-Unsupervised-Outlier-Detection-via-Linear-Priority-of-Discriminative-Network/","link":"","permalink":"http://qfxiao.me/2020/07/14/Effective-End-to-end-Unsupervised-Outlier-Detection-via-Linear-Priority-of-Discriminative-Network/","excerpt":"","text":"Introduction 本文针对无监督异常检测提出了\\(E^3\\space{Outlier}\\)。作者使用自监督学习的方法，通过构建有监督任务在没有标签的情况下学习高层语义特征。PS：这篇文章的方法和NIPS18上的Deep Anomaly Detection Using Geometric Transformations（后面简称GEOM）颇为相似，但是不知为啥没有在实验中进行比较。后面我会分析一些两篇文章方法上的异同。 Proposed Method Surrogate Supervision Based Effective Representation Learning for UOD 这里作者提到了使用重构的模型来进行异常检测的不足：重构模型采用像素级别的损失函数（如mean square error），而这太过于严格和细节，并不能学到高层语义特征。 为此，作者提出了surrogate supervision based discriminative network (SSD)。具体操作和GEOM类似，首先预定义大小为\\(K\\)的几何变换集合\\(\\mathcal O=\\{O(\\cdot|y)\\}_{y=1}^K\\)。对每一个样本\\(\\mathbf x\\)，在经过\\(K\\)个集合变换之后会得到\\(K\\)个变换后的样本（第\\(y\\)个变换产生的样本即记为\\(\\mathbf x^{(y)}=O(\\mathbf x|y)\\)），每个样本对应的pseudo label即为变换的序号或者说种类。之后在新的数据集上（大小为原来的\\(K\\)倍）训练\\(K\\)分类网络。网络的输出为\\(P(\\mathbf x^{(y^\\prime)}|\\boldsymbol\\theta)=[P^{(y)}(\\mathbf x^{(y^\\prime)}|\\boldsymbol\\theta)]_{y=1}^K\\)，每个维度代表输入样本对应的变换的概率。总的损失函数为： \\[ \\min_\\theta\\frac{1}{N}\\sum_{i=1}^{N}\\mathcal L_{SS}(\\mathbf x_i|\\theta) \\] 其中\\(\\mathcal L_{SS}(\\mathbf x_i|\\theta)\\)代表每个样本对应的Loss，这个Loss可以由分类器在\\(K\\)个变换上的交叉熵损失来确定： \\[ \\mathcal L_{SS}(\\mathbf x_i|\\boldsymbol\\theta)=-\\frac{1}{K}\\sum_{y=1}^K\\log(P^{(y)}(\\mathbf x_i^{(y)}|\\boldsymbol\\theta))=-\\frac{1}{K}\\sum_{y=1}^K\\log(P^{(y)}(O(\\mathbf x_i|y)|\\boldsymbol\\theta)) \\] 变换集合\\(\\mathcal O\\)由一系列基本变换的组合确定。作者将这些基本变换分为了：1) 旋转 2) 翻转 3) 平移，包括横向和纵向 4) Patch置换（参考图1(a)中的Patch Re-arranging）。最终的变换集合\\(\\mathcal O\\)由三个子集组成，分别是\\(\\mathcal O_{RA}\\)（代表Regular Affine，其中每个变换为旋转\\(90°\\)的倍数、翻转、横向平移和纵向平移这四个基本变换的叠加），\\(\\mathcal O_{IA}\\)（代表Irregular Affine，其中每个变换为进行\\(30°\\)的倍数且不为\\(90°\\)的倍数角度的旋转、翻转这两个基本变换的叠加）和\\(\\mathcal O_{PR}\\)（只包含Patch Re-arranging）。 为了验证SSD学到的特征的有效性，作者将CAE提取的特征和SSD提取的特征分别用孤立森林进行异常检测，发现SSD效果更好（见图1(b)）。 到这里为止本文和GEOM基本没有大的区别。值得注意的是在所采用的几何变换中，采用了非线性变换（进行\\(30°\\)的倍数且不为\\(90°\\)的倍数角度的旋转）。而在GEOM中，提到过使用非线性变换的话效果会比较差，至于具体的影响如何，可能需要实验来确定。 Inlier Priority: The Foundation of End-to-end UOD 在这里作者主要对在训练集包含少量异常的情况下做出的理论分析，作者将其称为Inlier Priority，原句如下： Inlier Priority: Despite that inliers/outliersare indiscriminately fed into SSD for training, SSD will prioritize the minimization of inliers’ loss. Priority by Gradient Magnitude 对于第\\(c\\)个类来说，设softmax层和倒数第二层之间的权重矩阵为\\(\\mathbf w_c=[w_{s,c}]^{(L+1)}_{s=1}\\)，损失函数记为\\(\\mathcal L\\)，梯度记为\\(\\nabla_{\\mathbf w_c}\\mathcal L=[\\nabla_{w_{s,c}}\\mathcal L]^{(L+1)}_{s=1}\\)。设训练集\\(X^{(c)}\\)包含\\(N_{in}\\)个正常样本，\\(N_{out}\\)个异常样本。记正常样本和异常样本对应的梯度分别为\\(\\parallel\\nabla^{(in)}_{\\mathbf w_c}\\mathcal L\\parallel\\)和\\(\\parallel\\nabla^{(out)}_{\\mathbf w_c}\\mathcal L\\parallel\\)，在网络只有一个隐层且采用Sigmoid作为激活函数时，两者梯度的期望之比有如下关系： \\[ \\frac{E(\\parallel\\nabla^{(in)}_{\\mathbf w_c}\\mathcal L\\parallel^2)}{E(\\parallel\\nabla^{(out)}_{\\mathbf w_c}\\mathcal L\\parallel^2)}\\approx\\frac{N^2_{in}}{N^2_{out}} \\] 在训练集中，正常样本和异常样本的数量是极不均衡的，\\(N_{in}\\gg N_{out}\\)，所以有\\(E(\\parallel\\nabla^{(in)}_{\\mathbf w_c}\\mathcal L\\parallel^2)\\gg E(\\parallel\\nabla^{(out)}_{\\mathbf w_c}\\mathcal L\\parallel^2)\\)。 在使用更复杂的网络时，作者通过实验展示了正常样本和异常样本对应的梯度大小的比较： Priority by Network Updating Direction 这里作者通过梯度更新的方向来进行了理论上的解释。对于一个Batch的数据\\(X\\)，梯度为\\(-\\nabla_\\theta\\mathcal L(X)=-\\frac{1}{N}\\sum_i\\nabla_\\theta\\mathcal L(\\mathbf x_i)\\)，如果将该梯度在Batch中某一样本\\(\\mathbf x_i\\)对应的梯度的方向上进行分解\\(-\\nabla_\\theta\\mathcal L(\\mathbf x_i):d_i=-\\nabla_\\theta\\mathcal L(X)\\cdot\\frac{-\\nabla_\\theta\\mathcal L(\\mathbf x_i)}{\\parallel -\\nabla_\\theta\\mathcal L(\\mathbf x_i)\\parallel}\\)，这代表了总的Loss在多大程度上减小样本\\(\\mathbf x_i\\)对应的Loss，由于一个Batch即包含正常样本，也可能包含异常样本，所以作者将两者对应的梯度方向贡献进行了可视化： 可以看到随着训练的进行，正常样本对应的贡献更高。 PS: 我以为作者会对基于几何变换的异常检测为什么有效做一些理论上的解释，不过却没有。这里只是对在训练集包含少量异常的情况下做出的理论分析，而这个实际上直觉上就很显然了。 Scoring Strategies for UOD 作者采用了三种方法来计算异常分数： Pseudo Label based Score (PL) 对于一个测试样本\\(\\mathbf x\\)，对其进行\\(K\\)个几何变换，通过分类器会得到\\(K\\)个输出，对于第\\(k\\)个输出，我们只取其第\\(k\\)个分量，最后把他们加起来除以\\(K\\)： \\[ S_{pl}(\\mathbf x)=\\frac{1}{K}\\sum_{y=1}^K P^{(y)}(\\mathbf x^{(y)}|\\boldsymbol\\theta) \\] Maximum Probability based Score (MP) 这里稍有不同，对于第\\(k\\)个输出，我们取其值最大的分量，而不是第\\(k\\)个分量： \\[ S_{mp}(\\mathbf x)=\\frac{1}{K}\\sum_{y=1}^K\\max_t P^{(t)}(\\mathbf x^{(y)}|\\boldsymbol\\theta) \\] Negative Entropy based Score (NE) 作者认为，标签为One-Hot向量，分类器的输出分布越“尖峰”就越接近于正常样本，而越“平均”就越接近于异常样本，所以作者提出使用熵来描述分类器输出的“尖锐度”： \\[ S_{ne}(\\mathbf x)=-\\frac{1}{K}\\sum_{y=1}^K H(P(\\mathbf x^{(y)}|\\boldsymbol\\theta))=\\frac{1}{K}\\sum_{y=1}^K\\sum_{t=1}^K P^{(t)}(\\mathbf x^{(y)}|\\boldsymbol\\theta)\\log(P^{(t)}(\\mathbf x^{(y)}|\\boldsymbol\\theta)) \\] 这里作者对第一种方法得到的结果进行了可视化： PS：对比NIPS18 的Dirichlet Normality Score 也用到了全部\\(K\\)个维度的信息 相当于对分类器的输出做了迪利克雷分布的先验假设，然后通过训练集的输出估计分布参数。因为直觉上对于正常分布来说，分类器的输出分布形状上都类似一个尖峰，但对于不同的数据集来说具体形状还是会有所差异 Experiments Experiment Setup 数据集用到了MNIST, Fashion-MNIST (F-MNIST) , CIFAR10, SVHN和CIFAR100。为了模拟无监督异常检测的环境，人为在训练集中加入异常样本，异常的比例\\(\\rho\\)从\\(5\\%\\)到\\(25\\%\\)以\\(5\\%\\)的步长递增。评测标准采用AUPR和AUROC。 UOD Performance Comparison and Discussion 下表展示了模型性能对比结果： 下图展示了在不同的Outlier Ratio下的性能对比： 下图展示了在不同的变换集合，网络结构，异常分数的条件下的性能：","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Self-Supervised Learning","slug":"Self-Supervised-Learning","permalink":"http://qfxiao.me/tags/Self-Supervised-Learning/"}]},{"title":"Probability Distributions - Binary and Multinomial Variables","slug":"Probability-Distributions-Binary-and-Multinomial-Variables","date":"2020-06-22T05:43:58.000Z","updated":"2021-02-19T10:26:08.671Z","comments":true,"path":"2020/06/22/Probability-Distributions-Binary-and-Multinomial-Variables/","link":"","permalink":"http://qfxiao.me/2020/06/22/Probability-Distributions-Binary-and-Multinomial-Variables/","excerpt":"","text":"Overview 本文主要是介绍一些机器学习中常用的分布，内容主要来自PRML (Pattern Recognition and Machine Learning) 第二章Probability Distributions笔记的第一部分，主要包括2.1. Binary Variables和2.2. Multinomial Variables这两节。 Probability Distributions for Binary Variables Intro 这一节主要针对二值随机变量的建模，即\\(x\\in\\{0,1\\}\\)。这里可以想象为我们有一个硬币，\\(x=1\\)代表正面朝上，而\\(x=0\\)代表反面朝上，并且正面朝上的概率为\\(\\mu\\)，即： \\[ p(x=1|\\mu)=\\mu \\] 其中\\(0\\leqslant \\mu \\leqslant 1\\)。\\(x\\)的概率分布可以写为： \\[ \\text{Bern}(x|\\mu)=\\mu^x(1-\\mu)^{1-x} \\] 也就是我们熟知的伯努利分布 (Bernoulli Distribution)。其均值和方差分别为： \\[ \\begin{align} \\mathbb E[x]&amp;=\\mu\\\\ \\text{var}[x] &amp;= \\mu(1-\\mu) \\end{align} \\] 现在来考虑参数估计任务。假设我们正在进行一个投硬币的实验，每一次投币都服从伯努利分布且相互独立，我们将每次采集到的观测值组成数据集\\(\\mathcal D=\\{x_1,\\cdots,x_N\\}\\)，则似然函数为： \\[ p(\\mathcal D|\\mu)=\\prod_{n=1}^N p(x_n|\\mu)=\\prod_{n=1}^N \\mu^{x_n}(1-\\mu)^{1-x_n} \\] 如果采用极大似然估计的话，我们可以最大化似然函数，这等价于最大化对数似然： \\[ \\ln p(\\mathcal D|\\mu)=\\sum_{n=1}^{N}\\ln p(x_n|\\mu)=\\sum_{n=1}^N\\{x_n\\ln\\mu+(1-x_n)\\ln(1-\\mu)\\} \\] 令其导数为0得到极值点： \\[ \\mu_{ML}=\\frac{1}{N}\\sum_{n=1}^N x_n \\] 这相当于样本均值，不过这样做会有严重的问题。假设我们的数据集为\\(\\mathcal D=\\{1,1,1\\}\\)，也就是说我们只收集到了三个样本，并且都是正例，我们会得到\\(\\mu_{ML}=1\\)，而这显然是严重过拟合的。稍后我们会说说如何应对这种情况（加入先验）。 Binomial Distribution 我们同样可以对多次伯努利实验进行概率建模。记\\(m\\)为成功的次数，\\(N\\)为数据集大小，可知这个概率应该与\\(\\mu^m(1-\\mu)^{N-m}\\)成正比。乘以标准化系数后即我们熟知的二项分布 (Binomial Distribution)： \\[ \\text{Bin}(m|N,\\mu)=\\binom{N}{m}\\mu^m(1-\\mu)^{N-m} \\] 其中： \\[ \\binom{N}{m}=\\frac{N!}{(N-m)!m!} \\] 其均值和方差分别为： \\[ \\begin{align} \\mathbb E[m]&amp;=N\\mu\\\\ \\text{var}[m]&amp;=N\\mu(1-\\mu) \\end{align} \\] Beta Distribution 现在我们来讨论如何解决刚才提到的最大似然估计过拟合问题。为了解决这个问题，我们使用贝叶斯的思路，对\\(\\mu\\)引入了先验分布\\(p(\\mu)\\)。而这个分布需要具有良好的解释性和数学性质。 根据贝叶斯定理： \\[ p(\\mu|\\mathcal D)=\\frac{p(\\mathcal D|\\mu)p(\\mu)}{p(\\mathcal D)} \\] 而\\(p(\\mathcal D)=\\int_0^1 p(\\mathcal D|\\mu)p(\\mu)\\mathrm d\\mu\\)只受数据集影响，而数据集是固定的，所以为常数，因此\\(p(\\mu|\\mathcal D)\\propto p(\\mathcal D|\\mu)p(\\mu)\\)。而似然函数为\\(\\mu^x(1-\\mu)^{1-x}\\)的乘积，如果先验也采用\\(\\mu\\)和\\(1-\\mu\\)的幂的乘积的形式，那么后验分布也将和先验形式相同，这种性质在统计学中被称为先验共轭 (conjugacy)。 这里我们直接给出这个先验分布，再来分析它的性质。这个分布叫做Beta分布 (Beta Distribution)\\(P(\\mu|a,b)\\sim \\text{Beta}(a,b)\\)： \\[ \\begin{align} \\text{Beta}(\\mu|a,b) &amp;= \\frac{\\Gamma(a+b)}{\\Gamma(a\\Gamma(b)}\\mu^{a-1}(1-\\mu)^{b-1}\\\\ &amp;= \\frac{1}{B(a,b)}\\mu^{a-1}(1-\\mu)^{b-1} \\end{align} \\] \\(B(\\boldsymbol \\alpha,\\beta)\\)称为B函数，为一个标准化函数： \\[ \\begin{align} B(a,b) = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)} \\end{align} \\] 其目的是为了使整个概率分布积分等于1而存在的。Gamma函数的定义为： \\[ \\Gamma(x)=\\int_0^{\\infty}s^{x-1}e^{-s}\\mathrm d s \\] Gamma函数有一个性质： \\[ \\Gamma(x+1)=x\\Gamma(x) \\] 证明为： \\[ \\begin{align*} \\Gamma(x+1) &amp;= \\int_{0}^{\\infty} {s^{x} e^{-s} ds} \\\\ &amp;= \\big[s^{x} (-e^{-s})\\big] \\big|_{0}^{\\infty} - \\int_{0}^{\\infty} {(x s^{x-1}) (-e^{-s}) ds} \\\\ &amp;= (0 - 0) + x \\int_{0}^{\\infty} {s^{x-1} e^{-s} ds} \\\\ &amp;= x \\Gamma(x) \\end{align*} \\] 除此之外： \\[ \\Gamma(1)=1\\\\ \\Gamma(\\frac{1}{2})=\\sqrt{\\pi} \\] 可以验证： \\[ \\int_0^1\\text{Beta}(\\mu|a,b)\\mathrm d\\mu=1 \\] Beta分布的均值和方差为： \\[ \\mathbb E[\\mu]=\\frac{a}{a+b}\\\\ \\text{var}[\\mu]=\\frac{ab}{(a+b)^2(a+b+1)} \\] 因为后验分布与先验和似然函数的乘积成比例，那么： \\[ p(\\mu|m,l,a,b)\\propto\\mu^{m+a-1}(1-\\mu)^{l+b-1} \\] 其中\\(l=N-m\\)。乘上标准化因子，就得到： \\[ p(\\mu|m,l,a,b)=\\frac{\\Gamma(m+a+l+b)}{\\Gamma(m+a)\\Gamma(l+b)}\\mu^{m+a-1}(1-\\mu)^{l+b-1} \\] 得到的仍然是Beta分布，相当于把\\(a\\rightarrow{m+a}\\)，\\(b\\rightarrow{l+b}\\)。同时不难发现，参数\\(a\\)和\\(b\\)都有比较直观的意义。\\(a\\)可以看作是历史记录中，成功的次数，\\(b\\)可以看作是历史记录中失败的次数，比如\\(a=2\\)，\\(b=3\\)，根据经验成功的概率应该在\\(\\frac{2}{2+3}=0.4\\)左右，即我们的先验为成功的概率为\\(0.4\\)（见下图左下角的子图）。如果在实验中，又进行了\\(7\\)次实验，其中\\(m=6\\)，\\(l=1\\)，由于成功的次数变多了，\\(a=2+6=8\\)，\\(b=3+1=4\\)，直觉上来说我们对成功概率的估计应当相应提高，大概为\\(\\frac{8}{8+4}\\approx 0.67\\)左右。这时的Beta分布如右下角的图的样子，也印证了我们的直觉。 以下为不同参数对应的Beta分布的互动演示： 最后，Beta还有一个有趣的应用就是，如果我们不断接收到新的观测数据，那么旧的后验分布则可以作为新的先验分布将参数更新下去 。这相当于说，基于已有的观测数据，我们提出一个先验Beta分布，然后根据新得到的一批观测数据，用先验Beta分布计算一个似然函数，将似然函数和先验Beta分布乘起来，归一化后得到了新的后验分布，只要不断有新的观测数据接收到，就可以把后验分布作为新的先验，不断更新下去。这样做的优势是对于大数据集，我们不需要整个数据集，而是只需要一批一批的更新即可。 Probability Distributions for Multinomial Variables Intro 前面我们讨论了二值随机变量，现在我们将其扩展到多值变量。设一个\\(K\\)维向量\\(\\mathbf x\\)，当\\(x_k\\)为\\(1\\)的时候其他元素都为\\(0\\)，如\\(K=6,x_3=1\\)时\\(\\mathbf x\\)表示为\\(\\mathbf x=(0,0,1,0,0,0)^\\top\\)。如果\\(p(x_k=1)=\\mu_k\\)，那么\\(\\mathbf x\\)的概率分布为： \\[ p(\\mathbf x|\\boldsymbol \\mu)=\\prod_{k=1}^{K}\\mu_k^{x_k} \\] \\(\\mu_k\\)满足\\(\\sum_k \\mu_k=1\\)和\\(\\mu_k\\geqslant 0\\)，该分布被称作是Categorical Distribution。易知其均值为： \\[ \\begin{align} \\mathbb E[\\mathbf x|\\boldsymbol \\mu]=\\sum_{\\mathbf x}p(\\mathbf x|\\boldsymbol \\mu)\\mathbf x=\\boldsymbol \\mu \\end{align} \\] 假设我们有大小为\\(N\\)的数据集\\(\\mathcal D\\)，每个样本服从该分布且相互独立，那么似然函数： \\[ p(\\mathcal D|\\boldsymbol \\mu)=\\prod_{n=1}^N\\prod_{k=1}^K \\mu_k^{x_{nk}}=\\prod_{k=1}^K \\mu_k^{\\sum_n x_{nk}}=\\prod_{k=1}^K\\mu_k^{m_k} \\] 其中\\(m_k=\\sum_n x_{nk}\\)，即\\(x_k=1\\)的数量。为了最大化对数似然同时保证\\(\\sum_k \\mu_k=1\\)，我们可以用拉格朗日乘子法： \\[ \\sum_{k=1}^K m_k\\ln \\mu_k+\\lambda\\left(\\sum_{k=1}^K\\mu_k-1\\right) \\] 我们得到\\(\\mu_k=-m_k/\\lambda\\)。通过\\(\\sum_k \\mu_k=1\\)得出\\(\\lambda=-N\\)，故最后我们有： \\[ \\mu_k^{ML}=\\frac{m_k}{N} \\] 这相当于是\\(x_k=1\\)的数量除以总数。 Multinomial Distribution 类似的，我们可以对多次实验进行建模，假设进行\\(N\\)次独立实验，概率分布可以写为： \\[ \\text{Mult}(m_1,m_2,\\cdots,m_K|\\boldsymbol\\mu,N)=\\binom{N}{m_1m_2\\cdots m_K}\\prod_{k=1}^K\\mu_k^{m_k} \\] 这也是我们熟知的多项分布 (Multinomial Distribution)，其中\\(\\binom{N}{m_1m_2\\cdots m_K}\\)为正则化因子： \\[ \\binom{N}{m_1m_2\\cdots m_K}=\\frac{N!}{m_1!m_2!\\cdots m_K!} \\] 注意\\(\\sum\\limits_{k=1}^K m_k=N\\)。 Dirichlet Distribution 有了前面Beta的启发，我们同样可以对多项分布的参数\\(\\mu_k\\)建立共轭先验。首先根据似然函数，我们知道先验应当与\\(\\mu_k\\)的幂的乘积成比例： \\[ p(\\boldsymbol \\mu|\\boldsymbol \\alpha) \\propto \\prod_{k=1}^{K}\\mu_k^{a_{k-1}} \\] 其中\\(0\\leqslant \\mu_k\\leqslant 1\\)且\\(\\sum_k\\mu_k=1\\)。和Beta分布不同，由于要满足\\(\\sum\\mu_k=1\\)，所以\\(\\{\\mu_k\\}\\)的取值会位于\\(K-1\\)的单纯型上，如下图所示： 加上标准化因子，我们就得到了所谓的先验分布，称之为迪利克雷分布 (Dirichlet Distribution)： \\[ \\text{Dir}(\\boldsymbol \\mu|\\boldsymbol\\alpha)=\\frac{\\Gamma(\\alpha_0)}{\\Gamma(\\alpha_1)\\cdots\\Gamma(\\alpha_K)}\\prod_{k=1}^K\\mu_k^{a_{k-1}} \\] 其中\\(\\Gamma(\\cdot)\\)为Gamma函数，\\(\\alpha_0=\\sum\\limits_{k=1}^K\\alpha_k\\)。下图为不同条件下的迪利克雷分布的可视化： \\(\\boldsymbol \\mu\\)的后验与先验和似然函数的乘积成正比： \\[ p(\\boldsymbol\\mu|\\mathcal D,\\boldsymbol\\alpha)\\propto p(\\mathcal D|\\boldsymbol\\mu)p(\\boldsymbol\\mu|\\boldsymbol\\alpha)\\propto\\prod_{k=1}^K \\mu_k^{\\alpha_k+m_k-1} \\] 不难验证： \\[ \\begin{align} p(\\boldsymbol\\mu|\\mathcal D,\\boldsymbol\\alpha) &amp;= \\text{Dir}(\\boldsymbol\\mu|\\boldsymbol\\alpha+\\mathbf m)\\\\ &amp;=\\frac{\\Gamma(\\alpha_0+N)}{\\Gamma(\\alpha_1+m_1)\\cdots\\Gamma(\\alpha_K+m_K)}\\prod_{k=1}^K\\mu_k^{\\alpha_k+m_k-1} \\end{align} \\] 即后验同样为迪利克雷分布。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Notes","slug":"Research/Notes","permalink":"http://qfxiao.me/categories/Research/Notes/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://qfxiao.me/tags/Statistics/"},{"name":"Probability","slug":"Probability","permalink":"http://qfxiao.me/tags/Probability/"}]},{"title":"Time2Graph: Revisiting Time Series Modeling with Dynamic Shapelets","slug":"Time2Graph-Revisiting-Time-Series-Modeling-with-Dynamic-Shapelets","date":"2020-06-13T08:42:04.000Z","updated":"2020-07-07T03:15:36.315Z","comments":true,"path":"2020/06/13/Time2Graph-Revisiting-Time-Series-Modeling-with-Dynamic-Shapelets/","link":"","permalink":"http://qfxiao.me/2020/06/13/Time2Graph-Revisiting-Time-Series-Modeling-with-Dynamic-Shapelets/","excerpt":"","text":"Introduction 本文旨在提供一种可解释的高效的时间序列建模（表示学习）方法来更好地服务分类任务。Shapelet在时间序列分类任务上体现了良好的可解释性。不过传统的基于Shapelet的方法忽略了Shapelet在不同时间片段上的动态性，即整个时间维度上不同的时间片段可能适合用不同的Shapelet。作者基于此设计了动态的time-aware shapelet，并且定义了shapelet evolution graph来捕获Shapelet在时间维度上的动态变化。 📰Get Paper Preliminaries 时间序列集合\\(T=\\{t_1,\\cdots,t_{|T|}\\}\\)包含若干条时序数据\\(t=\\{x_1,\\cdots,x_n\\}\\)。一个\\(t\\)的片段\\(s\\)是\\(t\\)的一个连续子序列。如果\\(t\\)能被切分成\\(m\\)个长度都为\\(l\\)的片段，那么我们就有\\(t=\\{\\{x_{l*k+1},\\cdots,x_{l*k+l}\\},0\\leq k\\leq m-1\\}\\)。两个长度相等的片段之间距离很好度量，直接计算欧式距离即可，那么两个片段长度不相等的情况呢？这就需要对其（Alignment）的概念。 Definition 1 Alignment. 给定两个长度分别为\\(l_i\\)和\\(l_j\\)的序列\\(s_i\\)和\\(s_j\\)，一个alignment \\(a=(a_1,a_2)\\)是一个满足以下条件的长度为\\(p\\)的下标序列： \\[ 1\\leq a_k(1)\\leq\\cdots\\leq a_k(p)=l_k,\\\\ a_k(n+1)-a_k(n)\\leq 1,\\\\ \\text{for }k=i,j,\\text{ and }1\\leq n\\leq p-1 \\] 上述公式可能比较抽象，其实看了下图就不难理解： 片段\\(s_i\\)中的某个点\\(a\\)，与片段\\(s_j\\)中的某个点\\(b\\)形成对应，然后在\\(a\\)和\\(b\\)之间连一条虚拟的线（不能与已有的线交叉），一直这么做直到短的那个片段中的每个点都找到对应，就是一个合理的alignment。对于两个长度不一样的片段\\(s_i\\)和\\(s_j\\)，会有很多种alignment。我们把\\(s_i\\)和\\(s_j\\)所有可能的alignment记为\\(\\mathcal{A}(s_i,s_j)\\)。在定义了alignment之后就可以定义DTW了。DTW (Dynamic Time Warping) 定义为在给定一个预定义的距离度量\\(\\tau\\)和所有可能的alignment \\(\\mathcal{A}(s_i,s_j)\\)的情况下，最小的距离\\(\\tau\\)： \\[ d_\\text{DTW}(s_i,s_j)=\\min_{a\\in\\mathcal{A}(s_i,s_j)}\\tau(s_i,s_j|a) \\] 进一步的，因为时间序列\\(t\\)也可以看作是一个片段，我们可以定义一个子序列\\(s\\)和时间序列\\(t\\)之间的距离度量： \\[ D(s,t)=\\min_{1\\leq k\\leq m} d(s,s_k) \\] 这里\\(\\boldsymbol s_k\\)为时序\\(\\boldsymbol t\\)分解成的片段。之后Shapelet可以通过片段与时序的距离定义为最具有辨识度的有代表性的片段： Definition 2 Shapelet. 一个Shapelet \\(\\boldsymbol v\\)是对于特定类别时序的最具有代表性的片段。考虑时序分类任务，给定时序集合\\(T\\)，可以通过与\\(\\boldsymbol v\\)相似或不相似而分成两个子集合，与\\(\\boldsymbol v\\)相似的集合与\\(\\boldsymbol v\\)的距离应当尽量小，与\\(\\boldsymbol v\\)不相似的集合与\\(\\boldsymbol v\\)的距离应当尽量大，此时损失函数可以形式化为： \\[ \\mathcal L=-g(S_{pos}(\\boldsymbol v,T),S_{neg}(\\boldsymbol v,T)) \\] \\(\\mathcal L\\)描述了在shapelet \\(\\boldsymbol v\\)下正负样本集的相异性。\\(S_{*}(\\boldsymbol v,T)\\)表示特定时序集合与\\(\\boldsymbol v\\)的距离集合，\\(g(\\cdot,\\cdot)\\)为接受两个有限集合为输入的可微函数，并且能够度量两个集合的距离。 Framework 本文主要是提出了一种时间序列表示学习方法。基于Shapelet在不同的时间片段上的作用是不同的观察，作者为不同的时间片段赋予了不同的Shapelet，而不是像传统方法一样整个时序对应一个Shapelet。接着基于这些Shapelet作者构造了图，并通过图嵌入得到了嵌入向量，作为时序的表示。 Time-Aware Shapelet Extraction 第一步是捕获Shapelet在时间维度上的动态影响。我们定义了两个参数来定量的测量shapelet在不同时间上的动态性。第一个是局部因子\\(\\boldsymbol w_n\\)，用来控制shapelet内部\\(n\\)个元素的权重，那么shapelet \\(\\boldsymbol v\\)和片段\\(\\boldsymbol s\\)的距离为： \\[ \\begin{align} \\hat{d}(\\boldsymbol v,\\boldsymbol s|\\boldsymbol w) &amp;= \\tau(\\boldsymbol v,\\boldsymbol s|\\boldsymbol a^*,\\boldsymbol w)\\\\ &amp; = \\left(\\sum_{k=1}^{p}\\boldsymbol w_{\\boldsymbol a^*_1(k)}\\cdot(\\boldsymbol v_{\\boldsymbol a^*_1(k)}-\\boldsymbol s_{\\boldsymbol a^*_2(k)})^2\\right)^{\\frac{1}{2}} \\end{align} \\] 其中\\(\\boldsymbol a^*\\)为DTW距离下的最佳对齐。 第二个是全局因素\\(\\boldsymbol u_m\\)，这主要是通过对不同片段\\(\\boldsymbol s\\)施加不同的权重实现的，于是shapelet \\(\\boldsymbol v\\)和时间序列\\(\\boldsymbol t\\)的距离可以重写为： \\[ \\hat{D}(\\boldsymbol v,\\boldsymbol t|\\boldsymbol w,\\boldsymbol u)=\\min_{1\\leq k\\leq m}\\boldsymbol u_k\\cdot\\hat{d}(\\boldsymbol v,\\boldsymbol s_k|\\boldsymbol w) \\] 其中\\(\\boldsymbol t\\)被分割为\\(m\\)个片段：\\(\\boldsymbol t=\\{\\boldsymbol s_1,\\cdots,\\boldsymbol s_m\\}\\)。对于分类任务，具体的来说，我们先生成一堆Shapelet候选集，然后通过有监督的方法来挑选最佳的Shapelet和对应的参数\\(\\boldsymbol w\\)和\\(\\boldsymbol u\\)。 计算shapelet候选集的算法如下： 在获取了Shapelet候选集合之后，我们有带有标签的时序集合\\(T\\)，对于每一个Shapelet我们可以优化： \\[ \\hat{\\mathcal L}=-g(S_{pos}(\\boldsymbol v,T),S_{neg}(\\boldsymbol v,T))+\\lambda\\parallel \\boldsymbol w\\parallel+\\epsilon\\parallel \\boldsymbol u\\parallel \\] 来获取最优的\\(\\hat{\\boldsymbol w}\\)和\\(\\hat{\\boldsymbol u}\\)。然后，我们可以挑选出使得\\(\\hat{\\mathcal L}\\)最小的前\\(K\\)个Shapelet。整个过程的算法流程如下： Shapelet Evolution Graph 在获取了Shapelet之后，为了捕获Shapelet之间的相关性，我们定义了Shapelet Evolution Graph。 Definition 3 Shapelet Evolution Graph. Shapelet Evolution Graph为一个有向带权图\\(G=(V,E)\\)，\\(V\\)为\\(K\\)个Shapelet，每条带有权重\\(w_{ij}\\)的边\\(e_{ij}\\in E\\)代表两个Shapelet \\(\\boldsymbol v_i \\in V\\)和\\(\\boldsymbol v_j \\in V\\)被分配给相邻片段的概率。 Graph Construction 这里来说一下，建图的具体过程。首先顶点为Shapelet，之后来进行边的构造。对于每一个片段\\(\\boldsymbol s_i\\)，我们会计算Shapelet到该片段的距离，距离越近代表这个Shapelet与片段越匹配。之后会设定一个阈值\\(\\delta\\)，然后将与片段的距离低于这个阈值的Shapelet分配给这个片段（一个Shapelet可能会分配给多个不同片段）。对于\\(\\boldsymbol s_i\\)的所有shapetlet我们记为\\(\\boldsymbol v_{i,*}\\)，我们会按照Shape到片段的距离进行归一化： \\[ \\boldsymbol p_{i,j}=\\frac{\\max(\\hat{d}_{i,*}(\\boldsymbol v_{i,*},\\boldsymbol s_i))-\\hat{d}_{i,j}(\\boldsymbol v_{i,j},\\boldsymbol s_i)}{\\max(\\hat{d}_{i,*}(\\boldsymbol v_{i,*},\\boldsymbol s_i))-\\min(\\hat{d}_{i,*}(\\boldsymbol v_{i,*},\\boldsymbol s_i))} \\] 其中\\(\\hat{d}_{i,*}(\\boldsymbol v_{i,*},\\boldsymbol s_i)=\\boldsymbol u_*[i]*\\hat{d}(\\boldsymbol v_{i,*},\\boldsymbol s_i|\\boldsymbol w_*)&lt;\\delta\\)。这样对于每个片段\\(\\boldsymbol s_i\\)所分配的Shapelet对应的\\(\\boldsymbol p\\)之和会等于\\(1\\)。对每一对相邻的片段\\((\\boldsymbol s_i,\\boldsymbol s_{i+1})\\)的Shapelet \\(\\boldsymbol v_{i,j}\\)和\\(\\boldsymbol v_{i+1,k}\\)，我们创建一条连接\\(\\boldsymbol v_{*,j}\\)和\\(\\boldsymbol v_{*,k}\\)的边\\(e_{j,k}\\)，权重为\\(\\boldsymbol p_{i,j}\\cdot\\boldsymbol p_{i+1,k}\\)。最后，所有重复的边会被合并。 如上图所示，假设有两个片段，每个片段分配了\\(3\\)个Shapelet，Shapelet \\(B\\)在片段\\(1\\)对应的概率是\\(p_{12}\\)，Shapelet \\(C\\)在片段\\(2\\)对应的概率是\\(p_{23}\\)，那么由于片段\\(1\\)和\\(2\\)是相邻片段，会在\\(B\\)和\\(C\\)之间连一条边，边的权重为\\(p_{12}*p_{23}\\)。 建图的算法流程图如下： Representation Learning 之后，我们使用DeepWalk算法来获取获取每个结点（Shapelet）的嵌入表示。对于时序\\(\\boldsymbol t=\\{\\boldsymbol s_1,\\cdots,\\boldsymbol s_m\\}\\)即对应的Shapelet \\(\\{\\boldsymbol v_{1,*},\\cdots, v_{m,*}\\}\\)和对应的概率\\(\\{\\boldsymbol p_{1,*},\\cdots,\\boldsymbol p_{m,*}\\}\\)，每个Shaplet \\(\\boldsymbol v_{i,j}\\)的表示记为\\(\\boldsymbol \\mu(\\boldsymbol v_{i,j})\\)。片段\\(\\boldsymbol s_i\\)对应的嵌入向量为对应的Shapelet嵌入向量与对应的概率值加权求和： \\[ \\boldsymbol\\Phi_i=\\left(\\sum_j p_{i,j}\\cdot\\boldsymbol \\mu(\\boldsymbol v_{i,j})\\right),\\space 1\\leq i \\leq m \\] 算法流程如下： Experiments Experimental Setup 文中用了Earthquakes (EQS)、WormsTwoClass (WTC)、Strawberry (STB)、Electricity Consumption Records (ECR)和Network Traffic Flow (NTF) 这五个数据集，其中后两个为作者自己收集的数据集。五个数据集对应的统计信息如下： 文中与多个Baseline进行了比较，包括: Distance-based Models: 文中使用了不同的距离度量与基于1-NN的模型进行组合，包括Euclidean Distance (ED)、Dynamic Time Warping (DTW)、Weighted DTW (WDTW)、Complexity-Invariant Distance (CID) 和 Derivative DTW (DDTW)； Feature-based Models: 文中分别使用了提取特征（均值、标准差等）和原始序列来训练XGBoost。除此之外，还使用了 Bag-of-Patterns (BoP)、Time Series Forest (TSF)、Elastic Ensembles (EE) 和 基于SAX的 Vector Space Model (SAXVSM)； Shapelet-based Models: 这部分模型包括 Learn Time Series Shapelets (LS)、Fast Shapelets (FS)、和 Learned Pattern Similarity (LPS)； Deep Learning Models: 这部分模型包括MLP、LSTM和VAE。 Comparison Results 对于前三个公共数据集评测标准采用Accuracy，后两个数据集因为样本类比不均衡，所以采用了Precision、Recall和F1作为评测标准。结果如下： 在EQS数据集上，Time2Graph打败了所有Baseline，而在WTC和STB这两个数据集上也达到了较好的效果。在ECR和NTF这两个真实数据集上，Time2Graph在F1上打败了所有Baseline。 Parameter Analysis 本节对Shapelet的数量\\(K\\)、嵌入维度\\(B\\)和片段长度\\(l\\)进行了参数分析。结果如下： Case Study of Time-Aware Shapelets 本节作者对提出的Time-Aware Shapetlet进行了细致的探究。第一个问题是不同Shapelet的区分能力是否不同？下图(a)里，作者在使用Shapelet进行二分类的任务中，将Shapelet按Loss（图中灰色的线）进行排序，并且绘制了对应的正负样本距离的KL散度（橘红色的点）。可以看到，在Loss曲线和KL散度呈反比关系。KL散度越高，我们可以认为该Shapelet的区分度越高，这说明不同Shapelet的区分度的确不同，并且这会与最终效果直接挂钩。图(b)展示了不同Shapelet的均值和方差（原文没有说清楚是什么的均值和方差）。 除此之外，作者和流行的Shapelet提取算法LS进行了比较，如图(c)和图(d)。从图中可以看到对于不同时间，本文的算法提取的Shapelet的确是具有时间动态性的。 Case Study of the Shapelet Evolution Graph 本节作者对Shapelet Evolution Graph进行了细致的探究。下图分别为一月份和七月份的Shapelet Evolution Graph。在一月，45号Shapelet的度较大，而且对应的时间因素在一月和二月也较大（图中深色部分）。说明45号Shapelet在一月份具有代表性。而在七月，45号Shapelet的重要性降低，而42号Shapelet在七月的重要性很高。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Time Series Modeling","slug":"Research/Time-Series-Modeling","permalink":"http://qfxiao.me/categories/Research/Time-Series-Modeling/"}],"tags":[{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Shapelet","slug":"Shapelet","permalink":"http://qfxiao.me/tags/Shapelet/"}]},{"title":"Generative Probabilistic Novelty Detection with Adversarial Autoencoders","slug":"Generative-Probabilistic-Novelty-Detection-with-Adversarial-Autoencoders","date":"2020-06-06T04:03:27.000Z","updated":"2020-06-25T08:14:29.250Z","comments":true,"path":"2020/06/06/Generative-Probabilistic-Novelty-Detection-with-Adversarial-Autoencoders/","link":"","permalink":"http://qfxiao.me/2020/06/06/Generative-Probabilistic-Novelty-Detection-with-Adversarial-Autoencoders/","excerpt":"","text":"Introduction 这篇文章介绍了一种基于概率分布的异常检测方法。其基本思想是假设正常样本服从定义在流形\\(M\\)上的分布，而对于任意一点\\(\\bar x\\)，通过投影到流形\\(M\\)上\\(x^\\parallel\\)，可以分解为平行于切空间的部分\\(x^\\parallel\\)和正交与切空间的部分\\(x^\\bot\\)。原始的坐标\\(\\bar x\\)被转换到\\(x^\\parallel\\)局部坐标系中，然后似然通过转换后的坐标系进行计算。 Methodology Generative Probabilistic Novelty Detection 我们假设训练数据\\(x_1,\\cdots,x_N\\)，其中\\(x_i\\in\\mathbb{R}^m\\)，从一个分布采样的来，并带有随机噪声\\(\\xi\\)： \\[ x_i=f(z_i)+\\xi_i, \\space\\space\\space i=1,\\cdots,N \\] 其中\\(z_i\\in\\mathbb{R}^n\\)，\\(f:\\Omega\\mapsto\\mathbb{R}^m\\)定义了一个\\(n\\)维带参流形\\(\\mathcal{M}\\equiv f(\\Omega)\\)。注意这里噪声的加入使得样本的值域扩展到了整个实数空间。同时假设存在\\(g:\\mathbb{R}^m\\mapsto\\mathbb{R}^n\\)，对任意\\(x\\in\\mathcal{M}\\)都有\\(f(g(x))=x\\)。\\(f\\)和\\(g\\)后面会通过神经网络实现。 对于一个测试样本\\(\\bar{x}\\in\\mathbb{R}^m\\)，我们可以得到其在\\(M\\)上的投影，这是通过逆变换\\(\\bar z = g(\\bar x)\\)得到对应\\(z\\)的然后再通过\\(\\bar x^{\\parallel}=f(\\bar z)\\)得到。\\(f\\)在\\(\\bar z\\)的一阶泰勒展开为： \\[ f(z)=f(\\bar z)+J_f(\\bar z)(z-\\bar z)+O(\\parallel z-\\bar z\\parallel ^2) \\] 其中\\(J_f(\\bar z)\\)为\\(f\\)在点\\(\\bar z\\)的雅各比矩阵。\\(\\mathcal T=\\text{span}(J_f(\\bar z))\\)代表点\\(\\bar z\\)处由\\(J_f(\\bar z)\\)的\\(n\\)个独立向量组成的切空间。通过对\\(J_f(\\bar z)\\)进行奇异值分解\\(J_f(\\bar z)=U^\\parallel SV^\\top\\)。 \\[ \\bar w=U^\\top\\bar x=\\left[\\begin{matrix}U^{\\parallel^\\top}\\bar x\\\\ U^{\\bot^\\top}\\bar x\\end{matrix}\\right]=\\left[\\begin{matrix}\\bar w^\\parallel\\\\ \\bar w^\\bot\\end{matrix}\\right] \\] 坐标\\(\\bar w\\)可以分解为平行于\\(\\mathcal T\\)和正交于\\(\\mathcal T\\)两部分。 定义在施加变换前后的坐标系上的概率分布\\(p_X(x)\\)和\\(p_W(w)\\)是等价的，不过对于\\(p_W(w)\\)，我们假设平行部分和正交部分是独立的，即： \\[ p_X(x)=p_W(w)=p_W(w^\\parallel,w^\\bot)=p_{W^\\parallel}(w^\\parallel)p_{W^\\bot}(w^\\bot) \\] 这一假设的依据是随机噪声部分假设主要是往流形之外偏离的，即与\\(\\mathcal T\\)正交，所以\\(W^\\bot\\)主要是反映噪声的部分。而噪声与样本分布相独立的假设是合理的。于是，异常分数可以定义为： \\[ p_X(\\bar x)=p_{W^\\parallel}(\\bar w^\\parallel)p_{W^\\bot}(\\bar w^\\bot)=\\begin{cases}\\geq \\gamma \\Rightarrow \\text{Inlier}\\\\&lt;\\gamma\\Rightarrow\\text{Outlier}\\end{cases} \\] Computing the Distribution of Data Samples 上面的异常分数需要计算\\(p_{W^\\parallel}(\\bar w^\\parallel)\\)和\\(p_{W^\\bot}(\\bar w^\\bot)\\)。给定测试样本\\(\\bar x\\)，投影到流形\\(\\bar x^\\parallel=f(g(\\bar x))\\)。\\(\\bar w^\\parallel\\)可以重写为\\(\\bar w^\\parallel=U^{\\parallel^\\top}\\bar x=U^{\\parallel^\\top}(\\bar x-\\bar x^{\\parallel})+U^{\\parallel^\\top}\\bar x^\\parallel=U^{\\parallel^\\top}\\bar x^\\parallel\\)，即我们假设\\(U^{\\parallel^\\top}(\\bar x-\\bar x^\\parallel)\\approx 0\\)。于是有\\(w^\\parallel(z)=U^{\\parallel^\\top}f(\\bar z)+SV^\\top(z-\\bar z)+O(\\parallel z-\\bar z\\parallel^2)\\)。 如果\\(Z\\)为定义在流形上的概率分布，那么： \\[ p_{W^\\parallel}(w^\\parallel)=|\\text{det}S^{-1}|p_Z(z) \\] \\(p_{W^\\bot}(w^\\bot)\\)由半径为\\(\\parallel w^\\bot\\parallel\\)的超球体\\(\\mathcal S^{m-n-1}\\)来进行估计： \\[ p_{W^\\bot}(w^\\bot)\\approx\\frac{\\Gamma(\\frac{m-n}{2})}{2\\pi^{\\frac{m-n}{2}}\\parallel w^\\bot\\parallel^{m-n}}p_{\\parallel W^\\bot\\parallel}(\\parallel w^\\bot\\parallel) \\] 其中\\(\\Gamma(\\cdot)\\)代表Gamma函数。 Manifold Learning with Adversarial Autoencoders 为了学习映射\\(f\\)和\\(g\\)，我们使用了AAE框架，如下图所示： 除了常规的AAE外，我们还为\\(x\\)添加了一个额外的判别器。 Adversarial Losses 对于隐变量\\(z\\)，对抗损失函数为： \\[ \\mathcal L_{adv-d_z}(x,g,D_z)=E[\\log(D_z(\\mathcal N(0,1)))]+E[\\log(1-D_z(g(x)))] \\] 对于样本\\(x\\)，对抗损失函数为： \\[ \\mathcal L_{adv-d_x}(x,D_x,f)=E[\\log(D_x(x))]+E[\\log(1-D_x(f(\\mathcal N(0,1))))] \\] Autoencoder Loss \\[ \\mathcal L_\\text{error}(x,g,f)=-E_z[\\log(p(f(g(x))|x))] \\] Full Objective \\[ \\mathcal L(x,g,D_z,D_x,f)=\\mathcal L_{adv-d_z}+\\mathcal L_{adv-d_x}+\\lambda \\mathcal L_\\text{error} \\] 下图为模型重构的例子： Experiments Datasets MNIST. 手册数字识别数据集。 The Coil-100. 包含7200张100个不同物体的不同角度的图片。 Fashion-MNIST. 手册数字识别数据集彩色版。 Others. 前三个数据集都是采用一个类作为inlier，而其他类作为outlier。在这一设置中inlier采样自数据集CIFAR-10(CIFAR-100)，而outlier采样自TinyImageNet、LSUN和iSUN。 Results MNIST Dataset Coil-100 Dataset Fashion-MNIST CIFAR-10 (CIFAR-100) Ablation","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"GAN","slug":"GAN","permalink":"http://qfxiao.me/tags/GAN/"},{"name":"Novelty Detection","slug":"Novelty-Detection","permalink":"http://qfxiao.me/tags/Novelty-Detection/"}]},{"title":"Classification-based Anomaly Detection for General Data","slug":"Classification-based-Anomaly-Detection-for-General-Data","date":"2020-06-02T15:01:34.000Z","updated":"2020-06-26T12:55:43.589Z","comments":true,"path":"2020/06/02/Classification-based-Anomaly-Detection-for-General-Data/","link":"","permalink":"http://qfxiao.me/2020/06/02/Classification-based-Anomaly-Detection-for-General-Data/","excerpt":"","text":"Introduction 本文主要是对NIPS18这篇异常检测文章的改进，首先是利用了标签信息来提升算法的表现，其次是将算法扩展到了非图像数据。作者对现有的异常检测算法进行了回顾： Reconstruction Methods： 这一部分方法假设异常样本和正常样本能够通过重构任务来进行区分。通过在正常样本上学习重构任务，之后对于正常样本，模型能够很好地进行重构，而异常样本则会有较高的重构误差。 Distributional Methods： 这一部分方法将异常检测看作是密度估计问题。通过对正常样本的分布进行估计，异常样本在该正常分布下的似然将会很低。 Classification-based Methods： 这一部分方法主要是指的单分类方法和通过几何变换构造分类任务的方法。本文使用的就是这类方法。 Proposed Method Classification-based Anomaly Detection 假设所有数据位于空间\\(R^L\\)内，而正常数据位于子空间\\(X\\subset R^L\\)内。我们假设所有的异常样本位于\\(X\\)之外。为了检测异常，我们希望学习一个分类器\\(C\\)使得对于所有的\\(x\\in X\\)有\\(C(x)=1\\)，而对所有的\\(x\\in R^L\\backslash X\\)有\\(C(x)=0\\)。 单分类方法的思想是直接学习\\(P(x\\in X)\\)，代表的方法有One-Class SVM，DSVDD等。传统的OC-SVM直接在原始空间或者核空间学习分类器。比较新的方法，如Deep-SVDD则是先将样本转换到一个特征空间，然后在这个特征空间上学习使得半径\\(R\\)最小的超球体（球心\\(c_0\\)），来覆盖住所有正常样本。异常的判定则通过计算\\(\\parallel f(x)-c_0\\parallel^2-R^2\\)来实现。不过学习一个好的样本到特征空间的变换并不是一件容易的事情，比如说\\(f(x)=0, \\forall x \\in X\\)就是一个使得超球体最小的解。所以需要很多trick来避免诸如此类的情况。 Geometric-transformation classification (GEOM) 则将数据空间\\(X\\)通过\\(M\\)个几何变换转换到一系列子空间\\(X_1,\\cdots,X_M\\)。之后训练一个分类器来预测样本\\(T(x,m)\\)对应的几何变换的种类\\(m\\)。转换后的正常图片空间记为\\(\\cup_m X_m\\)，所以该方法尝试估计以下条件概率： \\[ P(m^\\prime|T(x,m))=\\frac{P(T(x,m)\\in X_{m^\\prime})P(m^\\prime)}{\\sum_{\\bar{m}}P(T(x,m)\\in X_{\\bar{m}})P(\\tilde{m})}-\\frac{P(T(x,m)\\in X_{m^\\prime})}{\\sum_{\\bar{m}}P(T(x,m)\\in X_{\\bar{m}})} \\] 对于异常的样本\\(x\\in R^L\\backslash X\\)，在经过几何变换之后，都不会位于正确的子空间中，即\\(T(x,m)\\in R^L\\backslash X_m\\)。之后，使用\\(P(m|T(x,m))\\)来判定异常。 作者认为，这种方法的问题是分类器\\(P(m^\\prime|T(x,m))\\)只在正常数据上训练，而对于异常样本的异常分数会出现方差很大的问题。 一种解决方式是加入异常样本进行训练，但是作者认为在有的任务中标签很难获取，于是作者使用了另外一种方法来解决这个问题。 Distance-based Multiple Transformation Classification 和GEOM一样，先对每个样本进行\\(M\\)个几何变换，然后学习一个特征提取器\\(f(x)\\)，将\\(X_m\\)映射到特征空间。之后和OC-SVM类似，假设特征\\(\\{f(x)|x\\in X_m\\}\\)为球心为\\(c_m=\\frac{1}{N}\\sum_{x\\in X} f(T(x,m))\\)的超球体。样本属于某一类\\(m^\\prime\\)的概率由下式给出： \\[ P(m^\\prime|T(x,m))=\\frac{e^{-\\parallel f(T(x,m))-c_{m^\\prime}\\parallel^2}}{\\sum_{\\bar m}e^{-\\parallel f(T(x,m))-c_{\\bar m}\\parallel^2}} \\] 目标函数采用的是Triplet Loss： \\[ L=\\sum_i\\max(\\parallel f(T(x_i,m))-c_m\\parallel^2+s-\\min_{m^\\prime\\neq m}\\parallel f(T(x_i,m))-c_{m^\\prime}\\parallel^2,0) \\] \\(\\parallel f(T(x_i,m))-c_m\\parallel^2\\)相当于最小化了类内距离，\\(\\min_{m^\\prime\\neq m}\\parallel f(T(x_i,m))-c_{m^\\prime}\\parallel^2\\)最大化了每个类对应的集簇间距离。在检测阶段，为了避免一些数值问题，作者做了一些平滑操作： \\[ \\tilde P(m^\\prime|T(x,m))=\\frac{e^{-\\parallel f(T(x,m))-c_{m^\\prime}\\parallel^2+\\epsilon}}{\\sum_{\\tilde m}e^{-\\parallel f(T(x,m))-c_{\\tilde m}\\parallel^2+M\\cdot\\epsilon}} \\] 最后的评判分数由下式给出： \\[ Score(x)=-\\log P(x\\in X)=-\\sum_m\\log \\tilde{P}(T(x,m)\\in X_m)=-\\sum_m\\log\\tilde{P}(m|T(x,m)) \\] 算法流程图如下： Parameterizing the Set of Transformations 在GEOM中，由于使用的几何变换都是针对图像的，所以对于其他类型的数据并不适用。本文中作者对非图像数据设计了以下变换： \\[ T(x,m)=W_mx+b_m \\] 不同的参数\\(W_m\\)和\\(b_m\\)即为不同的几何变换，可以考虑采用随机采样的方式。 Experiments Image Experiments 对于图像数据的异常检测实验，作者采用了CIFAR10、FasionMNIST这两个数据集，实验结果如下： Tabular Data Experiments 对于非图像数据，作者采用了几个小的数据集：Arrhythmia、Thyroid、KDD和KDDRev。采用的Baseline包括OC-SVM、E2E-AE、LOF、DAGMM和FB-AE (Feature Bagging Autoencoder)。对于几何变换的参数，采样自标准正态分布。结果如下： Remark 结合OpenReview上的一些讨论，这里提出一些问题和总结： KDD数据集太简单了，正常、异常样本能够很容易被分开； 对于图像数据作者只使用了CIFAR10和FashionMNIST这两个比较小的数据集，而在GEOM中还使用了CIFAR100和CatsVsDogs。并且GEOM原文中提到数据集（指图像大小）越大，GEOM的优势就越明显，所以在本文的实验中只使用这两个数据集说服力略显不够； 关于评测标准的问题，作者在图像数据中用的是AUROC，而非图像数据用的是F1 score。像AUPR、AUROC这种评测标准往往更加全面，而F1 score依赖于阈值的选取。如果是遍历阈值找到最好的那个F1 score，则无法全面考察模型的鲁棒性，模型有可能只是在特定的阈值下表现很好，而阈值稍微偏差一下性能可能就会大幅下降。我看到的大多数异常检测文章都是使用AUROC或者F1加上AUROC作为评测指标； 文中在第二节“CLASSIFICATION-BASED ANOMALY DETECTION”的末尾两段关于GEOM方法的缺点说的很模糊。异常分数的方差大到底指的是什么； 关于作者提出的变换\\(T(x,m)=W_mx+b_m\\)并没有用到图像数据的实验上，而且在实验中\\(b_m\\)这个参数实际上是被忽略掉了的，\\(b_m\\)的作用究竟如何不得而知。而且GEOM中的几何变换的Motivation在原文中是做了实验充分讨论了的，GEOM的作者认为这些几何变换保留了图像的高阶语义信息。而本文中的变换中的参数只是随机采样而来，并不存在说保留原始数据中的结构信息。如果忽略掉这一层变换，那就类似于加了神经网络提取特征的OC-SVM。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"面向OpenPAI的Docker镜像配置及OpenPAI基本使用方法","slug":"面向OpenPAI的Docker镜像配置及OpenPAI基本使用方法","date":"2020-06-02T04:26:13.000Z","updated":"2020-08-01T04:00:16.325Z","comments":true,"path":"2020/06/02/面向OpenPAI的Docker镜像配置及OpenPAI基本使用方法/","link":"","permalink":"http://qfxiao.me/2020/06/02/%E9%9D%A2%E5%90%91OpenPAI%E7%9A%84Docker%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE%E5%8F%8AOpenPAI%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Introduction 实验室服务器集群采用OpenPAI来进行GPU资源的管理，而OpenPAI采用了Docker作为基础，即代码都放在Docker容器中运行。由于Docker的使用、Docker镜像的配置都有一定的门槛，所以这里写一篇Tutorial来进行介绍。本文不是网上资料的拼凑，而是经过本人走弯路踩坑形成的\"Best practice\"。主要内容包括Docker的介绍、Docker的基本使用、如何配置自己的Docker镜像以及OpenPAI平台的基本使用，但不包括Docker和OpenPAI的安装。 2020.8.1 Update: 加入通过HDFS读取容器保存的文件的方法 Docker from Scratch 要理解Docker是什么，从虚拟机开始讲可能会比较好理解。虚拟机大家可能都很熟悉了，比如说我用的系统是Windows，但我需要Linux系统来作为一个Flask编写的网站的服务器，但是又不想单独安装Linux系统，于是可以使用虚拟机来解决这个问题。安装VMWare Workstation，去官网下载Ubuntu系统镜像，然后在VMWare中安装好系统，然后从头配置Flask相关环境。实际上我需要的仅仅是一个Flask运行环境而已，而使用虚拟机却需要如此“大费周章”，这时Docker出现了，网上有大量现成的Flask Docker镜像，配置好了你所需的Flask环境，你只需要下载这些镜像，然后运行它，你就得到了一个Flask运行环境，而与你当前使用的系统无关。如果你需要一个Tomcat的运行环境，那么去找一个Tomcat的Docker镜像就行。Docker将需求或者说服务绑定在了Docker镜像中（轻量化，一个需求对应一个Docker镜像，每个镜像都很小），你有什么需求，去找相应的镜像即可（或者自己写一个），镜像的运行是以虚拟机的形式存在，所以他们之间也是互不干扰的。同时，你在写好一个Docker镜像之后，你还可以分享给别人，这样其他人就不用重新配置，直接运行你给他的镜像即可。Docker有两个比较关键的概念： 镜像 Images： 这里的镜像不是指我们安装系统时下载的ISO镜像，Docker镜像就是把你需要的东西（一个系统+需要的服务）集中到一起，相当于做菜的菜谱； 容器 Containers： 如果一个Docker镜像启动了，那么就会有一个Docker容器产生，相当于按照菜谱做出来的菜。 这一节我们先不讨论如何自己写Docker镜像，只是先讨论Docker的基本操作。 Basic Operations Docker新安装好当然是没有什么镜像的，首先我们使用docker pull hello-world来下载一个测试镜像。 拉取镜像 docker pull &lt;image_name&gt; 在输入之后，Docker会自动在远程服务器上查找对应的镜像进行下载。由于我的电脑上已经有这个镜像了，所以显示是下面的样子： 接下来，我们输入docker run hello-world运行这个镜像。 运行镜像docker run &lt;image_name&gt; 可以看到，Docker输出了一些信息就自己退出了，这和我们理解的虚拟机不太一样。在Docker里面，我们既可以创建一个完整的系统，用户在运行之后就可以正常使用这个操作系统，也可以创建一个简单的服务，默认运行完一些指令就退出了。这里的hello-world镜像这是输出了一些信息后就自动退出了，因为这就是这个镜像的全部内容。 我们尝试来运行一个完整的系统，先用docker pull ubuntu拉取Ubuntu Docker镜像： 接下来我们使用： -it的意思是什么？根据docker run --help： 123456789-i, --interactive Keep STDIN open even if not attached --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --ipc string IPC mode to use --isolation string Container isolation technology --kernel-memory bytes Kernel memory limit-t, --tty Allocate a pseudo-TTY --ulimit ulimit Ulimit options (default [])Copy 其实-it是-i和-t的合并写法，意思是运行后进入这个容器并且启用shell，不然运行之后就会放到后台而不会进入容器中。而--rm则代表容器退出之后会被删除（镜像不会被删除），每次运行实际上会创建一个新的容器，如果不加--rm或退出之后不手动删除的话会看到一堆停止运行的容器。 输入cat /etc/issue可以看到默认拉取的是最新的Ubuntu 20.04 LTS： Build Customized Docker Images 如果没有现成的Docker镜像能满足我们的需求，我们可以考虑自己写一个。要自定义一个Docker镜像需要两步，第一步是编写Dockerfile，第二步是使用docker build命令构建镜像。Dockerfile可以看作是一个脚本，描述了我们构建镜像所需要的全部命令，比如要构建一个用于Python科学计算的Docker镜像，我们需要在Dockerfile中编写安装Python的命令，安装Numpy、Scipy等常用包的命令等等。我们先来上手编写Dockerfile，这里我准备写一个包含hexo博客框架的镜像，这个框架需要node作为基础环境，不过我们不需要在Dockerfile里写安装node的命令。因为类似于C++或Python中的对象的继承，Dockerfile也可以“继承”，这意味着我们不必从头写起。我们先来看一下完整的Dockfile和效果，再来一一解释。 1234567FROM node--------------------------------------------------------------RUN npm install -g hexo-cliEXPOSE 4000CMD hexo init blog &amp;&amp; cd blog &amp;&amp; hexo generate &amp;&amp; hexo serverCopy 运行结果如下所示，可以看到Docker按照我们写的Dockerfile一行一行的进行镜像的构建： 现在来解释Docerfile里的内容。FROM &lt;docker image&gt;表示继承其他的镜像，这里我们使用node官方的镜像。接下来是安装hexo，RUN &lt;command&gt;表示执行命令，这里我们直接用npm install -g hexo-cli进行安装。由于要浏览博客网页需要开放端口，而Docker容器运行的时候和外部主机是完全隔断的，要使外部主机访问Docker容器端口，需要暴露端口。EXPOSE &lt;port&gt;代表暴露端口，这里用的是4000端口。之后是创建博客和启动本地服务，CMD &lt;command&gt;和RUN &lt;command&gt;的区别是RUN会在构建的时候执行，而CMD是在容器启动之后才会执行。hexo init blog &amp;&amp; cd blog &amp;&amp; hexo generate &amp;&amp; hexo server分别代表初始化博客、进入博客所在文件夹、生成博客网站、启动本地服务器。更多指令可以参考官方文档。 然后我们使用docker build -t test_hexo .命令构建镜像。 构建镜像 docker build -t &lt;image_name&gt; &lt;direcotry&gt; 运行镜像： 可以看到容器启动后开始执行博客初始化。 最后在locahost:4000上启动了一个本地服务器，在浏览器中输入这个地址，可以看到刚刚构建好的博客： 值得注意的是，在Dockerfile中我们暴露了4000端口，使用-p标签可以达到同样的效果：docker run -p &lt;docker_port&gt;:&lt;local_port&gt; &lt;image_name&gt;。比如docker run -p 9999:8888 xxxx代表将Docker容器中的9999端口转发到外部主机的8888端口。如果你是在远程服务器上使用的Docker，那么端口只是被转发到了远程服务器上，还得手动将远程服务器再转发到你本机上才能直接在本机浏览器上看到页面。 Build Docker Images with Aliyun Container Registry 因为某些原因，如果在构建镜像的时候需要通过apt-get update更新源，会发现无论如何都会卡住。这个时候可以使用阿里云容器镜像服务，在阿里的服务器上构建好镜像，再拉取到自己的机器上。注册好帐号之后，点击创建镜像仓库： 这里仓库类型如果没有特殊需求建议使用公开，然后填写一些基本信息： 之后设置代码源，其实就是告诉阿里云从哪儿获取Dockerfile，我这里用的是Github，所以需要先在阿里云中关联Github账号，然后在Github中创建一个用来放Dockerfile的仓库。构建设置里有一个“海外机器构建”，这正是我们使用阿里云容器服务的主要目的，勾选。 镜像仓库创建好之后，点进去，在构建页面点击添加规则： 按下图进行设置即可，镜像版本就是你想要的镜像名字： 点击“立即构建”： 等待一段时间后，如果构建成功，便可以进行拉取了，在镜像仓库的基本信息页面可以看到地址： 将阿里云上的镜像拉取到本机之后一般会想要对镜像改名，可以使用docker tag &lt;old_name&gt; &lt;new_name&gt;。 Build Docker Images for Deep Learning Startup 在Docker中配置适用于OpenPAI的深度学习镜像不是一件容易的事，会有很多的坑，这里专门说一下如何配置。推荐在阿里云容器镜像服务中进行构建，会少很多麻烦。 第一步是初始镜像，由于需要用到CUDA，这里可以根据自己的需求（比如不同CUDA版本支持的GPU驱动版本不一样，还有Tensorflow不同版本对CUDA和cuDNN要求也不一样）从Nvidia的Dockerhub官方页面选择合适的CUDA和cuDNN版本： 这里我们选择CUDA10.1 + cuDNN7： 1FROM nvidia/cuda:10.1-cudnn7-devel-ubuntu18.04Copy 这一条主要是解决乱码问题以及定义用到的软件包的版本，这里Miniconda版本设置为4.5.4的原因是这是最后一个自带Python3.6的版本，我在这儿为了稳定所以用了Python3.6，大家也可以安装最新版的Miniconda： 1234ENV LANG=C.UTF-8 LC_ALL=C.UTF-8ENV HADOOP_VERSION=2.7.2LABEL HADOOP_VERSION=2.7.2ENV MINICONDA_VERSION=4.5.4Copy 接下来安装必须的包，大家可以根据需求自行调整，-y标签代表Yes，即自动同意安装： 123456789101112131415RUN DEBIAN_FRONTEND=noninteractive &amp;&amp; \\ apt-get -y update &amp;&amp; \\ apt-get -y install build-essential \\ wget \\ git \\ curl \\ unzip \\ automake \\ openjdk-8-jdk \\ openssh-server \\ openssh-client \\ lsof \\ libcupti-dev &amp;&amp; \\ apt-get clean &amp;&amp; \\ rm -rf /var/lib/apt/lists/*Copy 安装Miniconda并设置环境变量，-b标签可以让Miniconda无交互自动安装： 123RUN wget --quiet https://repo.anaconda.com/miniconda/Miniconda3-$&#123;MINICONDA_VERSION&#125;-Linux-x86_64.sh &amp;&amp; /bin/bash Miniconda3-$&#123;MINICONDA_VERSION&#125;-Linux-x86_64.sh -b -p /opt/miniconda \\&amp;&amp; rm Miniconda3-$&#123;MINICONDA_VERSION&#125;-Linux-x86_64.shENV PATH /opt/miniconda/bin:$PATHCopy 安装Hadoop，OpenPAI平台会用到： 123RUN wget -qO- http://archive.apache.org/dist/hadoop/common/hadoop-$&#123;HADOOP_VERSION&#125;/hadoop-$&#123;HADOOP_VERSION&#125;.tar.gz | \\ tar xz -C /usr/local &amp;&amp; \\ mv /usr/local/hadoop-$&#123;HADOOP_VERSION&#125; /usr/local/hadoopCopy ENV的作用是配置环境变量。配置JAVA和Hadoop环境变量： 12345678910ENV JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 \\ HADOOP_INSTALL=/usr/local/hadoop \\ NVIDIA_VISIBLE_DEVICES=allENV HADOOP_PREFIX=$&#123;HADOOP_INSTALL&#125; \\ HADOOP_BIN_DIR=$&#123;HADOOP_INSTALL&#125;/bin \\ HADOOP_SBIN_DIR=$&#123;HADOOP_INSTALL&#125;/sbin \\ HADOOP_HDFS_HOME=$&#123;HADOOP_INSTALL&#125; \\ HADOOP_COMMON_LIB_NATIVE_DIR=$&#123;HADOOP_INSTALL&#125;/lib/native \\ HADOOP_OPTS=&quot;-Djava.library.path=$&#123;HADOOP_INSTALL&#125;/lib/native&quot;Copy 设置PATH环境变量： 12ENV PATH=/usr/local/nvidia/bin:/usr/local/cuda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$&#123;HADOOP_BIN_DIR&#125;:$&#123;HADOOP_SBIN_DIR&#125; \\LD_LIBRARY_PATH=/usr/local/cuda/extras/CUPTI/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/nvidia/lib:/usr/local/nvidia/lib64:/usr/local/cuda/lib64:/usr/local/cuda/targets/x86_64-linux/lib/stubs:$&#123;JAVA_HOME&#125;/jre/lib/amd64/serverCopy 完整的Dockerfile如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344FROM nvidia/cuda:10.1-cudnn7-devel-ubuntu18.04ENV LANG=C.UTF-8 LC_ALL=C.UTF-8ENV HADOOP_VERSION=2.7.2LABEL HADOOP_VERSION=2.7.2ENV MINICONDA_VERSION=4.5.4RUN DEBIAN_FRONTEND=noninteractive &amp;&amp; \\ apt-get -y update &amp;&amp; \\ apt-get -y install build-essential \\ wget \\ git \\ curl \\ unzip \\ automake \\ openjdk-8-jdk \\ openssh-server \\ openssh-client \\ lsof \\ libcupti-dev &amp;&amp; \\ apt-get clean &amp;&amp; \\ rm -rf /var/lib/apt/lists/*RUN wget --quiet https://repo.anaconda.com/miniconda/Miniconda3-$&#123;MINICONDA_VERSION&#125;-Linux-x86_64.sh &amp;&amp; /bin/bash Miniconda3-$&#123;MINICONDA_VERSION&#125;-Linux-x86_64.sh -b -p /opt/miniconda \\&amp;&amp; rm Miniconda3-$&#123;MINICONDA_VERSION&#125;-Linux-x86_64.shENV PATH /opt/miniconda/bin:$PATH RUN wget -qO- http://archive.apache.org/dist/hadoop/common/hadoop-$&#123;HADOOP_VERSION&#125;/hadoop-$&#123;HADOOP_VERSION&#125;.tar.gz | \\ tar xz -C /usr/local &amp;&amp; \\ mv /usr/local/hadoop-$&#123;HADOOP_VERSION&#125; /usr/local/hadoop ENV JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 \\ HADOOP_INSTALL=/usr/local/hadoop \\ NVIDIA_VISIBLE_DEVICES=allENV HADOOP_PREFIX=$&#123;HADOOP_INSTALL&#125; \\ HADOOP_BIN_DIR=$&#123;HADOOP_INSTALL&#125;/bin \\ HADOOP_SBIN_DIR=$&#123;HADOOP_INSTALL&#125;/sbin \\ HADOOP_HDFS_HOME=$&#123;HADOOP_INSTALL&#125; \\ HADOOP_COMMON_LIB_NATIVE_DIR=$&#123;HADOOP_INSTALL&#125;/lib/native \\ HADOOP_OPTS=&quot;-Djava.library.path=$&#123;HADOOP_INSTALL&#125;/lib/native&quot;ENV PATH=/usr/local/nvidia/bin:/usr/local/cuda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$&#123;HADOOP_BIN_DIR&#125;:$&#123;HADOOP_SBIN_DIR&#125;:$PATH \\LD_LIBRARY_PATH=/usr/local/cuda/extras/CUPTI/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/nvidia/lib:/usr/local/nvidia/lib64:/usr/local/cuda/lib64:/usr/local/cuda/targets/x86_64-linux/lib/stubs:$&#123;JAVA_HOME&#125;/jre/lib/amd64/serverCopy 建议先把这一部分进行构建，作为基础镜像，后面要配置其他环境（如安装Pytorch框架登），就不用重复构建这部分，还减少了出错的可能性。这里说一下，启动带CUDA的Docker镜像需要在docker run加上额外的参数--runtime nvidia。 接下来安装深度学习框架。 Configure PyTorch 假设上面的镜像我们命名为xiaoqinfeng/base，那么构建PyTorch的Dockerfile可以像下面这么写： 12345FROM xiaoqinfeng/baseRUN pip install -U pipRUN pip install numpy scipy pandas matplotlib tqdmRUN pip install torch==1.5.0+cu101 torchvision==0.6.0+cu101 -f https://download.pytorch.org/whl/torch_stable.htmlCopy 因为这里我用的CUDA10.1，其他版本的CUDA安装指令可能不太一样，具体可以参考官网。 Configure Tensorflow 如果是安装Tensorflow，那么构建Tensorflow的Dockerfile可以像下面这么写： 1234FROM xiaoqinfeng/baseRUN pip install -U pipRUN pip install numpy scipy pandas matplotlib tqdm tensorflow-gpuCopy 这里会自动安装最新版本的Tensorflow2。Tensorflow不同版本对CUDA和cuDNN版本甚至Python版本的支持都不太一样，可以参考官网的说明。 Deep Learning with OpenPAI What is OpenPAI OpenPAI是一个分布式深度学习计算资源管理平台，对于我们用户来说，只需要定义好Docker镜像，然后编写好任务设置，提交到平台之后，平台便会自动分配计算资源来运行任务。 OpenPAI界面： 下面我们来讲讲怎么向OpenPAI平台提交任务。 Submit Jobs to OpenPAI Pack Code &amp; Data Files 假设你已经完成了代码的编写和测试，你的目录结构可能看起来是这样： 12345678.├── README.md├── data│ └── dataset.csv├── main.py└── src ├── data.py └── net.pyCopy 因为OpenPAI会创建一个虚拟容器来运行你的代码，所以你的数据和代码必须要以某种方式传送到OpenPAI上的虚拟容器中。我们先来打包，在代码目录下执行tar -cvf files.tar ./。之后，运行python -m http.server &lt;port&gt;。打开浏览器输入&lt;server_ip&gt;:&lt;port&gt;应该就能看到你的文件了： 由于这个http进程需要一直运行，所以建议使用screen放到后台执行。 Configure Tasks 像OpenPAI提交任务可以采用网页提交也可以使用VSCode插件，这里我们采用网页提交。登入OpenPAI界面，点击Submit Job： 可以看到提交任务的界面： Job name大家可以自己设置。在Command一栏，是执行任务所需的全部命令，首先我们要做的就是将代码数据压缩包下载到容器中并解压： 123wget &lt;server_ip&gt;:&lt;port&gt;/files.tartar -xvf files.tarCopy 然后是运行代码，假设我这里的任务比较简单，只有一行main.py的调用： 1python main.pyCopy 如果任务的执行比较复杂，也只需把命令填到Command里即可，OpenPAI会自动执行。接下来是设置配置，可以选GPU的数量，内存大小等等： 然后是镜像的选择： 要注意在本机上构建好镜像之后，需要把镜像重命名为&lt;repository_address&gt;/&lt;image_name&gt;的格式（我们的&lt;repository&gt;是lin-ai-27:5000，假设我的镜像名是xiaoqinfeng/pytorch，那就是改成lin-ai-27:5000/xiaoqinfeng/pytorch），然后执行docker push推送到Docker镜像服务器上才能在OpenPAI上使用。 提交之后，可以在Jobs界面看到任务的运行情况： Misc Store Files in Containers 我们往往需要在程序运行的时候保存文件，如checkpoints等。在OpenPAI上执行程序的话文件是保存在程序中的，如果我们想要在运行完之后把文件复制到本地电脑上呢？这个时候就需要在任务的配置文件里加上复制文件到HDFS的语句。首先确认你的HDFS的URL：如hdfs://172.31.246.52:9000/你的OpenPAI用户名/。 如果要创建文件夹，则可以使用hdfs dfs -mkdir -p &lt;HDFS URL&gt;+&lt;New Folder&gt;。这里&lt;New Folder&gt;是你要创建的的文件夹的路径，用起来和Linux的mkdir命令其实是差不多的。 要复制文件（夹）则使用hdfs dfs -cp &lt;Source Dir&gt; &lt;Dest Dir&gt;。","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Misc","slug":"Technical-Notes/Misc","permalink":"http://qfxiao.me/categories/Technical-Notes/Misc/"}],"tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://qfxiao.me/tags/Pytorch/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://qfxiao.me/tags/Tensorflow/"},{"name":"Docker","slug":"Docker","permalink":"http://qfxiao.me/tags/Docker/"}]},{"title":"Ubuntu20.04LTS 深度学习环境配置 CUDA11 + cuDNN8 + Tensorflow + Pytorch","slug":"Ubuntu20-4LTS-深度学习环境配置-CUDA11-cuDNN8-Tensorflow-Pytorch","date":"2020-06-02T02:26:13.000Z","updated":"2020-12-21T14:05:52.434Z","comments":true,"path":"2020/06/02/Ubuntu20-4LTS-深度学习环境配置-CUDA11-cuDNN8-Tensorflow-Pytorch/","link":"","permalink":"http://qfxiao.me/2020/06/02/Ubuntu20-4LTS-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-CUDA11-cuDNN8-Tensorflow-Pytorch/","excerpt":"","text":"Introduction Ubuntu的最新LTS版本也更新到了20.04，在给新机器配置深度学习环境的时候发现比以前容易了许多，特此写一篇Tutorial。这里的安装方法只针对Ubuntu20.04LTS，对于其他版本的系统可能不太适用。 Install GPU Drivers 这里假设安装系统之后已经做好了必要的配置（安装常用软件依赖、修改国内源等）。Ubuntu20.04中GPU驱动可以直接通过GUI界面安装，十分方便，方法是找到软件与更新 (Software &amp; Updates)，在附加驱动 (additional drivers) 选项卡中选择驱动版本，一般是选择“专有，tested” (proprietary, tested) 那个，之后点Apply Changes，重启。 如果是服务器的话，也可以采用命令行的安装方法。在命令行输入： 1ubuntu-drivers devices 会列出驱动信息： image-20201219103330645 可以看到推荐驱动版本是455，直接使用命令ubuntu-drivers autoinstall就可以自动安装推荐版本的驱动了。 Install CUDA &amp; cuDNN 最常用的方式是按照官网的指导来安装CUDA，之后需要设置环境变量，在~/.bashrc中添加下列指令： 123export PATH=/usr/local/cuda-11.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda-11.0/lib64\\ $&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125; 还可以选择简单的方式，直接使用apt-get来安装CUDA： 1sudo apt-get install nvidia-cuda-toolkit 不过这样会直接安装最新的CUDA版本，而PyTorch等深度学习框架不一定对最新的CUDA版本都有很好的支持，所以不推荐这种方式。 安装完CUDA之后输入nvcc --version可以测试是否安装成功，输入nvidia-smi可以看到GPU信息和CUDA版本。 之后安装cuDNN，进入官网，选择Download cuDNN： 会要求登录，如果没有账号的注册一个即可。在这里根据CUDA版本选择适合的cuDNN，我这里是CUDA10.2。我们选择deb包的方式安装，下载下图中圈出来的三个deb包，依次用sudo dpkg -i xxx.deb命令安装。 Configure Python 为了更好地管理Python包和虚拟环境，我们需要安装Anaconda。使用Anaconda之后，我们可以创建虚拟环境，虚拟环境之间互不干扰。做科学实验我们一般需要安装大量的Python包，有的包之间甚至还有冲突，如果我们把他们都安装在同一个环境下就会难以管理，甚至出冲突。而有了虚拟环境之后，我们可以把不同需求放在不同虚拟环境中，比如深度学习开发放在一个虚拟环境中（安装Tensorflow等），网站开发放在一个虚拟环境中（安装Flask等）。Anaconda默认自带大量的包，不过我们一般会创建新的虚拟环境去安装新的包，所以这里我们选用Miniconda。Miniconda和Anaconda唯一的区别是不会自带大量Python包，这里大家自行选择。Anaconda国内镜像下载地址为：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/，Miniconda国内镜像下载地址为：https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/。 比如说我们下载的是Miniconda3-py38_4.8.2-Linux-x86_64.sh，执行bash Miniconda3-py38_4.8.2-Linux-x86_64.sh即可安装。显示一大屏用户协议哪儿按q可以直接跳过，其他选项的默认的输入yes即可。在提示是否需要conda init的时候记得输入yes。 安装成功之后，重开一个终端，可以看到现在处于base环境中： 我们先配置一下国内镜像，执行 1vim ~/.condarc 然后粘贴下列文本使用清华源： 1234567891011121314151617channels: - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 之后我们输入conda create -n &lt;your_name&gt;创建一个新的虚拟环境，如果需要指定Python版本，则conda create --n &lt;your_name&gt; python=&lt;python_version&gt;。之后输入conda activate &lt;your_name&gt;进入虚拟环境，如果需要退出，则使用conda deactivate。 安装常用包： 1conda install --yes numpy scipy pandas matplotlib tqdm pip jupyter --yes的作用是手动输入y来确认是否安装，这里列出的是一些最常用的Python包，大家可以根据自己的需求自行调整。conda install为Anaconda中安装Python包的方式。 Install PyTorch 这里来安装PyTorch环境，推荐使用conda create -n pytorch创建一个专有虚拟环境，然后使用conda install安装常用包。对于安装PyTorch，我们可以使用conda也可以使用pip安装。pip是另外一个安装Python包的工具，由于不检查依赖所以比conda安装速度快，而且包的数量比conda多，使用也更广泛。同样pip也可以使用国内镜像加速下载，详见https://mirrors.tuna.tsinghua.edu.cn/help/pypi/。 对于CUDA11.0，官方给出的用conda安装PyTorch的命令（CUDA11.1也是这个）是： 1conda install pytorch torchvision torchaudio cudatoolkit=11.0 -c pytorch 用pip安装PyTorch的命令是： 1pip install torch==1.7.1+cu110 torchvision==0.8.2+cu110 torchaudio===0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 对于其他版本的CUDA安装命令可能不一样，可以去官网查看。 可以使用以下命令来测试GPU版本的PyTorch是否正常工作： 1python -c &quot;import torch; print(torch.cuda.is_available())&quot; Install Tensorflow 安装Tensorflow环境同样推荐创建一个专有虚拟环境。对于Tensorflow2的安装，使用pip十分方便，使用 1pip install tensorflow tensorflow-gpu 即可。要安装其他版本的Tensorflow可以使用pip install tensorflow==&lt;tf_version&gt; tensorflow-gpu==&lt;tf_version&gt;来指定版本。不过不同版本的Tensorflow要求的CUDA版本都有所不同，可以参考官网的说明。 可以使用以下命令来测试GPU版本的Tensorflow是否正常工作： 1python -c &quot;import tensorflow as tf; tf.config.list_physical_devices(&#x27;GPU&#x27;)&quot;","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Misc","slug":"Technical-Notes/Misc","permalink":"http://qfxiao.me/categories/Technical-Notes/Misc/"}],"tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://qfxiao.me/tags/Pytorch/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://qfxiao.me/tags/Tensorflow/"}]},{"title":"Deep Anomaly Detection Using Geometric Transformations","slug":"Deep-Anomaly-Detection-Using-Geometric-Transformations","date":"2020-06-01T15:17:03.000Z","updated":"2020-06-26T16:25:25.079Z","comments":true,"path":"2020/06/01/Deep-Anomaly-Detection-Using-Geometric-Transformations/","link":"","permalink":"http://qfxiao.me/2020/06/01/Deep-Anomaly-Detection-Using-Geometric-Transformations/","excerpt":"","text":"Introduction 本文考虑图像数据的异常检测问题。与基于重构的方法不同，本文提出的方法通过对正常图片施加不同的几何变换之后，训练一个多分类器将无监督异常检测问题转化为一个有监督问题。本方法背后的直觉是在训练能够分辨不同变换后的图片之后，分类器一定学得了一些显著的几何特征，这些几何特征是正常类别独有的。 Proposed Method Problem Statement 本文考虑针对图像的异常检测。记\\(\\mathcal X\\)为所有自然图像的空间，\\(X\\subseteq\\mathcal X\\)为正常图像集合。给定数据集\\(S\\subseteq X\\)，异常检测的目的是学习一个分类器\\(h_S(x):\\mathcal X\\rightarrow\\{0,1\\}\\)，其中\\(h_S(x)=1\\Leftrightarrow x\\in X\\)。 为了兼顾查准率和查全率，常用的设置是学习一个打分函数\\(n_S(x):\\mathcal X\\rightarrow\\mathbb R\\)，分数越高代表样本属于\\(X\\)的概率越大。之后，通过设定阈值，便可以构建异常分类器： \\[ \\begin{align} h_S^\\lambda(x)= \\begin{cases} 1 &amp; n_S(x)\\leq\\lambda\\\\ 0 &amp; n_S(x)&lt;\\lambda \\end{cases} \\end{align} \\] Discriminative Learning of an Anomaly Scoring Function Using Geometric Transformations 有初始数据集\\(S\\)，几何变换集合\\(\\mathcal T\\)，通过对\\(S\\)中每个样本施加这\\(|\\mathcal T|\\)个几何变换得到新数据集记为\\(S_\\mathcal{T}\\)，且\\(S_\\mathcal{T}\\)中每个样本的标签为变换的序号。之后，在\\(S_\\mathcal{T}\\)上训练一个\\(|\\mathcal T|\\)分类器。在测试阶段，对测试样本同样施加\\(|\\mathcal T|\\)个几何变换，分类器会给出经过\\(\\mathrm{softmax}\\)的输出向量，最终的异常分数由经过输出的向量构造的分布对数似然得来。 Creating and Learning the Self-Labeled Dataset 设\\(\\mathcal T=\\{T_0,T_1,\\cdots,T_{k-1}\\}\\)为几何变换集合，\\(1\\leq i\\leq k-1,\\space T_i:\\mathcal X\\rightarrow \\mathcal X\\)，且\\(T_0(x)=x\\)。\\(S_\\mathcal{T}\\)定义为： \\[ S_\\mathcal T=\\{(T_j(x),j):x\\in S,T_j\\in\\mathcal T\\} \\] 对于每个\\(x\\in S\\)，\\(j\\)为\\(T_j(x)\\)的标签。我们直接学习一个\\(K\\)类分类器\\(f_\\theta\\)，来预测输入样本对应的几何变换种类，这相当于是一个图像分类问题。 Dirichlet Normality Score 接下来要做的是如何定义异常分数，记为\\(n_S(x)\\)，这是文中的一个重要的部分。设几何变换集合\\(\\mathcal T=\\{T_0,T_1,\\cdots,T_{k-1}\\}\\)，且\\(k\\)分类器\\(f_\\theta\\)在\\(S_\\mathcal{T}\\)上完成训练。对于任意一个样本\\(x\\)，令\\(\\mathbf y(x)=\\text{softmax}(f_{\\theta}(x))\\)，即分类器\\(f_\\theta\\)输出的\\(\\text{softmax}\\)之后的向量。异常分数\\(n_S(x)\\)定义为： \\[ n_S(x)=\\sum\\limits_{i=0}^{k-1}\\log p(\\mathbf y(T_i(x))|T_i) \\] 该异常分数定义为每个类别上，在几何变换\\(T_i\\)的条件下，输出的\\(\\mathbf y\\)的对数似然之和。在文中，作者假设\\(\\mathbf y(T_i(x)|T_i\\)服从迪利克雷分布：\\(\\mathbf y(T_i(x))|T_i\\sim\\text{Dir}(\\boldsymbol \\alpha_i)\\)，其中\\(\\boldsymbol \\alpha_i\\in\\mathbb R^k_+\\)，\\(x\\sim p_X(x)\\)，\\(i\\sim\\text{Uni}(0,k-1)\\)，而\\(p_X(x)\\)代表正常样本的真实数据分布。于是： \\[ n_S(x)=\\sum_{i=0}^{k-1}\\left[\\log\\Gamma(\\sum_{j=0}^{k-1}[\\tilde{\\boldsymbol\\alpha}_i]_j)-\\sum_{j=0}^{k-1}\\log\\Gamma([\\tilde{\\boldsymbol\\alpha}_i]_j)+\\sum_{j=0}^{k-1}([\\tilde{\\boldsymbol\\alpha}_i]_j-1)\\log\\mathbf y(T_i(x))_j\\right] \\] 因为\\(\\tilde{\\alpha}_i\\)相对于\\(x\\)来说是常数，所以可以直接忽略，于是式子简化为： \\[ n_S(x)=\\sum_{i=0}^{k-1}\\sum_{j=0}^{k-1}([\\tilde{\\boldsymbol\\alpha}_i]_j-1)\\log\\mathbf y(T_i(x))_j=\\sum_{i=0}^{k-1}(\\tilde{\\boldsymbol \\alpha}_i-1)\\cdot\\log\\mathbf y(T_i(x)) \\] 注意这里的每个\\(\\boldsymbol \\alpha_i\\)都是一个向量，即对于每个变换\\(i\\)，都对应一个迪利克雷分布，其参数为\\(\\boldsymbol\\alpha_i\\)；在对训练集进行第\\(i\\)个几何变换之后，我们得到了\\(\\{T_i(x)\\}\\)，然后分类器\\(f_\\theta(\\cdot)\\)的输出\\(\\mathbf y(T_i(x))\\)相当于迪利克雷分布的观测值，我们需要根据观测值来估计参数\\(\\boldsymbol \\alpha_i\\)，然后根据这个参数来计算\\(n_S(x)\\)。对于\\(\\boldsymbol\\alpha_i\\)，可以知道其第\\(i\\)个分量应该是相对比较大的，下面是运行官方代码得到的\\(\\boldsymbol\\alpha_i\\)的结果（\\(i=69\\)，\\(i\\)从\\(0\\)开始，总共为\\(72\\)维），可以看到第\\(69\\)个分量是最大的。 12345678910111213[INFO] value of mle_alpha_t: [ 0.10228925 0.08997199 0.13083569 0.10862965 0.09811163 0.08527119 0.17637901 0.27628416 0.12873376 0.19197053 0.11587154 0.09873095 0.12700618 0.07688542 0.10488203 0.12499191 0.11637607 0.07739511 0.13049147 0.51031647 0.20546597 0.15558449 0.09288609 0.12134945 0.09324992 0.14650162 0.16281216 0.11827823 0.08214853 0.15618336 0.28129761 0.45293697 0.11485838 1.78598954 0.16556983 0.1141158 0.10909459 0.13916602 0.11563799 0.07309986 0.11049714 0.12974086 0.15930642 0.13714361 0.13938356 0.70619553 0.11174039 0.07201538 0.16626109 0.12153727 0.09548811 0.07940956 0.15832209 0.11035474 0.12487912 0.16937875 0.23212662 0.37041831 0.08557451 0.0839439 0.09924258 0.39766872 0.14917286 0.08704662 0.09554555 0.31047109 0.24504759 0.16812463 0.11508187 63.98878807 0.12971073 0.07972932] 下图也展示了对于每个变换\\(i\\)，\\(\\mathbf y(T_i(x)|T_i\\)分布的情况： 作者还给出了一种简化的形式，\\(\\hat{n}_S(x)=\\frac{1}{k}\\sum^{k-1}_{j=0}[\\mathbf y(T_j(x))]_j\\)。相当于说，对于每个变换\\(T_i\\)分类器都会给出一个\\(\\text{softmax}\\)向量，取其第\\(i\\)个分量\\([\\mathbf y(T_j(x))]_j\\)，然后把每个变换对应的\\([\\mathbf y(T_j(x))]_j\\)加起来。 整个算法的流程如下： 这里结合作者的源代码简单说一下检测阶段的流程。 12for t_ind in range(transformer.n_transforms): observed_dirichlet = mdl.predict(transformer.transform_batch(observed_data, [t_ind] * len(observed_data)), batch_size=1024) 在训练好模型之后，对于训练集的所有样本，对其进行\\(K\\)个几何变换之后，得到\\(K\\)个样本\\(\\{T_i(x)\\}\\)，对于所有第\\(i\\)个几何变换对应的样本\\(\\{T_i(x)\\}\\)，通过分类器\\(f_\\theta\\)会给出输出\\(\\mathbf y(T_i(x))\\)。这里对应算法中的第\\(7-8\\)行，这个observed_dirichlet就是\\(S_i\\)。 1234log_p_hat_train = np.log(observed_dirichlet).mean(axis=0)alpha_sum_approx = calc_approx_alpha_sum(observed_dirichlet)alpha_0 = observed_dirichlet.mean(axis=0) * alpha_sum_approx 之后这部分主要对应算法中的\\(9-11\\)行。作者把所有的第\\(i\\)个变换，分类器的输出的集合（也就是变量observed_dirichlet）记为\\(S_i\\)，\\(\\bar s\\)为\\(S_i\\)的平均，\\(\\bar l\\)为\\(S_i\\)对数的平均（变量log_p_hat_train），初始值\\(\\tilde{\\alpha}_i\\)由\\(\\bar s\\frac{(k-1)(-\\Psi(1))}{\\bar s\\cdot\\log\\bar s-\\bar s\\cdot\\bar l}\\)给出（变量alpha_0）。函数calc_approx_alpha_sum实现的是算法中第\\(11\\)行的\\(\\frac{(k-1)(-\\Psi(1))}{\\bar s\\cdot\\log\\bar s-\\bar s\\cdot\\bar l}\\)，代码如下： 123456def calc_approx_alpha_sum(observations): N = len(observations) f = np.mean(observations, axis=0) return (N * (len(f) - 1) * (-psi(1))) / ( N * np.sum(f * np.log(f)) - np.sum(f * np.sum(np.log(observations), axis=0))) 1mle_alpha_t = fixed_point_dirichlet_mle(alpha_0, log_p_hat_train) 这里对应算法中的\\(12-14\\)行，即重复\\(\\tilde\\alpha_i\\leftarrow\\Psi^{-1}\\left(\\Psi(\\sum_j[\\alpha_i]_j)+\\bar l\\right)\\)来估计\\(\\alpha\\)，函数fixed_point_dirichlet_mle代码如下： 12345678def fixed_point_dirichlet_mle(alpha_init, log_p_hat, max_iter=1000): alpha_new = alpha_old = alpha_init for _ in range(max_iter): alpha_new = inv_psi(psi(np.sum(alpha_old)) + log_p_hat) if np.sqrt(np.sum((alpha_old - alpha_new) ** 2)) &lt; 1e-9: break alpha_old = alpha_new return alpha_new \\(\\Psi^{-1}(\\cdot)\\)是通过数值方法来估计的： 12345678def inv_psi(y, iters=5): # initial estimate cond = y &gt;= -2.22 x = cond * (np.exp(y) + 0.5) + (1 - cond) * -1 / (y - psi(1)) for _ in range(iters): x = x - (psi(x) - y) / polygamma(1, x) return x 最后，在得到对\\(\\alpha\\)的估计之后，可以来计算测试样本的分数了。这里对应的是算法中的第\\(16\\)行。 123x_test_p = mdl.predict(transformer.transform_batch(x_test, [t_ind] * len(x_test)), batch_size=1024)scores += dirichlet_normality_score(mle_alpha_t, x_test_p) 函数dirichlet_normality_score代码如下： 12def dirichlet_normality_score(alpha, p): return np.sum((alpha - 1) * np.log(p), axis=-1) Experiments Baselines 文中用到了如下的Baseline： One-class SVM. 单类支持向量机，作者使用了三个变体，分别为RAW-OC-SVM——使用原始数据作为输入，CAE-OC-SVM——使用一个卷积自编码器来获得低维表示作为输入和E2E-OC-SVM——全名为One-Class Deep Support Vector Data Description； Deep structured energy-based models. Deep Autoencoding Gaussian Mixture Model. Generative Adversarial Networks. Datasets 文中用到了一下几个数据集： CIFAR-10 CIFAR-100 Fashion-MNIST CatsVsDogs 在实验中所有图片都被归一化到\\([-1,1]\\)的范围。 Experimental Protocol 设数据集有\\(C\\)个类，我们会进行\\(C\\)次实验，在第\\(c\\)次实验 (\\(1\\leq c \\leq C\\))中我们会将第\\(c\\)个类作为正常样本，而其他类作为异常样本。在训练阶段，训练集只包含正常样本，而在测试阶段则会有正常样本和异常样本。在获得异常分数之后，阈值\\(\\lambda\\)则根据ROC曲线下面积选择。 实验中使用的几何变换基于以下三种基变换： Horizontal flip: 记为\\(T_b^{flip}(x)\\)，\\(b\\in\\{T,F\\}\\)代表是否翻转； Translation: 记为\\(T_{s_h,s_w}^{trans}(x)\\)，其中\\(s_h,s_w\\in\\{-1,0,1\\}\\)。在长宽两个维度上位移分别为\\(0.25\\)高度和\\(0.25\\)宽度，这两个维度发生位移的方向由\\(s_h\\)和\\(s_w\\)决定，当\\(s_h=s_w=0\\)时代表不移动； Rotation by multiples 90 degrees: 记为\\(T_k^{rot}(x)\\)，\\(k\\in\\{0,1,2,3\\}\\)。旋转\\(k\\times90\\)度。 将三种基变换叠加有： \\[ \\mathcal T=\\left\\{ T_k^{rot}\\circ T_{s_h,s_w}^{trans}\\circ T_b^{flip} : \\begin{matrix} b &amp;\\in \\{T,F\\}\\\\ s_h,s_w&amp;\\in\\{-1,0,1\\}\\\\ k&amp;\\in\\{0,1,2,3\\} \\end{matrix} \\right\\} \\] 最终几何变换种数为\\(2\\times3\\times3\\times4=72\\)种。 分类器模型使用的是Wide Residual Network，优化器为Adam，Batch size为128，训练轮数为200。 Results 下面是不同方法在不同数据集上的实验结果： 评测标准使用的是AUROC。作者关于结果的分析主要有以下几点： 在绝大多数情况下，我们的算法都比Baseline要好，而且是越大的数据集效果越好。CatsVsDogs数据集每张图片的大小比其他几个数据集都要大，而Baseline在这个数据集上的结果都在\\(50\\%\\)或不到\\(50\\%\\)，这基本等同于瞎猜； 在CIFAR-100数据集里，由于将这100类聚合为了20类，所以存在类内样本差异大的问题。比如在类\\(5\\)、类\\(7\\)和类\\(13\\)上，模型表现就不够好； 在Fashion-MNIST数据集上几乎所有方法（除了DAGMM）都表现很好。 On the Intuition for Using Geometric Transformations 这里作者对所选用的几何变换做了一些解释。实验中选用的三种基本几何变换都是可逆的线性几何变换（且为双射），作者也试过一些复杂的非线性变换，如高斯模糊、锐化、伽马校正等等，但是效果并不好。 作者认为分类器能够分辨不同变换的能力与最终性能成正比，为了验证这一点，进行了\\(3\\)个实验。从MNIST数据集选择一个数字作为正常样本，几何变换只采用两个，然后选择另一个数字作为异常样本，结果如下： Normal digit: 8，Anomaly: 3，Transformations: Identity and horizontal flip. 由于数字\\(8\\)是对称的，所以要让分类器分辨原始的\\(8\\)和翻转之后的\\(8\\)是很难的，AUROC只有\\(0.646\\)； Normal digit: 3，Anomaly: 8，Transformations: Identity and horizontal flip. 这里把\\(3\\)作为正常样本，由于\\(3\\)不是对称的，所以两种变换是可以分辨的，AUROC达到了\\(0.957\\)； Normal digit: 8，Anomaly: 3，Transformations: Identity and translation by 7 pixels. 同样是把\\(8\\)作为正常样本，但变换用的是平移，AUROC达到了\\(0.919\\)。 除此之外，作者还设计了一个实验，目的是测试什么样的图像会获得较高的分数\\(n_S(x)\\)。在给定训练好的分类器的情况下，优化输入的图像，目标函数是最大化分数\\(n_S(x)\\)。下图为实验结果： 在左图中，将数字\\(3\\)作为正常样本训练的分类器、原始输入为数字\\(0\\)的图片时，随着优化的进行，图片慢慢地变得像数字\\(3\\)。在右图中，同样是将数字\\(3\\)作为正常样本训练的分类器，不过原始输入也是数字\\(3\\)，这时图像却没有怎么变化。 Remark 文中提到的在CIFAR100数据的实验上，由于类间差异比较大导致效果较差，那么很自然地，不同的变换样本对应的集簇实际上应当足够分开，集簇内的样本要足够进，这样对于分类器来说才能比较好的分类。不过采用的几何变换并没有针对这一点进行特别设计； 文中强调了所使用的变换为几何变换，其实除此之外，所使用的变换还都是可以用矩阵表示的可逆的变换。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"Cross-dataset Time Series Anomaly Detection for Cloud Systems","slug":"Cross-dataset-Time-Series-Anomaly-Detection-for-Cloud-Systems","date":"2020-06-01T08:14:08.000Z","updated":"2020-06-25T05:28:22.135Z","comments":true,"path":"2020/06/01/Cross-dataset-Time-Series-Anomaly-Detection-for-Cloud-Systems/","link":"","permalink":"http://qfxiao.me/2020/06/01/Cross-dataset-Time-Series-Anomaly-Detection-for-Cloud-Systems/","excerpt":"","text":"Introduction 本文介绍了一种用于云计算平台的时间序列异常检测框架。为了解决标签不足的问题，文中使用了迁移学习的方法，即在有标签的source domain上训练模型，在没有标签的target domain上检测。同时，文中还使用了主动学习的方法来挑选最有价值的无标签样本进行标记。 📰Get Paper Background 针对云计算平台数据的异常检测通常是应用在云监控数据，如KPI、CPU使用率、系统负载等时序数据上。和传统的异常检测不一样的是，时序异常检测往往更难，文中总结了以下几个挑战： 异常特征的差异性。在不同的云服务系统中，对异常的容忍度是不同的，所以对每个场景或系统组件设置准确的阈值来进行异常检测是十分困难的； 时间依赖性。该异常检测问题处理的是时间序列数据，而传统的异常检测并不会考虑时间依赖性； 无监督学习的性能问题。无监督的异常检测方法的性能有限，会带来大量的误报； 有监督学习需要大量标签。 Proposed Approach 为了解决上述挑战，文中提出了一个时间序列异常检测框架ATAD (Active Transfer Anomaly Detection)。该框架结合了迁移学习技术和主动学习技术，示意图如下： 未标记数据\\(T_u\\)是我们要检测的目标数据 (target domain)，标记数据\\(T_l\\)是我们的源数据 (source domain)，可以是开源数据或者是其他系统的监控数据。 Transfer Learning Component 在应用迁移学习时，我们需要考虑以下几个因素： 我们处理的是时间序列数据，即在不同的时间点上样本之间不是相互独立的。为了解决这个问题，我们提取了不同的特征，每一个时间点被转换为了高维的特征向量，且每个时间点附近的背景信息被保存在了特征向量之中； 时间序列的粒度。粗粒度的迁移学习不利于发现异常，本文采用细粒度，即数据点级别的迁移学习； 迁移学习需要source domain和target domain具有潜在的相似性，所以我们需要对source domain中的样本进行过滤。 Feature Identification 这一节描述特征工程中用到的特征。在提取特征之前，文中使用了离散傅里叶变换来识别时间序列的周期\\(p\\)，并为后面滑动窗口的大小原则作参考。 Statistical Features 统计特征包含了一些基本的统计信息，如均值、方差等，用到的特征如下表所示： 表中的统计特征都是基于大小等于周期\\(p\\)的滑动窗口的。 Forecasting Error Features 使用预测特征的理由是如果一个数据点偏离预测值很远，那么它很有可能是异常。文中使用了多种时间序列预测模型，如SARIMA、Holt、Holt-Winters、STL等。最终的预测结果使用下式来加权集成： \\[ \\hat{Y}_t=\\sum\\limits_{m=1}^{M}\\frac{\\hat{Y}_{m,t}}{M-1}\\left(1-\\frac{RMSE_{m,t}}{\\sum\\limits_{n=1}^M RMSE_{n,t}}\\right) \\] \\(M\\)代表\\(M\\)个不同模型，\\(RMSE_{m,t}\\)代表模型\\(m\\)在时间\\(t\\)的\\(RMSE\\)，\\(\\hat{Y}_t\\)是在时间\\(t\\)的最终预测结果。之后，使用下表中的Metrics来计算不同预测特征： 同样的，上述特征都是基于窗口的。 Temporal Features 这一部分是一些时间序列相关特征： 最后，总共提取了37个特征，并且每个特征都进行了正则化。 The Transfer between Source Domain and Target Domain 本文结合了基于实例的迁移学习(Instance-based Transfer Learning)和基于特征的迁移学习(Feature-based Transfer Learning)。 首先，source domain中的数据差异性是比较大的，所以我们需要选择与target domain相似的样本。 基于实例的迁移学习(Instance-based Transfer Learning)的思想是选择source domain中与target domain相似的样本。对于source domain，在将时间序列\\(T_l\\)转换为特征\\(F_l\\)之后，本文使用\\(K-means\\)算法将\\(F_l\\)分成若干个簇。每个簇\\(F_l^i, i\\in[1,K]\\)是\\(F_l\\)的不重叠子集。为了选择合适的样本，我们计算了target domain中的样本和每个簇中心点的欧几里得距离，然后样本会和距离最近的簇\\(F_l^i\\)联系起来。 之后，为了使source domain和target domain在特征空间的差别更小，作者在每个簇上使用了CORrelation ALignment (CORAL) 算法。CORAL是一种领域适应算法 (Domain Adaption)，其基本思想是对source domain和target domain进行线性变换使其二阶统计信息（即协方差矩阵）的差别最小化： \\[ \\min_A\\parallel A^\\top C^i_lA-C^i_u\\parallel_F^2 \\] 在最后一步，作者在每一个sub source domain \\(\\hat{F}_l^i\\)训练了有监督模型（随机森林或SVM），所以最后我们得到了\\(K\\)个基模型。 Active Learning Component 由于数据的差异性和复杂性太大，仅仅使用迁移学习的技术不足以达到很好的效果。在ATAD中，作者使用了主动学习技术来用较少的成本标注最有价值的样本来提升性能。本文中使用基于Uncertainty和Context Diversity的主动学习。 Uncertainty 大多数主动学习算法使用不确定性 (Uncertainty) 来作为选择要标记的样本的准则。 \\[ Uncertainty=-|Prob(Normal)-Prob(Anomaly)| \\] 其中的\\(Prob\\)由基模型给出。 Context Diversity 多样性 (Diversity) 也是一个选择要标记样本的重要参考。如果有两个相似的样本，那么就没有必要将他们都标记。 时间上相邻的样本往往也是相似的。 具体的来说，我们对所有样本按照Uncertainty排序，然后进行一次扫描，如果当前样本在候选集中某个样本的Context之中，我们则忽略当前样本，因为这代表当前样本和候选集中的那个样本是相似的。如果不在Context之中，我们则将该样本加入候选集中。 判断是否在某个样本的Context中，如下图所示，直接判断是否落在区间\\([t-\\alpha,t+\\alpha]\\)中就是了。 主动学习模块的算法流程图如下图所示： Experiments 在实验部分，作者试图回答以下问题： ATAD的效果如何？ 迁移学习模块的有效性如何？ 主动学习模块的有效性如何？ ATAD在基于公开数据时对公司内部数据检测效果如何？ Dataset and Setup 下表是用到的数据集的一些基本信息： Evaluation Metric 评测标准使用的是F1-score： \\[ F1=\\frac{2\\cdot P\\cdot R}{P+R}, \\space P=\\frac{TP}{TP+FP}, \\space R=\\frac{TP}{TP+FN} \\] Results RQ1: How effective is ATAD? Baseline包括孤立森林、K-Sigma、S-H-ESD和随机森林。 最终结果如下表所示： 为了评测ATAD利用标签的能力，我们比较了RF在达到和ATAD相似F1 score情况下所需标签的数量，如下表所示： RQ2: How effective is the Transfer Learning Component? 我们从以下两个方面来探究模型迁移知识的能力： 使用文中所用到的特征的重要性 本模型迁移知识的能力 对于第一点，作者提出传统的方法一般只提取了统计特征，而本文还提取了多种其他特征。作者对提取不同特征进行了比较试验，结果如下表所示： 除此之外，作者还展示了不同数据集下前10有效的特征： 对于第二点，作者比较了是否使用文中的领域适应算法CORAL，在达到相似F1 score下所需的标签数，如下表所示： RQ3: How effective is the Active Learning component? 为了验证本文所用的主动学习的有效性，作者进行了对比试验。第一个模型 (Supervised model) 使用全部标签但不使用迁移学习训练，第二个 (Naïve) 为只使用主动学习而不使用迁移学习，第三个为本文提出的模型。结果如下图所示，为了达到相似的性能，不同模型需要的标签数。 下表展示了使用不同主动学习策略 (U - conventional uncertainty method, UCD - 本文使用的方法, random - 随机选择) 进行标记得到的结果： 同时作者还对不同\\(\\alpha\\)的选择进行了实验： RQ4: How effective is ATAD in detecting anomalies in a company’s local dataset based on public datasets? 这里作者对比了不同方法在微软内部数据集上的结果：","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"Transfer Learning","slug":"Transfer-Learning","permalink":"http://qfxiao.me/tags/Transfer-Learning/"}]},{"title":"Learning Representations of Ultrahigh-dimensional Data for Random Distance-based Outlier Detection","slug":"Learning-Representations-of-Ultrahigh-dimensional-Data-for-Random-Distance-based-Outlier-Detection","date":"2020-05-06T03:05:37.000Z","updated":"2020-06-25T08:15:23.573Z","comments":true,"path":"2020/05/06/Learning-Representations-of-Ultrahigh-dimensional-Data-for-Random-Distance-based-Outlier-Detection/","link":"","permalink":"http://qfxiao.me/2020/05/06/Learning-Representations-of-Ultrahigh-dimensional-Data-for-Random-Distance-based-Outlier-Detection/","excerpt":"","text":"Introduction 本文提出了一种针对高维数据异常检测的表示学习方法。文中提出了RAMODO框架，一种基于排序的结合表示学习和异常检测的无监督框架。除此之外，基于RAMODO，文中还提出了基于此框架的模型REPEN。 Paper📰 Proposed Method The Proposed Framework: RAMODO Problem Statement 我们的目的是为高维数据学习低维表示，同时在学到的低维表示中能够更好地进行异常检测。设有数据集\\(\\mathcal{X}=\\{\\mathbf x_1,\\mathbf x_2,\\cdots, \\mathbf x_N\\}\\) (\\(\\mathbf x_i\\in \\mathbb{R}^D\\)) 和一个基于随机距离的异常检测器\\(\\phi:\\mathcal{X}\\mapsto \\mathbb{R}\\)，我们的目标是学习一个表示函数\\(f:\\mathcal{X}\\mapsto\\mathbb{R}^M (M\\ll D)\\)使得对于所有异常样本\\(\\mathbf x_i\\)和正常样本\\(\\mathbf x_j\\)都有\\(\\phi(f(\\mathbf x_i))&gt;\\phi(f(\\mathbf x_j))\\)。 Ranking Model-based Representation Learning Framework RAMODO基于pairwise ranking model。第一步是通过一定的预处理算法（原文中称为outlier thresholding）将数据划分为inlier候选集和outlier候选集；第二步通过随机从inlier候选集采样\\(n\\)个样本生成query set \\((\\mathbf x_i,\\cdots,\\mathbf x_{i+n-1})\\)，从inlier候选集采样一个样本生成positive example \\((\\mathbf x^+)\\)，从outlier候选集采样一个样本生成negative example \\((\\mathbf x^-)\\)，将三者组合生成 metatriplet \\(T=(&lt;\\mathbf x_i,\\cdots,\\mathbf x_{i+n-1}&gt;,\\mathbf x^+,\\mathbf x^-)\\)；第三步通过神经网络\\(f\\)学习表示；第四步通过outlier score-based ranking loss \\(L(\\phi(f(\\mathbf x^+)|&lt;f(\\mathbf x_i),\\cdots,f(\\mathbf x_{i+n-1})&gt;),\\phi(f(\\mathbf x^-)|&lt;f(\\mathbf x_i),\\cdots,f(\\mathbf x_{i+n-1})&gt;))\\)来进行优化，其中\\(\\phi(\\cdot|\\cdot)\\)为基于距离的异常检测器。 A RAMODO Instance: REPEN REPEN为RAMODO的实例模型，使用Sp作为异常检测器。 Outlier Thresholding Using State-of-the-art Detectors and Cantelli's Inequality 第一步使用Sp作为基础获得初始anomaly score： Definition 1 (Sp-based Outlier Scoring). 给定样本\\(x_i\\)，Sp 以以下方式定义该样本的异常程度： \\[ r_i=\\frac{1}{m}\\sum\\limits_{j=1}^m nn\\_dist(\\mathbf x_i|\\mathcal{S}_j) \\] 其中\\(\\mathcal S_j\\subset \\mathcal X\\)为数据集随机采样的子集，\\(m\\)为集成大小，\\(nn_dist(\\cdot|\\cdot)\\)为\\(\\mathcal S_j\\)中最近邻居的距离。 接着通过Cantelli's Inequality来定义Pseudo Outlier： Definition 2 (Cantelli's Inequality-based Outlier Thresholding). 给定异常分数向量\\(\\mathbf r\\in\\mathbb R^N\\)，更高异常分数代表更高的可能性为异常，设\\(\\mu\\)和\\(\\delta^2\\)分别为均值和方差，Outlier候选集由以下方式确定： \\[ \\mathcal{O}=\\{\\mathbf x_i|r_i \\geq \\mu + \\alpha\\delta\\}, \\space\\forall \\mathbf x_i\\in\\mathcal X, \\space r_i\\in\\mathbf r \\] 其中\\(\\alpha\\geq 0\\)为自定义的阈值。 Inlier候选集\\(\\mathcal I=\\mathcal X\\backslash \\mathcal O\\)。 Triplet Sampling Based on Outlier Scores 首先，从\\(\\mathcal I\\)采样一定数量的样本组成query set，每个样本被采样的概率与其对应的异常分数有关： \\[ p(\\mathbf x_i)=\\frac{\\mathbb Z-r_i}{\\sum_{t=1}^{|\\mathcal I|}[\\mathbb Z-r_t]} \\] 其中\\(\\mathbb Z=\\sum_{t=1}^{|\\mathcal I|}r_t\\)。 之后从inlier set中均匀随机采样一个positive sample \\(\\mathbf x^+\\)。最后从outlier set中根据以下概率采样一个negative sample \\(\\mathbf x^-\\)： \\[ p(\\mathbf x_j)=\\frac{r_j}{\\sum_{t=1}^{|\\mathcal O|}r_t} \\] A Shallow Data Representation 单层神经网络用来获得浅层的表示： Definition 3 (Single-layer Fully-connected Representations) 给定输入\\(x\\)， \\[ f_\\Theta(\\mathbf x)=\\{\\psi(\\mathbf w_1^\\top\\mathbf x),\\psi(\\mathbf w_2^\\top\\mathbf x),\\cdots,\\psi(\\mathbf w_M^\\top\\mathbf x)\\} \\] 其中\\(\\psi(\\cdot)\\)为激活函数，\\(\\mathbf w\\)为权重矩阵。 Ranking Loss Using Random Nearest Neighbor Distance-based Outlier Scores 设\\(\\mathcal{Q}=&lt;f_\\Theta(\\mathbf x_i),\\cdots,f_\\Theta(\\mathbf x_{i+n-1})&gt;\\)为query set，给定样本\\(\\mathbf x\\)，REPEN根据最近邻距离定义了\\(f_\\Theta(\\mathbf x)\\)的异常程度： \\[ \\phi(f_\\Theta(\\mathbf x)|\\mathcal{Q})=nn\\_dist(f_\\Theta(\\mathbf x)|\\mathcal Q) \\] 因此，给定三元组\\(T=(\\mathcal Q,f_\\Theta(\\mathbf x^+),f_\\Theta(\\mathbf x^-))\\)，我们的目标是学得表示\\(f(\\cdot)\\)使得： \\[ nn\\_dist(f_\\Theta(\\mathbf x^+)|\\mathcal Q)&lt;nn\\_dist(f_\\Theta(\\mathbf x^-)|\\mathcal Q) \\] 损失函数： \\[ J(\\Theta;T)=L(\\phi(f_\\Theta(\\mathbf x^+)|\\mathcal Q),\\phi(f_\\Theta(\\mathbf x^-)|\\mathcal Q))=\\\\\\max\\{0, c+nn\\_dist(f_\\Theta(\\mathbf x^+)|\\mathcal Q)-nn\\_dist(f_\\Theta(\\mathbf x^-)|\\mathcal Q)\\} \\] 其中\\(c\\)为边界参数。给定一系列三元组，最终优化目标如下： \\[ \\mathop{\\text{arg min}}\\limits_{\\Theta}\\frac{1}{|\\mathcal{T}|}\\sum\\limits_{i=1}^{|\\mathcal T|}J(\\Theta;T_i) \\] The Algorithm and Its Time Complexity Leveraging A Few Labeled Outliers to Improve Triplet Sampling Experiments Datasets AD：网络广告检测 LC：肺癌疾病监测 p53：异常蛋白质活动检测 R8：文本分类 News20：文本分类 URL：异常网址检测 Webspam：Pascal Large Scale LearningChallenge Effectiveness in Real-world Data with Thousands to Millions of Features 作者分别使用原始特征和REPEN学到的特征进行异常检测，IMP代表性能提升比例，SU代表加速比例。 Comparing to State-of-the-art Representation Learning Competitors AE: 自编码器 HLLE: Hessian Locally Linear Embedding SRP: Sparse Random Projection CoP: Coherent Pursuit The Capability of Leveraging Labeled Outliers as Prior Knowledge Sensitivity Test w.r.t. the Representation Dimension 文中提到了对于R8、URL、News20这三个数据集在维度\\(M=1\\)的时候表现和其他维度一样好，作者给出的解释是在这几个数据集中异常部分是线性可分的，所以1维就足够了，另一个解释是优化问题。 Scalability Test","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"Representation Learning","slug":"Representation-Learning","permalink":"http://qfxiao.me/tags/Representation-Learning/"}]},{"title":"Deep Weakly-supervised Anomaly Detection","slug":"Deep-Weakly-supervised-Anomaly-Detection","date":"2020-03-29T16:17:24.000Z","updated":"2020-06-25T05:33:35.419Z","comments":true,"path":"2020/03/30/Deep-Weakly-supervised-Anomaly-Detection/","link":"","permalink":"http://qfxiao.me/2020/03/30/Deep-Weakly-supervised-Anomaly-Detection/","excerpt":"","text":"Introduction 在文献中，因为标注成本的昂贵，无监督方法占据了异常检测的主要位置。然而，在现实生活中，我们可能会有少量标签，如何利用这部分标签信息就成为了一个问题，作者将其称之为anomaly-informed modeling。作者提出了两点挑战： 少量标签可能无法提供所有类型异常的信息； 大部分无标签数据为正常样本，但其中包含少部分异常（污染）。 作者提出了基于pairwise relation learning的方法来解决这些问题。文章的主要贡献如下： 提出了一种基于pairing-based data augmentation和ordinal regression来进行弱监督异常检测的框架 基于该框架提出了PReNet，一种基于双流ordinal regression的网络 从理论和实践角度分析了方法的有效性 在40个真实数据集上进行了完善的实验 Proposed Method Learning Anomaly Scores by Predicting Pairwise Relation Problem Formulation 给定数据集\\(\\mathcal{X}=\\{\\mathbf{x}_1,\\mathbf {x}_2,\\cdots,\\mathbf{x}_N,\\mathbf{x}_{N+1},\\cdots,\\mathbf{x}_{N+K}\\}\\)，包含两部分，一部分是五标签数据\\(\\mathcal{U}=\\{\\mathbf{x}_1,\\mathbf {x}_2,\\cdots,\\mathbf{x}_N\\}\\)，另一部分是有标签异常数据\\(\\mathcal{A}=\\{\\mathbf{x}_{N+1},\\cdots,\\mathbf{x}_{N+K}\\}\\)，其中\\(K\\ll N\\)。我们的任务目标是学习一个打分函数\\(\\phi:\\mathcal{X}\\mapsto \\mathbb{R}\\)，使得对任任意异常样本的打分高于任意正常样本。 在这个Formulation里，作者将关系学习和异常打分统一了起来。首先，输入的数据集不再是原始样本，而是样本对。样本对包含三种：anomaly-anomaly，anomaly-unlabeled，unlabeled-unlabeled，记为\\(C_{\\{\\mathbf{a},\\mathbf{a}\\}}\\)，\\(C_{\\{\\mathbf{a},\\mathbf{u}\\}}\\)，\\(C_{\\{\\mathbf{u},\\mathbf{u}\\}}\\)。每一个样本对包含一个标签\\(y\\)，表示该pair对应的异常分数，整个输入数据集\\(\\mathcal{P}=\\{\\{\\mathbf{x}_i,\\mathbf{x}_j,y_{ij}\\}|\\mathbf{x}_i,\\mathbf{x}_j\\in\\mathcal{X} \\space\\text{and}\\space y_{ij}\\in\\mathbb{N}\\}\\)。因为有\\(y_{\\{\\mathbf a,\\mathbf a\\}}&gt;y_{\\{\\mathbf a,\\mathbf u\\}}&gt;y_{\\{\\mathbf u,\\mathbf u\\}}\\)，所以对关系的学习也是对异常打分的学习。 The Instantiated Model: PReNET 下图为模型示意图，Data Augmentation模块负责产生pair数据，End-to-End Anomaly Score Learner \\(\\phi\\) 模块负责关系学习（异常打分）。 Data Argumentation by Pairing 数据的产生分为两步： 从\\(\\mathcal{A}\\)和\\(\\mathcal{U}\\)上随机采样，组成pair； 对每个pair打上次序(ordinal class feature) 标签\\(\\mathbf{y}\\)。 部分\\(C_{\\{\\mathbf{a},\\mathbf{u}\\}}\\)和\\(C_{\\{\\mathbf{u},\\mathbf{u}\\}}\\)可能包含异常污染，因为在\\(\\mathcal{U}\\)中可能会有未标记的异常样本。 End-to-End Anomaly Score Learner 令\\(\\mathcal{Z}\\in\\mathbb{R}^M\\)为中间表示空间，那么Score Learner可以拆解为特征学习\\(\\psi(\\cdot;\\Theta_r):\\mathcal{X}\\mapsto \\mathcal{Z}\\)和打分函数\\(\\eta((\\cdot,\\cdot);\\Theta_s):(\\mathcal{Z},\\mathcal{Z})\\mapsto\\mathbb{R}\\)两部分，两部分都由神经网络组成。 Ordinal Regression 损失函数定义为： \\[ L\\left(\\phi((\\mathbf x_i,\\mathbf x_j);\\Theta),y_{ij}\\right)=|y_{ij}-\\phi((\\mathbf x_i,\\mathbf x_j);\\Theta)| \\] 采用绝对值而不是均方误差的原因是为了减少异常污染的影响。默认\\(y_{\\{\\mathbf a,\\mathbf a\\}}=8\\)，\\(y_{\\{\\mathbf a,\\mathbf u\\}}=4\\)，\\(y_{\\{\\mathbf u,\\mathbf u\\}}=0\\)。最后的优化函数可以写为： \\[ \\mathop{\\text{argmin}}\\limits_{\\Theta}\\frac{1}{|\\mathcal{B}|}\\sum\\limits_{\\{\\mathbf x_i,\\mathbf x_j, y_{ij}\\}\\in\\mathcal{B}}|y_{ij}-\\phi((\\mathbf x_i,\\mathbf x_j);\\Theta)|+\\lambda R(\\Theta) \\] \\(\\mathcal{B}\\)为一个batch，\\(R(\\Theta)\\)为正则项。 Anomaly Detection Using PReNet Training Stage 训练流程如下图所示： 为了保证训练样本类别的平衡，\\(\\frac{|\\mathcal{B}|}{2}\\)的样本采样自\\(C_{\\{\\mathbf u,\\mathbf u\\}}\\)，采样自\\(C_{\\{\\mathbf a,\\mathbf u\\}}\\)和\\[C_{\\{\\mathbf a,\\mathbf a\\}}\\]的样本都占\\(\\frac{|\\mathcal{B}|}{4}\\)。 Anomaly Scoring Stage 在测试阶段，给定测试样本\\(\\mathbf{x}_k\\)，先分别从\\(\\mathcal{A}\\)和\\(\\mathcal{U}\\)采样，然后定义以下anomaly score： \\[ s_{\\mathbf{x}_k}=\\frac{1}{2E}\\left[\\sum\\limits_{i=1}^E\\phi((\\mathbf a_i,\\mathbf x_k);\\Theta^*)+\\sum\\limits_{j=1}^E\\phi((\\mathbf x_k,\\mathbf u_j);\\Theta^*)\\right] \\] \\(\\mathbf a_i\\)和\\(\\mathbf u_j\\)为随机采样得到的异常样本和正常样本，采样大小\\(E\\)默认为30。 Experiments 实验部分主要是回答以下四个问题： 在有限的标签异常情况下，PReNet能否有效地检测已知和未知的异常； 在不同数量标签异常的情况下，PReNet的表现如何； PReNet对异常污染的鲁棒性如何； PReNet不同组件的重要性如何。 Datasets 实验一共用到了40个数据集，其中12个用来评测算法检测已知的异常的能力（如Table 2所示），28个用来评测算法检测未知的异常的能力（如Table 3所示）。 Competing Methods and Parameter Settings 用到的baseline有以下几个： DevNet：同一作者在KDD2019提出的异常检测框架 Deep support vector data description (DSVDD)：深度支持向量数据描述 Prototypical network： few-shot classification中的一种模型 iForest：孤立森林 Performance Evaluation Metrics 用到的Metrics为AUC-ROC和AUC-PR。 Detection of Known Anomalies 在本实验中，异常污染的比例（2%）和有标记异常样本的数量（60）是固定的，下表为实验结果： Detection of Unknown Anomalies 在本实验中，异常污染的比例（2%）和有标记异常样本的数量（60）同样是固定的，下表为实验结果： Availability of Known Anomalies 本实验主要是研究不同数量标注异常样本的条件下，算法的性能如何。异常污染的比例固定（2%），标注异常的数量从15到120变化。实验结果如下： Further Analysis of PReNet Tolerance to Anomaly Contamination in Unlabeled Data 本实验主要研究不同异常污染比例下，算法的性能，即探究算法对异常污染的鲁棒性。标注异常样本的数量恒定（60），异常污染比例在\\(\\{0\\%,2\\%,5\\%,10\\%\\}\\)中变化。实验结果如下所示： Ablation Study 这一节是消融实验，分别设置了四个变体： BOR: 损失函数替换成了二值回归Binary Ordinal Regression； OSNet: 将双流结构简化为单流； LDM: 将网络中的隐藏层去除； A2H: 加入了额外的隐藏层，并且加入了\\(\\ell_2\\)-norm防止过拟合。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"Discovering Physical Concepts with Neural Networks","slug":"Discovering-Physical-Concepts-with-Neural-Networks","date":"2020-03-01T14:55:02.000Z","updated":"2020-06-25T05:35:20.215Z","comments":true,"path":"2020/03/01/Discovering-Physical-Concepts-with-Neural-Networks/","link":"","permalink":"http://qfxiao.me/2020/03/01/Discovering-Physical-Concepts-with-Neural-Networks/","excerpt":"","text":"Introduction 如题目所示，本文的目的是利用神经网络来发掘物理概念。其思路是从实验数据学到表示，然后用学到的表示来回答物理问题，由此物理概念可以从学到的表示来提取出。作者进行了4个实验： 在阻尼振动实验中，模型学到了相关的物理参数； 在角动量守恒实验中，模型预测了质点的运动； 给定量子系统的观测数据，模型正确的识别出了量子状态的自由度； 给定从地球观测的太阳和火星的位置时间序列数据，模型发现了日心说模型。 Preliminaries 作者在附录中对神经网络的基础知识进行了介绍，这里不再赘述，只截取了一些相对前沿的内容。 Variational Autoencoders 本文用到的模型基础是VAE： Representation Learning Representation learning的主要目标是将数据映射到一个隐向量 (encoder)，为了保证隐向量包含了所有相关信息， 那么应该能够从隐向量还原原数据 (decoder)。传统的Autoencoder是这个思想的最简单实现，而VAE则将AE和Variational Inference结合了起来，是一种经典的生成式模型。现在很多研究关注Disentangled Representation Learning，也就是说我们希望模型能够无监督地学习数据，从中学到有意义的表示。 \\(\\boldsymbol \\beta\\)-VAE \\(\\beta\\)-VAE是一种特殊的VAE，也是一个经典的Disentangled Representation Learning模型，它和VAE主要的区别是对KL散度一项加上了权重\\(\\beta\\)进行调节： \\[ C_\\beta(x)=-\\left[\\mathbb{E}_{z\\sim p_\\phi(z|x)}\\log p_\\theta(x|z)\\right] + \\beta D_\\text{KL}\\left[p_\\phi(z|x)\\parallel h(z)\\right] \\] 如果假设\\(p_\\phi(z|x)=\\mathcal{N}(\\mu,\\sigma)\\)，那么损失函数可以进行简化： \\[ C_\\beta(x)=\\parallel \\hat{x} - x \\parallel^2_2-\\frac{\\beta}{2}\\left(\\sum\\limits_i\\log(\\sigma_i^2)-\\mu_i^2-\\sigma_i^2\\right)+C \\] Network Structure Network Structure: SciNet 模仿物理学家建模物理问题的过程，作者提出了SciNet，如下图所示： 物理学家在建模物理问题的时候，往往是从一些实验数据出发，根据物理常识提取更加精练的表示，然后用学到的表示来回答物理问题。 对于单纯的输入输出问题，SciNet可以看作是一个映射，\\(F:\\mathcal{O}\\times\\mathcal{Q}\\rightarrow\\mathcal{A}\\)。\\(\\mathcal{O}\\)是可能的实验数据集合，\\(\\mathcal{Q}\\)是可能的问题集合，\\(\\mathcal{A}\\)是可能的答案集合。可以将其分为两个步骤：编码过程\\(E:\\mathcal{O}\\rightarrow\\mathcal{R}\\)从实验数据学到表示，解码过程\\(D:\\mathcal{R}\\times \\mathcal{Q}\\rightarrow \\mathcal{A}\\)根据给定的问题从表示来回答问题。由此，\\(F(o,q)=D(E(o),q)\\)。在实现方面，SciNet采用的是全连接网络。 Training and Testing SciNet 用来训练的数据形式为\\((o,q,a_{cor}(o,q))\\)，观测\\(o\\)和问题\\(q\\)分别从观测集\\(\\mathcal{O}\\)和问题集\\(\\mathcal{Q}\\)选出，\\(a_{cor}(o,q)\\)为对应的正确答案。在训练过程中，我们希望准确度尽量高，并且学到minimal uncorrelated representations。为此，作者采用disentangling variational autoencoder作为模型。 Results 在文中，作者进行了4个实验来验证模型的有效性。 Damped Pendulum 阻尼振动实验： 任务：预测一维阻尼振动在不同时间的位置。 物理模型：\\(-kx-b\\dot{x}=m\\ddot{x}\\)，\\(k\\)为弹性模量，\\(b\\)为阻尼系数，通解为\\(x(t)=A_0e^{-\\frac{b}{2m}t}\\cos(\\omega t+\\delta_0), \\space \\omega=\\sqrt{\\frac{k}{m}}\\sqrt{1-\\frac{b^2}{4mk}}\\) 观测数据：位置时间序列数据\\(o=[x(t_i)]_{i\\in\\{1,\\cdots,50\\}}\\in\\mathbb{R}^{50}\\)，时间间隔相等，质量\\(m=1\\text{kg}\\)，振幅\\(A_0=1\\text{m}\\)，相位\\(\\delta_0=0\\)，弹性模量\\(k\\in[5,10]\\text{kg}/\\text{s}^2\\)，阻尼系数\\(b\\in[0.5,1]\\text{kg}/\\text{s}\\)。 问题：预测\\(q=t_\\text{pred}\\in\\mathbb{R}\\) 隐变量大小设置为3，结果如下图所示： (b)中的三幅图分别是学到的三个隐变量和我们感兴趣的参数\\(k\\)和\\(b\\)的关系图。第一幅图中变量\\(1\\)与\\(b\\)几乎完全线性相关，与\\(k\\)基于线性无关，变量\\(2\\)只和\\(k\\)相关。变量\\(3\\)几乎为一个常数，故不提供额外的信息。由此作者认为SciNet学到了我们关心的两个参数的知识。 Conservation of Angular Momentum 角动量守恒实验： 任务：预测一个由长度为\\(r\\)的绳子捆绑着的旋转质点在位置\\((0,r)\\)经一个自由质点撞击后的位置 物理模型：给定撞击之前的角动量，自由质点撞击之后的速度，旋转质点在撞击之后在时间\\(t_\\text{pred}^\\prime\\)的位置可以由角动量守恒定律给出： \\[ J=m_\\text{rot}r^2\\omega-rm_\\text{free}(\\mathbf{v}_\\text{free})_x=m_\\text{rot}r^2\\omega^\\prime-rm_\\text{free}(\\mathbf{v}^\\prime_\\text{free})_x=J^\\prime \\] 观测数据：在撞击之前两个质点的位置数据\\(o=[(t_i^\\text{rot},q_\\text{rot}(t_i^\\text{rot})),(t_i^\\text{free},q_\\text{free}(t_i^\\text{free}))]_{i\\in\\{1,\\cdots,5\\}}\\)，质量为固定值，半径\\(r\\)也为固定值。数据添加高斯噪声。 问题：预测撞击之后自由质点在时间\\(t_\\text{pred}^\\prime\\)的位置 实验室意图如下： 实验结果表明SciNet能够正确预测质点撞击之后的位置，同时对噪音鲁棒。根据(b)，隐变量和角动量存在线性相关关系，作者认为SciNet学到了守恒的动量这一概念。 Representation of Qubits 量子比特实验： 任务：预测在\\(n=1,2\\)的纯\\(n\\)量子位状态\\(\\psi\\in\\mathbb{C}^{2^n}\\)下任何二进制投影测量\\(\\omega\\in\\mathbb{C}^{2^n}\\)的测量概率。 物理模型：在执行测量\\(\\omega\\in\\mathbb{C}^{2^n}\\)的状态\\(\\psi\\in\\mathbb{C}^{2^n}\\)下测量0的概率\\(p(\\omega,\\psi)\\)由\\(p(\\omega,\\psi)=|\\left&lt;\\omega,\\psi\\right&gt;|^2\\)给定 观测数据：状态\\(\\psi: o=[p(\\alpha_i,\\psi)]_{i\\in\\{i,\\cdots,n_1\\}}\\)的操作参数化：表示一组固定的随机二元射影测量值\\(\\mathcal{M}_1=\\{\\alpha_1,\\cdots,\\alpha_{n_1}\\}\\)（一个量子位\\(n_1 = 10\\)，两个量子位\\(n_1 = 30\\)） 问题：对于固定的一组随机二元射影测量\\(\\mathcal{M}_2=\\{\\beta_1,\\cdots,\\beta_{n_2}\\}\\)，测量\\(\\omega:q=[p(\\beta_i,\\omega)]_{i\\in\\{1,\\cdots,n_2\\}}\\)的Operational参数化（一个量子位\\(n_2 = 10\\)，两个量子位\\(n_2 = 30\\)） 实验结果如下： 通过实验发现，SciNet可以在不提供先验物理知识的条件下确定表述状态\\(\\psi\\)最小的参数数量。同时，SciNet还能分辨tomographically complete和tomographically incomplete。 Heliocentric Model of the Solar System 日心说模型： 问题：在给定初始条件下预测相对与地球的太阳和火星的角度\\(\\theta_M(t)\\)和\\(\\theta_S(t)\\) 物理模型：地球和火星围绕太阳以一定角速度做近似圆周运动 观测数据：给定初始角度，随机选择周周期的哥白尼的观测数据 模型的实现稍有变化，如下图所示： 这样，对于不同时间都对应一个隐变量\\(r(t_i)\\)，而且隐变量是时间依赖的，对于一个隐变量\\(r(t_i)\\)有一个解码器来输出答案。 实验结果表示，SciNet不仅正确预测了太阳和火星相对地球的角度，同时隐变量揭示了火星和地球相对太阳的角度。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Misc","slug":"Research/Misc","permalink":"http://qfxiao.me/categories/Research/Misc/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"}]},{"title":"Transfer Anomaly Detection by Inferring Latent Domain Representations","slug":"Transfer-Anomaly-Detection-by-Inferring-Latent-Domain-Representations","date":"2020-02-27T12:02:18.000Z","updated":"2020-06-25T09:01:35.786Z","comments":true,"path":"2020/02/27/Transfer-Anomaly-Detection-by-Inferring-Latent-Domain-Representations/","link":"","permalink":"http://qfxiao.me/2020/02/27/Transfer-Anomaly-Detection-by-Inferring-Latent-Domain-Representations/","excerpt":"","text":"Introduction 作者提出了一种利用迁移学习提升target domain异常检测性能的算法。文中指出现有的基于迁移学习的异常检测算法需要对每个 target domain 进行单独训练，这样做会带来很大的计算开销。本文通过latent domain vectors来实现无需重新训练的异常检测。latent domain vectors是domain的一种隐含表示，通过该domain中的正常样本得到。在本文中，anomaly score function通过Auto-encoder得到。 Proposed Method Task 令\\(\\mathbf{X}_d^+:=\\{\\mathbf{x}^+_{dn}\\}^{N^+_d}_{n=1}\\)为第\\(d\\)个domain的异常样本集，\\(\\mathbf{x}_{dn}^+\\in\\mathbb{R}^M\\)为其中第\\(n\\)个样本的\\(M\\)维特征向量，\\(N^+_d\\)为第\\(d\\)个domain异常样本的数量。 类似的，令\\(\\mathbf{X}_d^-:=\\{\\mathbf{x}^-_{dn}\\}^{N^-_d}_{n=1}\\)为第\\(d\\)个domain的正常样本集。我们假设对于每个domain都有\\(N^+_d\\ll N^-_d\\)，且特征向量维度都为\\(M\\)。 假设在 source domain \\(D_S\\)都有正常样本和异常样本，记为\\(\\{\\mathbf{X}^+_d\\cup\\mathbf{X}_d^-\\}^{D_S}_{d=1}\\)，在 target domain \\(D_T\\)只有正常样本\\(\\{\\mathbf{X}_d^-\\}^{D_S+D_T}_{d=D_S+1}\\)。我们的目标是得到一个对于 target domain 合适的 domain-specific 的异常打分函数。 Domain-specific Anomaly Score Function 我们基于Auto-encoder定义异常打分函数。对于每个domain，我们假设存在一个\\(K\\)维的隐变量\\(\\mathbf{z}_d\\in\\mathbb{R}^K\\)。对于第\\(d\\)个 domain，异常打分函数定义如下： \\[ s_\\theta(\\mathbf{x}_{dn}|\\mathbf{z}_d):=\\parallel\\mathbf{x}_{dn}-G_{\\theta_G}(F_{\\theta_F}(\\mathbf{x}_{dn},\\mathbf{z}_d))\\parallel^2 \\] 其中参数\\(\\theta:=(\\theta_G,\\theta_F)\\)在所有 domain 之间共享。 Models for Latent Domain Vectors 隐变量\\(\\mathbf{z}_d\\)是无法观测到的，只能通过数据来估计。首先\\(\\mathbf{z}_d\\)在\\(\\mathbf{X}_d^-\\)条件下的条件分布假设为高斯分布： \\[ q_\\theta(\\mathbf{z}_d|\\mathbf{X}_d^-):=\\mathcal{N}(\\mathbf{z}_d|\\mu_\\phi(\\mathbf{X}_d^-),\\text{diag}(\\sigma_\\phi^2(\\mathbf{X}_d^-))) \\] 其中均值\\(\\mu_\\phi(\\mathbf{X}_d^-)\\in\\mathbb{R}^K\\)和方差\\(\\sigma^2_\\phi(\\mathbf{X}_d^-)\\in\\mathbb{R}^K_+\\)由神经网络建模，且在所有 domain 之间共享。在\\(\\mathbf{X}_d^-\\)给定的时候，我们便能够推断出该 domain 对应的隐变量， \\(q_\\phi\\)的输入为正常样本的集合，故神经网络需要满足permutation invariant。\\(\\tau(\\mathbf{X}_d^-)=\\rho(\\sum_{n=1}^{N_d^-}\\eta(\\mathbf{x}_{dn}^-))\\)，其中\\(\\tau(\\mathbf{X}_d^-)\\)表示\\(\\mu_\\phi(\\mathbf{X_d^-})\\)或\\(\\ln\\sigma_\\phi^2(\\mathbf{X}_d^-)\\)，\\(\\rho\\)和\\(\\eta\\)为神经网络， Objective Function 目标函数由anomaly score函数和隐变量组成。第\\(d\\)个domain在对应的隐变量\\(\\mathbf{z}_d\\)条件下的目标函数为： \\[ L_d(\\theta|\\mathbf{z}_d):=\\frac{1}{N_d^-}\\sum\\limits_{n=1}^{N_d^-}s_\\theta(\\mathbf{x}_{dn}^-|\\mathbf{z}_d)-\\frac{\\lambda}{N_d^-N_d^+}\\sum\\limits_{n,m=1}^{N_d^-,N_d^+}f(s_\\theta(\\mathbf{x}_{dm}^+|\\mathbf{z}_d)-s_\\theta(\\mathbf{x}_{dn}^-|\\mathbf{z}_d)) \\] 其中\\(\\lambda\\geq 0\\)为超参数，\\(f\\)为sigmoid函数。公式的第一项表示第\\(d\\)个domain正常样本对应的anomaly score。第二项为可微分的AUC。异常样本的anomaly score应当大于正常样本，所以对任何\\(\\mathbf x_{dm}^+\\in\\mathbf X_d^+, \\mathbf x_{dn}^-\\in\\mathbf X_d^-\\)有\\(s_\\theta(\\mathbf x_{dm}^+|\\mathbf z_d)&gt;s_\\theta(\\mathbf x_{dn}^-|\\mathbf z_d)\\)。第二项\\(\\frac{\\lambda}{N_d^-N_d^+}\\sum\\limits_{n,m=1}^{N_d^-,N_d^+}f(s_\\theta(\\mathbf{x}_{dm}^+|\\mathbf{z}_d)-s_\\theta(\\mathbf{x}_{dn}^-|\\mathbf{z}_d))\\)的取值范围是\\([0,1]\\)，当所有的\\(s_\\theta(\\mathbf{x}_{dm}^+|\\mathbf{z}_d)\\gg s_\\theta(\\mathbf{x}_{dm}^-|\\mathbf{z}_d)\\)时该项为1，当所有的\\(s_\\theta(\\mathbf{x}_{dm}^+|\\mathbf{z}_d)\\ll s_\\theta(\\mathbf{x}_{dm}^-|\\mathbf{z}_d)\\)时该项为0，所以最小化该项的相反数相当于鼓励\\(s_\\theta(\\mathbf{x}_{dm}^+|\\mathbf{z}_d)\\gg s_\\theta(\\mathbf{x}_{dm}^-|\\mathbf{z}_d)\\)。 因为隐变量\\(\\mathbf z_d\\)包含不确定性，我们应该在目标函数里考虑这一点： \\[ \\mathcal{L}_d(\\theta,\\phi):=\\mathbb{E}_{q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)}\\left[L_d(\\theta|\\mathbf{z}_d)\\right]+\\beta D_\\text{KL}(q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)\\parallel p(\\mathbf{z_d})) \\] 第一项是\\(L_d(\\theta|\\mathbf z_d)\\)关于\\(q_\\phi(\\mathbf z_d|\\mathbf X_d^-)\\)的期望，第二项是\\(q_\\phi(\\mathbf z_d|\\mathbf X_d^-)\\)和\\(p(\\mathbf z_d):=\\mathcal{N}(\\boldsymbol 0,\\boldsymbol I)\\)的KL散度。第一项可以用monte carlo估计\\(\\mathbb{E}_{q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)}\\left[L_d(\\theta|\\mathbf{z}_d)\\right]\\approx\\frac{1}{L}\\sum_{\\ell=1}^L L_d(\\theta|\\mathbf z_d^{(\\ell)})\\)，除此之外还需要用到reparametrization trick。 对于第\\(d\\)个target domain，因为没有异常样本（假设），所以\\(L_d(\\theta|\\mathbf{z}_d):=\\frac{1}{N_d^-}\\sum\\limits_{n=1}^{N_d^-}s_\\theta(\\mathbf{x}_{dn}^-|\\mathbf{z}_d)\\)，有： \\[ \\mathcal{L}_d(\\theta,\\phi):=\\mathbb{E}_{q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)}\\left[\\frac{1}{N_d^-}\\sum\\limits_{n=1}^{N_d^-}s_\\theta(\\mathbf{x}_{dn}^-|\\mathbf{z}_d)\\right]+\\beta D_\\text{KL}(q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)\\parallel p(\\mathbf{z}_d)) \\] 所以总的损失函数为各domain对应的损失函数之和\\(\\mathcal{L}(\\theta,\\phi):=\\sum_{d=1}^{D_S+D_T}\\alpha_d\\mathcal{L}_d(\\theta,\\phi)\\)。 Inference 训练好之后，domain-specific的anomaly score可以由下式计算出： \\[ s(\\mathbf{x}_{d^\\prime}):=\\int s_{\\theta_*}(\\mathbf{x_{d^\\prime}}|\\mathbf{z}_{d^\\prime})q_{\\phi_*}(\\mathbf{z}_{d^\\prime}|\\mathbf{X}_{d^\\prime}^-)\\mathrm{d}\\mathbf{z}_{d^\\prime}\\approx\\frac{1}{L}\\sum\\limits_{\\ell=1}^L s_{\\theta_*}(\\mathbf{x}_{d^\\prime}|\\mathbf{z}_{d^\\prime}^{(\\ell)}) \\] Experiments Data 实验包含五个数据集，第一个是合成数据集。如下图(a)所示，围绕\\((0,0)\\)有\\(8\\)个圈，每个圈包含了一个内圈作为异常样本，第\\(7\\)个圈被选为target domain，其余的为source domain。第二个是MNIST-r，是加入旋转的MNIST，包含6个domain，其中数字“4”被选为异常样本，其余为正常。第三个为Anuran Calls，包含5个domain。第四个是Landmine，主要用在多任务学习中。第五个是IoT，网络流量数据，包含8个domain。 Comparison Methods 对比的baseline包括NN（普通多层神经网络），NNAUC（加入可微分AUC作为损失函数），AE（普通Autoencoer），AEAUC（加入可微分AUC的AE），OSVM（单类支持向量机），CCSA，TOSVM和OTL。 Results 4个真实数据集的结果如下： 表5为考虑隐变量不确定性的ablation study。将原来的公式\\(\\mathcal{L}_d(\\theta,\\phi):=\\mathbb{E}_{q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)}\\left[L_d(\\theta|\\mathbf{z}_d)\\right]+\\beta D_\\text{KL}(q_\\phi(\\mathbf{z}_d|\\mathbf{X}_d^-)\\parallel p(\\mathbf{z_d}))\\)中\\(q_\\phi(\\mathbf z_d|\\mathbf X_d^-)\\)用迪利克雷分布\\(q_\\phi(\\mathbf z_d|\\mathbf X_d^-)=\\delta(\\mathbf z_d-\\mu_\\phi(\\mathbf X_d^-))\\)代替并且去掉KL散度。 表6展示了不同异常比例对效果的影响。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"Transfer Learning","slug":"Transfer-Learning","permalink":"http://qfxiao.me/tags/Transfer-Learning/"}]},{"title":"Deep Anomaly Detection with Deviation Networks","slug":"Deep-Anomaly-Detection-with-Deviation-Networks","date":"2020-02-24T02:45:08.000Z","updated":"2020-06-25T05:30:55.514Z","comments":true,"path":"2020/02/24/Deep-Anomaly-Detection-with-Deviation-Networks/","link":"","permalink":"http://qfxiao.me/2020/02/24/Deep-Anomaly-Detection-with-Deviation-Networks/","excerpt":"","text":"Introduction 本文关注Deep Anomaly Detection，也就是用深度学习的方法来进行异常检测。文中提到现有的Deep Anomaly Detection存在两个弊端：一个是采用深度学习方法来进行特征学习，然后通过下游任务得到Anomaly Score，相比文中End-to-End的Anomaly Score学习，存在优化不充分的风险；另一个是现有的方法主要是无监督学习，无法利用已知的信息（如少量标签）。为此，本文提出了一种端到端的异常检测框架，来解决上述问题。 本文的主要贡献如下： 提出了一种端到端的异常检测框架，直接学习Anomaly Score并且可以利用已知信息； 基于提出的框架，文中提出了一种实例方法 (DevNet)。 Proposed Model End-To-End Anomaly Score Learning Problem Statement 为了区别于传统的两阶段异常检测（先学习特征表示，然后在学到的特征上定义一个anomaly measure来得到anomaly score），作者对端到端的异常检测问题重新进行形式化。 给定\\(N+K\\)个样本\\(\\mathcal{X}=\\{\\boldsymbol x_1,\\boldsymbol x_2,\\cdots,\\boldsymbol x_N,\\boldsymbol x_{N+1},\\cdots,\\boldsymbol x_{N+K}\\}\\)，其中\\(\\boldsymbol x_i\\in\\mathbb{R}^D\\)，无标签样本集\\(\\mathcal{U}=\\{\\boldsymbol x_1,\\boldsymbol x_2,\\cdots,\\boldsymbol x_N\\}\\)，有标签样本集\\(\\mathcal{K}=\\{\\boldsymbol x_{N+1},\\cdots,\\boldsymbol x_{N+K}\\}\\)，且\\(K\\ll N\\)。异常检测的目标是学习一个anomaly scoring function\\(\\phi:\\mathcal{X}\\mapsto\\mathbb{R}\\)使得\\(\\phi(\\boldsymbol x_i)&gt;\\phi(\\boldsymbol x_j)\\)，其中\\(\\boldsymbol x_i\\)为异常样本，\\(\\boldsymbol x_j\\)为正常样本。 The Proposed Framework 为了解决这个问题，文中提出了一种通用异常检测框架，模型框架如下图所示： 模型框架如下图所示： 主要包含三个部分： anomaly scoring network. 图中左边的部分，一个函数\\(\\phi\\)，输入样本\\(\\mathbf{x}\\)，输出anomaly score reference score generator. 图中右边的部分。只有一个anomaly scoring network并不能进行训练，需要训练的目标。为此加入reference score generator，输入为随机选择的\\(l\\)个正常样本，输出reference score（这\\(l\\)个正常样本anomaly score的均值，记为\\(\\mu_\\mathcal{R}\\)） deviation loss. \\(\\phi(\\mathbf{x})\\)，\\(\\mu_\\mathcal{R}\\)及对应的标准差\\(\\sigma_\\mathcal{R}\\)作为deviation loss函数的输入。因为\\(\\mu_\\mathcal{R}\\)和\\(\\sigma_\\mathcal{R}\\)对应正常样本集的均值和方差，那么异常样本的anomaly score应该和\\(\\mu_\\mathcal{R}\\)差别比较大，而正常样本则应该接近\\(\\mu_\\mathcal{R}\\)。 Deviation Networks 下面是上述三个部件的具体实现。 End-To-End Anomaly Scoring Network 记\\(\\mathcal{Q}\\in\\mathbb{R}^M\\)为中间表示空间，anomaly scoring network\\(\\phi(\\cdot;\\Theta):\\mathcal{X}\\mapsto\\mathbb{R}\\)可以定义为数据表示学习\\(\\psi(\\cdot;\\Theta_t):\\mathcal{X}\\mapsto\\mathcal{Q}\\)和异常分数学习\\(\\eta(\\cdot;\\Theta_s):\\mathcal{Q}\\mapsto\\mathbb{R}\\)两阶段的组合，其中\\(\\Theta=\\{\\Theta_t,\\Theta_s\\}\\)。 \\(\\psi(\\cdot;\\Theta_t)\\)可以用一个\\(H\\)层神经网络来实现： \\[ \\mathrm{q}=\\psi(\\mathbf{x};\\Theta_t) \\] 其中\\(\\mathbf{x}\\in\\mathcal{X}\\)，\\(\\mathrm{q}\\in\\mathcal{Q}\\)。 \\(\\eta(\\cdot;\\Theta_s)\\)可以用一个单层的神经网络来实现： \\[ \\eta(\\mathrm q;\\Theta_s)=\\sum\\limits_{i=1}^M w_i^oq_i+w_{M+1}^o \\] 其中\\(\\mathrm q\\in\\mathcal Q\\)，\\(\\Theta_s=\\{\\mathbf{w}^o\\}\\)。 所以有： \\[ \\phi(\\mathbf{x};\\Theta)=\\eta(\\psi(\\mathbf{x};\\Theta_t);\\Theta_s) \\] Gaussian Prior-based Reference Scores 有两种方法来获得\\(\\mu_\\mathcal{R}\\)，一种是data-driven，一种是prior-driven。如果是data-driven的话则采用另一个神经网络，文中表示为了更好的解释性和计算效率，所以采用的是prior-driven。 \\[ \\begin{align} r_1,r_2,\\cdots,r_l\\sim \\mathcal{N}(\\mu,\\sigma^2),\\\\ \\mu_\\mathcal{R}=\\frac{1}{l}\\sum\\limits_{i=1}^l r_i \\end{align} \\] 在文中，采用的prior是标准高斯分布。 Z-Score Based Deviation Loss anomaly scoring network的优化目标可以定义为Z-Score的方式： \\[ dev(\\boldsymbol x)=\\frac{\\phi(\\boldsymbol x;\\Theta)-\\mu_{\\mathcal{R}}}{\\sigma_{\\mathcal{R}}} \\] \\(dev(\\boldsymbol x)\\)可以看作是样本偏离标准的程度，而我们肯定希望异常样本偏离标准越大，正常样本越接近标准。文中采用的损失函数是Contrastive Loss： \\[ L(\\phi(\\boldsymbol x;\\Theta),\\mu_\\mathcal{R},\\sigma_\\mathcal{R})=(1-y)|dev(\\boldsymbol x)| + y \\max(0, a - dev(\\boldsymbol x)) \\] Contrastive Loss的直观解释可以看下图： 对于负例（正常），优化过程将他们尽量向原点靠近，对于正例（异常），优化过程将他们拉向边界。 The DevNet Algorithm DevNet的算法流程图如下： Interpretability of Anomaly Scores 因为reference score generator选择的是确定的高斯分布，于是可以用概率论给出一些解释性。作者给出了一个结论， PROPOSITION： 设\\(\\boldsymbol x\\in\\mathcal{X}\\)，\\(z_p\\)为\\(\\mathcal{N}(\\mu,\\sigma^2)\\)的分位数，那么\\(\\phi(\\boldsymbol x)\\)在区间\\(\\mu\\pm z_p\\sigma\\)的概率为\\(2(1-p)\\)。 例如，假设\\(p=0.95\\)，那么\\(z_{0.95}=1.96\\)，表示异常分数高于1.96的样本将以0.95的置信度为异常。 Experiment 实验用到了9个数据集，4个Baseline (REPEN，DSVDD，FSNET，iForest)，以及ROC和PR曲线两种评测标准。 Effectiveness in Real-world Data Sets Experiment Settings 这一个实验主要是为了验证算法在真实场景下的效果，即大量无标签数据和极少量标签数据。训练集包含两部分，一部分是无标签数据\\(\\mathcal{U}\\),包含\\(2\\%\\)的异常样本，另一部分是有标签数据\\(\\mathcal{K}\\)，由随机采样\\(0.005\\%-1\\%\\)的训练数据和\\(0.08\\%-6\\%\\)的异常样本组成。 Findings 实验结果如下表所示： 从结果上看来，本文提出的方法在所有数据集上都比Baseline好，说明DevNet端到端直接优化Anomaly Score的方式是有效的。 Data Efficiency Experiment Settings 这一个实验主要是为了探究基于深度的异常检测方法的data efficiency。和上一个实验一样，无标签数据集包含\\(2\\%\\)的异常，而有标签的异常数量从\\(5\\)到\\(120\\)不等。本实验试图回答以下两个问题： DevNet的data efficiency如何？ 基于深度的方法在多大程度上能够利用标签信息？ Findings 在几个基于深度的Baseline中，DevNet的效果是最好的，同时在有标签异常非常有限的情况下，DevNet也能很好的利用标签信息，达到更好的效果。 Robustness w.r.t. Anomaly Contamination Experiment Settings 在第一个实验中，无标签数据集\\(\\mathcal{U}\\)包含的是固定的异常比例\\(2\\%\\)，而在这个实验中，作者测试了从\\(0\\%\\)到\\(20\\%\\)之间不同异常比例来测试算法的鲁棒性（即使\\(\\mathcal{U}\\)中包含异常，由于没有标签，在训练的时候仍然假设都为正常来进行训练）。本实验试图回答以下问题： 基于深度的异常检测方法的鲁棒性如何？ 当训练集中异常污染的比例较高的时候基于深度的方法能否打败无监督的方法？ Findings 下图为实验结果： 从结果上来看，DevNet比其他基于深度的方法鲁棒性更好，同时在高异常污染的情况下仍然比纯无监督方法效果要好。 Ablation Study 本实验设置了DevNet的三个变体（默认的DevNet-Def为单层隐层加上一个输出层）来进行消融实验，分别是： DevNet-Rep，去掉了anomaly scoring network网络的输出层，对应end-to-end learning of anomaly scores和deviation loss； DevNet-Linear，去掉了网络中的非线性层，对应learning of non-linear features； DevNet-3HL，隐层数量为3层。 对比结果如下： 通过实验可以发现，DevNet-Rep说明了end-to-end learning of anomaly scores和deviation loss的有效性，而DevNet-Linear说明了learning of non-linear features的重要性。DevNet-3HL说明了加深网络并不总能带来性能的提升。 Scalability Test 这一个实验使用合成的数据来测试算法对大规模数据的处理能力，分别从Data Size和Data Dimensionality两方面来测试。结果如下： 可以看出，DevNet对Data Size并不敏感，同时，面对高维数据，DevNet也没有表现出劣势。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"Geant4 安装教程与调试环境配置","slug":"Geant4-安装教程","date":"2020-01-31T03:25:59.000Z","updated":"2020-06-25T05:39:27.592Z","comments":true,"path":"2020/01/31/Geant4-安装教程/","link":"","permalink":"http://qfxiao.me/2020/01/31/Geant4-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"Introduction Geant4安装的教程很多，版本都很旧了，这里写一个新版本（10.6）基于Ubuntu的安装教程，并且开启CLion IDE调试。 Step 1: Download Packages 首先进入官网(http://geant4.web.cern.ch/support/download)下载源代码（推荐tar.gz格式）及数据文件，解压。新建一个文件夹专门用来放Geant4相关文件，新建data，source，build文件夹，将Geant4的文件复制进来并按如下结构组织： 1234567891011121314151617.├── build├── data│ ├── G4ABLA3.1│ ├── G4EMLOW7.9│ ├── G4ENSDFSTATE2.2│ ├── G4INCL1.0│ ├── G4NDL4.6│ ├── G4PARTICLEXS2.1│ ├── G4PII1.3│ ├── G4SAIDDATA2.0│ ├── G4TENDL1.3.2│ ├── PhotonEvaporation5.5│ ├── RadioactiveDecay5.4│ └── RealSurface2.1.1└── source └── geant4.10.06 Step 2: Install Dependencies 安装编译所需环境： 1sudo apt-get install build-essential cmake 安装相关依赖： 1sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev libxt-dev libxmu-dev libxi-dev zlib1g-dev libgl2ps-dev libexpat1-dev libxerces-c-dev 如果要用到QT需要单独安装QT。 Step 3: Compile 进入build文件夹，用cmake命令： 1cmake ../source/geant4.10.06/ -DCMAKE_BUILD_TYPE=DEBUG -DGEANT4_USE_GDML=ON -DGEANT4_USE_OPENGL_X11=ON -DGEANT4_USE_RAYTRACER_X11=ON -DGEANT4_BUILD_MULTITHREADED=ON 其中../source/geant4.10.06/替换成换成（如果版本不一样）你自己的Geant4源代码所在目录，需要QT则加上-DGEANT4_USE_QT=ON。如果不需要调试则把-DCMAKE_BUILD_TYPE=DEBUG改成-DCMAKE_BUILD_TYPE=RELEASE。-DGEANT4_BUILD_MULTITHREADED=ON是多线程，视情况开启。 完成之后开始编译： 1make -jX -jX为多线程编译，如-j8。 编译完成之后进行安装： 1sudo make install Step 4: Configure 安装的默认路径在/usr/local/share/Geant4-10.6.0，将下载的数据文件复制到该文件夹： 1sudo cp -r ./data/ /usr/local/share/Geant4-10.6.0/ 之后，在~/.bashrc里添加/usr/local/share/Geant4-10.6.0/geant4make/geant4make.sh，如果你的版本和我的不一样，相应修改即可。 Step 5: CLion Configuration 最后我们来配置CLion环境，配好之后可以在IDE中编写Geant4代码，还可以断点调试，非常方便。安装CLion的过程这里省略，打开一个Geant4自带的例子或者自己新建一个项目，打开Edit Configurations。 随便打开一个终端，输入一下命令获取环境变量： 1env | grep G4 在Environment variables填入刚才获取的环境变量（复制之后按一下粘贴就可以了），然后把Working directory设置成当前文件夹。 现在就大功告成了！","categories":[{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Misc","slug":"Technical-Notes/Misc","permalink":"http://qfxiao.me/categories/Technical-Notes/Misc/"}],"tags":[{"name":"Geant4","slug":"Geant4","permalink":"http://qfxiao.me/tags/Geant4/"}]},{"title":"Complementary Set Variational Autoencoder for Supervised Anomaly Detection","slug":"Complementary-Set-Variational-Autoencoder-for-Supervised-Anomaly-Detection","date":"2020-01-09T02:15:03.000Z","updated":"2020-06-25T05:25:53.385Z","comments":true,"path":"2020/01/09/Complementary-Set-Variational-Autoencoder-for-Supervised-Anomaly-Detection/","link":"","permalink":"http://qfxiao.me/2020/01/09/Complementary-Set-Variational-Autoencoder-for-Supervised-Anomaly-Detection/","excerpt":"","text":"Introduction 对于异常检测问题，异常的模式是多种多样的。有监督模型能够较好地处理训练集中出现过的模式，无监督模型能够处理训练集中未出现过的模式，但对于训练集中出现过的异常模型并没有学习。本文提出了一种既能学习训练集中出现过的异常模式，同时能处理未出现过的异常模式的方法。 Proposed Model Conventional VAE 首先回顾一下原始的VAE。 原始VAE中的损失函数为： \\[ \\mathcal{L}(\\boldsymbol{\\theta},\\boldsymbol{\\phi};\\boldsymbol{x})=\\mathbb{E}_{q(\\boldsymbol{z}|\\boldsymbol{x};\\boldsymbol{\\phi})}[\\log p(\\boldsymbol{x}|\\boldsymbol{z};\\boldsymbol{\\theta})]-\\text{KL}[q(\\boldsymbol{z}|\\boldsymbol{x};\\boldsymbol{\\phi}\\parallel p(\\boldsymbol{z}))] \\] 原文中作者证明了\\(\\mathcal{L}(\\boldsymbol{\\theta},\\boldsymbol{\\phi};\\boldsymbol{x})\\leq\\log p(\\boldsymbol{x};\\boldsymbol{\\theta})\\)，所以\\(\\mathcal{L}(\\boldsymbol{\\theta},\\boldsymbol{\\phi};\\boldsymbol{x})\\)可以看作是数据分布\\(p(\\boldsymbol{x})\\)对数似然的一个下界。\\(\\mathcal{L}(\\boldsymbol{\\theta},\\boldsymbol{\\phi};\\boldsymbol{x})\\)又被称为证据下界 (ELBO)。\\(\\mathbb{E}_{q(\\boldsymbol{z}|\\boldsymbol{x};\\boldsymbol{\\phi})}[\\log p(\\boldsymbol{x}|\\boldsymbol{z};\\boldsymbol{\\theta})]\\)中的期望一般用蒙特卡洛来进行估计： \\[ \\begin{align} \\mathcal{L}(\\boldsymbol{\\theta},\\boldsymbol{\\phi};\\boldsymbol{x})\\simeq&amp; \\frac{1}{L}\\sum\\limits_l\\log p(\\boldsymbol{x}|\\boldsymbol{z}^{(l)};\\boldsymbol{\\theta})-\\text{KL}[q(\\boldsymbol{z}|\\boldsymbol{x};\\boldsymbol{\\phi})\\parallel p(\\boldsymbol{z})],\\\\ \\boldsymbol{z}^{(l)}&amp;\\sim q(\\boldsymbol{z}|\\boldsymbol{x};\\boldsymbol{\\phi}), \\space l\\in\\{1,2,\\cdots,L\\} \\end{align} \\] 对于隐变量\\(\\boldsymbol{z}\\)，一般假设先验服从标准高斯分布，后验服从均值为\\(\\mu\\)，方差为\\(\\sigma^2\\)的高斯分布，故KL散度能直接写出解析式： \\[ \\mathcal{L}(\\boldsymbol{\\theta},\\boldsymbol{\\phi};\\boldsymbol{x})\\simeq \\frac{1}{L}\\sum\\limits_l\\log p(\\boldsymbol{x}|\\boldsymbol{z}^{(l)};\\boldsymbol{\\theta})-C(-\\frac{1}{2}-\\log\\sigma+\\frac{1}{2}\\sigma^2+\\frac{1}{2}\\mu^2) \\] 使用VAE来做异常检测通常是在正常数据上进行训练，在检测阶段，如果是异常样本，那么VAE不能很好地重构它，这样会导致较大的重构误差。 Prior Distribution for Anomalies 在原始VAE异常检测中，无论输入样本\\(\\boldsymbol{x}\\)是否异常，VAE都会使对应编码的后验\\(p(\\boldsymbol{z}|\\boldsymbol{x})\\)服从高斯分布，且施加标准高斯分布的约束。在本文中，作者对异常和正常样本对应的隐变量的先验分布做了不同假设。首先，正常先验依然是标准高斯分布，记为\\(p_n(\\boldsymbol{z})\\)。而对于异常先验，作者认为异常即为“不正常”，和正常是补集的关系。作者在文中定义异常先验分布\\(p_a(\\boldsymbol{z})\\)为： \\[ p_a(\\boldsymbol{z})=\\frac{1}{Y^\\prime}(\\max\\limits_{\\boldsymbol{z}^\\prime}p_n(\\boldsymbol{z}^\\prime)-p_n(\\boldsymbol{z})) \\] 其中\\(Y^\\prime\\)为使\\(p_a(\\boldsymbol{z})\\)成为一个概率分布的调节因子。实际上，\\(Y^\\prime\\)往往会成为无限大，因为\\(p(\\boldsymbol z)\\)在整个定义域上都有定义。为了解决这个问题，作者加入了\\(p_w(\\boldsymbol z)\\)，一个在每个维度都足够宽的辅助分布： \\[ p_a(\\boldsymbol z)=\\frac{1}{Y}p_w(\\boldsymbol z)\\left(\\max\\limits_{\\boldsymbol z^\\prime}p_n(\\boldsymbol z^\\prime)-p_n(\\boldsymbol z)\\right) \\] 其中\\(Y\\)为有限的常数。在文中\\(p_n(\\boldsymbol z)\\)和\\(p_w(\\boldsymbol z)\\)都为高斯分布，那么\\(p_a(\\boldsymbol z)\\)的具体形式为： \\[ p_a(\\boldsymbol z)=\\frac{1}{Y}\\mathcal{N}(\\boldsymbol z;\\boldsymbol 0,\\boldsymbol s^2)\\{\\max\\limits_{\\boldsymbol z^\\prime}\\mathcal N(\\boldsymbol z^\\prime;\\boldsymbol 0,\\boldsymbol 1)-\\mathcal N(\\boldsymbol z;\\boldsymbol 0,\\boldsymbol 1)\\} \\] 其中： \\[ \\max\\limits_{\\boldsymbol z^\\prime}\\mathcal N(\\boldsymbol z^\\prime;\\boldsymbol 0,\\boldsymbol 1)=\\frac{1}{\\sqrt{2\\pi}} \\] \\[ Y=\\int_{-\\infty}^{\\infty}p_a(\\boldsymbol z)\\mathrm{d}\\boldsymbol z=\\frac{1}{\\sqrt{2\\pi}}\\left\\{1-\\frac{1}{\\boldsymbol s^2+1}\\right\\} \\] \\(\\boldsymbol s^2\\)为超参数，控制分布的宽度。用文中的先验替换VAE原始的KL散度，可写为： \\[ \\text{KL}\\left[q(\\boldsymbol z|\\boldsymbol x;\\phi)\\parallel p_a(\\boldsymbol z)\\right]=\\int_{-\\infty}^\\infty\\mathcal{N}(\\boldsymbol z;\\boldsymbol \\mu,\\boldsymbol \\sigma^2)\\log\\frac{\\mathcal N(\\boldsymbol z;\\boldsymbol\\mu,\\boldsymbol\\sigma^2)}{\\frac{1}{Y}\\mathcal N(\\boldsymbol z;\\boldsymbol 0,\\boldsymbol s^2)\\left\\{\\frac{1}{2\\pi}-\\mathcal N(\\boldsymbol z;\\boldsymbol0,\\boldsymbol 1)\\right\\}}\\mathrm{d}\\boldsymbol z \\] 展开后： \\[ \\begin{align} \\text{KL}\\left[q(\\boldsymbol z|\\boldsymbol x;\\phi)\\parallel p_a(\\boldsymbol z)\\right]&amp;= \\int_{-\\infty}^\\infty\\mathcal{N}(\\boldsymbol z;\\boldsymbol \\mu,\\boldsymbol \\sigma^2)\\log\\mathcal{N}(\\boldsymbol z;\\boldsymbol\\mu,\\boldsymbol\\sigma^2)\\mathrm{d}\\boldsymbol z\\\\ &amp;+\\log Y\\\\ &amp;-\\int_{-\\infty}^\\infty\\mathcal{N}(\\boldsymbol z;\\boldsymbol \\mu,\\boldsymbol \\sigma^2)\\log\\mathcal{N}(\\boldsymbol z;\\boldsymbol 0,\\boldsymbol s^2)\\mathrm{d}\\boldsymbol z\\\\ &amp;-\\int_{-\\infty}^\\infty\\mathcal{N}(\\boldsymbol z;\\boldsymbol \\mu,\\boldsymbol \\sigma^2)\\log\\left\\{\\frac{1}{\\sqrt{2\\pi}}-\\mathcal{N}(\\boldsymbol z;\\boldsymbol 0, \\boldsymbol 1)\\right\\}\\mathrm{d}\\boldsymbol z \\end{align} \\] 使用泰勒展开，\\(\\log (x+\\frac{1}{2\\pi})\\simeq-\\log 2\\pi+2\\pi x\\)，KL散度可以用下式估计： \\[ \\begin{align} \\text{KL}\\left[q(\\boldsymbol z|\\boldsymbol x;\\phi)\\parallel p_a(\\boldsymbol z)\\right]&amp;\\simeq\\sqrt{\\frac{2\\pi}{\\boldsymbol\\sigma^2+1}}\\exp\\left(\\frac{-\\boldsymbol\\mu^2}{2(\\boldsymbol\\sigma^2+1)}\\right)\\\\ &amp;+\\frac{\\boldsymbol\\mu^2+\\boldsymbol\\sigma^2}{2\\boldsymbol s^2}-\\log\\boldsymbol\\sigma+\\log\\boldsymbol s+\\log\\left(\\sqrt{\\boldsymbol s^2+1}-1\\right)\\\\ &amp;-\\frac{\\log(\\boldsymbol s^2+1)}{2}+\\frac{\\log(2\\pi)-1}{2} \\end{align} \\] 下图为一维时\\(p_n(\\boldsymbol z)\\)和\\(p_a(\\boldsymbol z)\\)的示例： Implementation of proposed method 文中使用编码器输出的分布\\(\\mathcal{N}(\\boldsymbol z;\\boldsymbol \\mu, \\boldsymbol \\sigma^2)\\)与标准正态分布之间的KL散度来作为异常分数。在每一轮的训练过程中，加入一轮使用Anomaly Prior的训练。 Experiments MNIST 作者设计了两个Task： Task 1. \\(N\\) vs. \\(\\bar{N}\\). 将手写数字中的一个作为已知异常，其他作为正常，并加入均匀分布作为未知的异常。 Task 2. 手写数字被分为3组：已知异常，正常，未知异常。 细节如下表所示： 在实现上，使用Adam优化器，batch_size为100，epochs为200。Encoder和Decoder都由三层感知机组成，超参数\\(s^2\\)设置为400。评测标准使用AUC (area under the receiver characteristic curve)。 下表为实验结果：","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"VAE","slug":"VAE","permalink":"http://qfxiao.me/tags/VAE/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"Anomaly Detection in Streams with Extreme Value Theory","slug":"Anomaly-Detection-in-Streams-with-Extreme-Value-Theory","date":"2019-10-29T03:36:22.000Z","updated":"2020-06-25T05:20:44.374Z","comments":true,"path":"2019/10/29/Anomaly-Detection-in-Streams-with-Extreme-Value-Theory/","link":"","permalink":"http://qfxiao.me/2019/10/29/Anomaly-Detection-in-Streams-with-Extreme-Value-Theory/","excerpt":"","text":"Introduction 本文基于Extreme Value Theory提出了一种不需要手动设置阈值也不需要对数据分布作任何假设的时间序列异常检测方法。除此之外，本方法可以用在通用的自动阈值选择的场合中。 原文 Background 在很多情况下我们需要进行阈值的选择。阈值的选择可以通过实验的方法或者对数据分布进行假设的方法来得到，不过这样做通常不准确。借助Extreme Value Theory我们可以在不需要对原始数据的分布作很强的假设的情况下，推断我们想要的极端事件的分布（在异常检测中就是异常值）。 下面给出一些数学符号，\\(X\\)为随机变量，\\(F\\)为累积分布函数，即\\(F(x)=\\mathbb{P}(X\\leq x)\\)。记\\(F\\)的“末尾”分布\\(\\bar{F}(x)=1-F(x)=\\mathbb{P}(X&gt;x)\\)。对于一个随机变量\\(X\\)和给定的概率\\(q\\)，记\\(z_q\\)为在\\(1-q\\)水平的分位数，即\\(z_q\\)为满足\\(\\mathbb{P}(X\\leq z_q)\\geq 1-q\\)最小的值。 Extreme Value Distributions Extreme Value Theory主要是为了找出极端事件发生的规律，有学者证明，在很弱的条件下，所有极端事件都服从一个特定的分布，而不管原始分布如何。具体形式如下： \\[ G_\\gamma:x\\mapsto \\exp(-(1+\\gamma x)^{-\\frac{1}{\\gamma}}), \\space\\space\\space\\space\\space\\gamma\\in\\mathbb{R}, \\space\\space\\space\\space\\space 1+\\gamma x&gt;0 \\] 其中\\(\\gamma\\)称为Extreme Value Index，由原始分布决定。 更严谨的说法是Fisher-Tippett-Gnedenko定理（极值理论第一定理）： THEOREM: (Fisher-Tippett-Gnedenko). 令\\(X_1,X_2,\\cdots,X_n,\\cdots\\)为独立同分布的随机变量序列，\\(M_n=\\max \\{X_1,\\cdots,X_n\\}\\)。如果实数对序列\\((a_n,b_n)\\)存在且满足\\(a_n&gt;0\\)和\\(\\lim\\limits_{n\\rightarrow \\infty}P\\left(\\frac{M_n-b_n}{a_n}\\leq x\\right)=F(x)\\)，其中\\(F\\)为非退化分布函数，那么\\(F\\)属于Gumbel、Fréchet或Weibull分布族（或总称Generalized Extreme Value Distribution）中的一种。 这是一个反直觉的结论，但是想到当事件发生变得极端时，即\\(\\mathbb{P}(X&gt;x)\\rightarrow 0\\)，\\(\\bar{F}(x)=\\mathbb{P}(X&gt;x)\\)分布的形状其实并没有很多种选择。Table 1展示了几种不同分布对应的\\(\\gamma\\)： Figure 1展示了几种不同\\(\\gamma\\)情况下的“末尾”分布： Power of EVT 根据Extreme Value Theory，我们可以在原始分布未知的情况下计算极端事件的概率。但是\\(\\bar{G}_\\gamma\\)分布中参数\\(\\gamma\\)是未知的，我们需要一种高效的方法来进行估计。The Peaks-Over-Threshold (POT) 方法是本文介绍的一种方法。 Peaks-Over-Threshold Approach POT方法依赖于Pickands-Balkema-De Haan定理（极值理论第二定理），维基百科版： 考虑一个未知分布\\(F\\)和随机变量\\(X\\)，我们的目标是估计\\(X\\)在超过确定阈值\\(u\\)下的条件分布\\(F_u\\)，定义为： \\[ F_u(y)=P(X-u\\leq y|X&gt;u)=\\frac{F(u+y)-F(u)}{1-F(u)} \\] 其中\\(0\\leq y\\leq x_F-u\\)，\\(x_F\\)为\\(F\\)的右端点。\\(F_u\\)描述了超过特征阈值\\(u\\)的分布，称为Conditional Excess Distribution Function。 STATEMENT: (Pickands-Balkema-De Haan). 设\\((X_1,X_2,\\cdots)\\)为独立同分布随机变量序列，\\(F_u\\)为相应的Conditional Excess Distribution Function。对于一大类的\\(F\\)和很大的\\(u\\)，\\(F_u\\)能够很好的被Generalized Pareto Distribution所拟合： \\[ F_u(y)\\rightarrow G_{k,\\sigma}(y),\\space\\space \\text{as } u\\rightarrow \\infty \\] 其中： \\[ G_{k,\\sigma}(y)= \\begin{cases} 1-(1+ky/\\sigma)^{-1/k}, &amp;\\text{if }k\\neq 0\\\\ 1-e^{-y/\\sigma}, &amp;\\text{if }k=0 \\end{cases} \\] 当\\(k\\geq 0\\)时\\(\\sigma&gt;0, y\\geq 0\\)，\\(k&lt;0\\)时\\(0\\leq y\\leq -\\sigma/k\\)。 论文中给出的定理如下： THEOREM: (Pickands-Balkema-De Haan). 累积概率密度函数\\(F\\in\\mathcal{D}_\\gamma\\)当且仅当函数\\(\\sigma\\)存在时，对所有\\(x\\in\\mathbb{R}\\)在\\(1+\\gamma x&gt;0\\)的条件下有： \\[ \\frac{\\bar{F}(t+\\sigma(t)x)}{\\bar{F}(t)}\\mathop{\\rightarrow}\\limits_{t\\rightarrow\\tau}(1+\\gamma x)^{-\\frac{1}{\\gamma}} \\] 上式可以写成如下形式： \\[ \\bar{F}_t(x)=\\mathbb{P}(X-t&gt;x|X&gt;t)\\mathop{\\sim}\\limits_{t\\rightarrow\\tau}\\left(1+\\frac{\\gamma x}{\\sigma(t)}\\right)^{-\\frac{1}{\\gamma}} \\] 该式表明\\(X\\)超过阈值\\(t\\)的概率（写为\\(X-t\\)）服从Generalized Pareto Distribution (GPD)，参数为\\(\\gamma\\)和\\(\\sigma\\)。POT主要是拟合GPD而不是EVT分布。 如果我们要估计参数\\(\\hat{\\gamma}\\)和\\(\\hat{\\sigma}\\)，分位数可以通过下式计算得到： \\[ z_q\\simeq t+\\frac{\\hat{\\sigma}}{\\hat{\\gamma}}\\left(\\left(\\frac{qn}{N_t}\\right)^{-\\hat{\\gamma}}-1\\right) \\] 其中\\(t\\)是一个“很高”的阈值，\\(q\\)是给定的概率值，\\(n\\)是所有观测样本的数量，\\(N_t\\)是peaks的数量，即\\(X_i&gt;t\\)的数量。为了进行高效的参数估计，文中使用了极大似然估计。 Maximum Likelihood Estimation 设\\(X_1,\\cdots,X_n\\)为独立同分布的随机变量，概率密度函数记为\\(f_\\theta\\)，\\(\\theta\\)为分布中的参数，那么似然函数可以写为： \\[ \\mathcal{L}(X_1,\\cdots,X_n;\\theta)=\\prod\\limits_{i=1}^n f_\\theta(X_i) \\] 在极大似然估计中，我们需要找到合适的参数使得似然函数最大化。在我们的问题中，似然函数如下： \\[ \\log\\mathcal{L}(\\gamma,\\sigma)=-N_t\\log\\sigma-\\left(1+\\frac{1}{\\gamma}\\right)\\sum\\limits_{i=1}^{N_t}\\log\\left(1+\\frac{\\gamma}{\\sigma}Y_i\\right) \\] 其中\\(Y_i&gt;0\\)表示\\(X_i\\)超过阈值\\(t\\)的部分。 文中使用了Grimshaw's Trick来将含两个参数的优化问题转换为只含一个参数的优化问题。记\\(\\ell(\\gamma,\\sigma)=\\log\\mathcal{L}(\\gamma,\\sigma)\\)，对于所有极值来说有\\(\\nabla \\ell(\\gamma, \\sigma)=0\\)。Grimshaw's Trick表明对于满足\\(\\nabla \\ell(\\gamma, \\sigma)=0\\)的一对\\((\\gamma^*,\\sigma^*)\\)，\\(x^*=\\frac{\\gamma^*}{\\sigma^*}\\)为等式\\(u(X)v(X)=1\\)的解，其中： \\[ \\begin{align} u(x)&amp;=\\frac{1}{N_t}\\sum\\limits_{i=1}^{N_t}\\frac{1}{1+xY_i}\\\\ v(x)&amp;=1+\\frac{1}{N_t}\\sum\\limits_{i=1}^{N_t}\\log(1+xY_i) \\end{align} \\] 在找到满足该等式的解\\(x^*\\)后，我们可以得到\\(\\gamma^*=v(x^*)-1\\)和\\(\\sigma^*=\\gamma^*/x^*\\)，于是问题就变成了如何寻找方程的所有根。 因为\\(\\log\\)的存在，所以有\\(1+xY_i&gt;0\\)。而\\(Y_i\\)是正数，所以\\(x^*\\)的范围一定在\\(\\left(-\\frac{1}{Y^M},+\\infty\\right)\\)，其中\\(Y^M=\\max Y_i\\)。 Grimshaw（作者参考的一篇论文）还给出了一个上界： \\[ x^*_{\\text{max}}=2\\frac{\\bar{Y}-Y^m}{(Y^m)^2} \\] 其中\\(Y^m=\\min Y_i\\)，\\(\\bar{Y}\\)为\\(Y_i\\)的均值。详细的优化方法会在下文讨论。 背景部分到此结束，接下来的部分就是作者提出的新方法。 Methodology Extreme Value Theory给出了在对原始分布未知的情况下估计使得\\(\\mathbb{P}(X&gt;z_q)&lt;q\\)的\\(z_q\\)的方法。 本文据此提出了时间序列流的异常检测方法。首先根据已知的观测值\\(X_1,\\cdots,X_n\\)得到阈值\\(z_q\\)，然后根据数据的特性运用两种不同方法来更新\\(z_q\\)。对于平稳时间序列，使用SPOT；对于非平稳时间序列，使用DSPOT。 Initialization Step 在进行异常检测之前，需要根据已有的观测数据进行\\(z_q\\)的估计。给定\\(n\\)个观测值\\(X_1,\\cdots,X_n\\)和一个固定的概率值\\(q\\)，我们的目标是估计阈值\\(z_q\\)使得\\(\\mathbb{P}(X&gt;z_q)&lt;q\\)。其主要流程是首先设定一个较大的阈值\\(t\\)，然后通过拟合GPD分布来计算\\(z_q\\)。过程如下图所示： 算法流程如下所示： \\(Y_t\\)代表大于\\(t\\)的观测值的集合，GPD分布的拟合使用了前文提到的Grimshaw's Trick。 Finding Anomalies in a Stream 通过Initialization Step使用POT算法得到的\\(z_q\\)，我们定义其为\"Normality Bound\"，用于后面的检测。在后面的步骤中，我们会根据新得到的观测值来更新\\(z_q\\)。 Stationary Case 我们首先来讨论时间序列没有时间依赖性的情况（\\(X_1,\\cdots,X_n\\)之间独立同分布）。通过POT算法对所有观测值得到\\(z_q\\)之后，Streaming POT (SPOT) 算法会检查\\(X_n\\)之后的值（数据流场景，\\(X_1,\\cdots,X_n\\)是历史数据，还会有新的数据进来），如果大于\\(z_q\\)，则将\\(X_i\\)加入异常点集合中；如果大于\\(t\\)但小于\\(z_q\\)，则将\\(X_i\\)加入观测值集合中，更新\\(z_q\\)；其他情况我们\\(X_i\\)是正常情况。算法流程图如下： Drifting Case SPOT算法只适用于平稳分布的情况，但在现实生活中这样的假设过强了。于是作者提出了能处理时间依赖性的Streaming POT with Drift (DSPOT) 算法。 在DSPOT中，我们不使用\\(X_i\\)的绝对值，而是用相对值\\(X^\\prime_i=X_i-M_i\\)，其中\\(M_i\\)是\\(i\\)时刻的局部特征，如Figure 4所示。最简单的实现是使用局部均值，即\\(M_i=(1/d)\\cdot\\sum\\limits_{k=1}^d X_{i-k}^*\\)，\\(X_{i-1}^*,\\cdots,X_{i-d}^*\\)是长度为\\(d\\)的窗口。我们假设\\(X^\\prime_i\\)服从平稳分布的假设。 算法流程图如下所示： Numerical Optimization 现在剩下的问题就是优化了，前文已经提到对GPD的拟合已经被优化成一个参数的优化问题，下面将会详细讨论优化算法。 Reduction of the Optimal Parameters Search 前文已经得到了一个初步的\\(x^*\\)的Bound，即\\(x^*&gt;-\\frac{1}{Y^M}\\)和\\(x^*\\leq 2\\frac{\\bar{Y}-Y^m}{(Y^m)^2}\\)，下面将给出一个更严格的Bound。 PROPOSITION: 如果\\(x^*\\)是\\(u(x)v(x)=1\\)的解，那么： \\[ x^*\\leq 0 \\text{ or } x^*\\geq 2\\frac{\\bar{Y}-Y^m}{\\bar{Y}Y^m} \\] 证明见论文原文。 这样\\(x^*\\)的范围就进一步缩小了，于是有\\(u(x)v(X)=1\\)的解\\(x^*\\)在以下范围之内： \\[ \\left(-\\frac{1}{Y^M},0\\right]\\text{ and }\\left[2\\frac{\\bar{Y}-Y^m}{\\bar{Y}Y^m},2\\frac{\\bar{Y}-Y^m}{(Y^m)^2}\\right] \\] How Can We Maximize the Likelihood Function? 接下来是优化的具体实现问题。文中首先设定了一个很小的值\\(\\epsilon&gt;0\\space(\\sim 10^{-8})\\)，然后在下面的范围内寻找函数\\(w:x\\mapsto u(x)v(x)-1\\)的根： \\[ \\left[-\\frac{1}{Y^M}+\\epsilon,-\\epsilon\\right]\\text{ and }\\left[2\\frac{\\bar{Y}-Y^m}{\\bar{Y}Y^m},2\\frac{\\bar{Y}-Y^m}{(Y^m)^2}\\right] \\] 作者没有使用现有的寻找函数根的算法，而是转换为如下优化问题： \\[ \\min\\limits_{x_1,\\cdots,x_k\\in I}\\sum\\limits_{i=1}^k w(x_k)^2 \\] 其中\\(I\\)就是\\(x^*\\)的Bound。该问题是一个很典型的优化问题，可以被很多成熟的算法所解决。 Initial Threshold 在算法的Initialization Step，需要事先设定一个阈值\\(t\\)，如果设定的太大，那么\\(Y_t\\)的数量就会很少。作者给出的建议是保证\\(t&lt;z_q\\)，即\\(t\\)对应的概率值应该小于\\(1-q\\)。 Experiments 在实验部分，作者在合成数据和真实数据上试验了SPOT算法和DSPOT算法的有效性。 (D)SPOT Reliability 作者首先在合成数据上验证SPOT的有效性。具体做法是使用高斯分布生成数据（高斯分布的分位数能够直接计算），然后将SPOT得出的\\(z_q\\)和理论值进行对比。误差定义如下： \\[ \\text{error rate}=\\left|\\frac{z^{\\text{SPOT}}-z^{\\text{th}}}{z^{\\text{th}}}\\right| \\] 下图是采用不同数量观测值的结果： Finding Anomalies with SPOT 在这一节作者在真实数据集上进行了实验以验证SPOT算法的有效性，结果如下图： 在文中作者说算法的True Positive达到了\\(86\\%\\)，False Positive小于\\(4\\%\\)。 Finding Anomalies with DSPOT 在这一节作者使用DSPOT在真实数据集上进行了实验。窗口大小\\(d=450\\)，预设的风险概率值\\(q=10^{-3}\\)。结果如下图所示： 在图中可以看出在\\(8000\\) Minutes之后上界显著提高，作者分析了原因，认为是因为超过阈值\\(t\\)的点\\(Y_t\\)的存储是全局的，在前\\(8000\\) Minutes算法存储了很多较高的\\(Y_t\\)值，而在\\(8000\\) Minutes之后，真实数据的趋势开始下降，但算法仍是根据全局的\\(Y_t\\)来进行\\(z_q\\)的计算（这一段没有特别明白）。作者给出的修正方法是只保存固定数量的Peaks。 下图是作者在股票数据上得到的实验结果： Performances 作者还验证了算法的时间效率。 表中T代表的是每个Iteration的时间，M代表的是Peaks的比例，\"bi-\"前缀代表的是同时计算上界和下界。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Statistics","slug":"Statistics","permalink":"http://qfxiao.me/tags/Statistics/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"}]},{"title":"An Introduction to Variational Autoencoders","slug":"An-Introduction-to-Variational-Autoencoders","date":"2019-10-22T07:14:26.000Z","updated":"2020-06-24T08:16:51.584Z","comments":true,"path":"2019/10/22/An-Introduction-to-Variational-Autoencoders/","link":"","permalink":"http://qfxiao.me/2019/10/22/An-Introduction-to-Variational-Autoencoders/","excerpt":"","text":"Deep Generative Models 生成模型是指一系列用于随机生成可观测数据的模型。假设在一个高维空间\\(\\mathcal{X}\\)中，存在一个随机向量\\(\\mathbf{X}\\)服从一个未知的分布\\(p_r(x),x\\in \\mathcal{X}\\)。生成模型就是根据一些可观测的样本\\(x^{(1)},x^{(2)},\\cdots,x^{(N)}\\)来学习一个参数化的模型\\(p_\\theta(x)\\)来近似未知分布\\(p_r(x)\\)。 生成模型主要用于密度估计和样本生成。 密度估计即给定一组数据\\(\\mathcal{D}=\\{x^{(i)}\\},1\\leq i\\leq N\\)，假设他们都是从相同的概率密度函数\\(p_r(x)\\)独立产生的。密度估计就是根据数据集\\(\\mathcal{D}\\)来估计其概率密度函数\\(p_r(x)\\)。 如果将生成模型用于监督学习，那么就是输出标签的条件概率分布\\(p(y|x)\\)，根据贝叶斯公式： \\[p(y|x)=\\frac{p(x,y)}{\\sum_y p(x,y)}\\] 问题就变为了联合概率\\(p(x,y)\\)的密度估计问题。 样本生成即根据给定的概率分布\\(p_\\theta(x)\\)生成一些服从这个分布的样本，即采样。在含隐变量的生成模型中，生成\\(x\\)的过程一般包含两步： 根据隐变量的分布\\(p_\\theta(z)\\)采样得到\\(z\\)； 根据条件分布\\(p_\\theta(x|z;\\theta)\\)进行采样得到\\(x\\)。 所以在生成模型中的重点是估计条件分布\\(p(x|z;\\theta)\\)。 Parameter Estimation for Hidden Variable with EM Algorithm 如果图模型中存在隐变量，就需要使用EM算法进行参数估计。 在一个包含隐变量的图模型中，令\\(\\mathbf{X}\\)为可观测变量集合，\\(\\mathbf{Z}\\)为隐变量集合，则一个样本\\(x\\)的边际似然函数为： \\[p(x;\\theta)=\\sum_z p(x,z;\\theta)\\] 给定包含\\(N\\)个训练样本的训练集\\(\\mathcal{D}=\\{x^{(n)}\\},1\\leq i\\leq N\\)，则训练集的对数边际似然为： \\[\\begin{align}\\mathcal{L}(\\mathcal{D};\\theta)&amp;=\\frac{1}{N}\\sum_{n=1}^N \\log p(x^{(n)};\\theta)\\\\&amp;=\\frac{1}{N}\\sum_{n=1}^N \\log \\sum_z p(x^{(n)},z;\\theta)\\end{align}\\] 这时，只要最大化整个训练集的对数边际似然\\(\\mathcal{L}(\\mathcal{D};\\theta)\\)，即可估计出最优的参数\\(\\theta^*\\)。不过在计算梯度的时候，需要在对数函数内部进行求和或积分计算。为了更好的计算\\(\\log p(x;\\theta)\\)，我们引入一个额外的变分函数\\(q(z)\\)，\\(q(z)\\)为定义在隐变量\\(z\\)上的分布。样本\\(x\\)的对数边际似然函数为： \\[\\begin{align}\\log p(x;\\theta)&amp;=\\log \\sum_z q(z)\\frac{p(x,z;\\theta)}{q(z)}\\\\&amp;\\geq\\sum_z q(z)\\log \\frac{p(x,z;\\theta)}{q(z)}\\\\&amp;\\triangleq ELBO(q,x;\\theta)\\end{align}\\] 其中\\(ELBO(q,x;\\theta)\\)为对数边际似然函数\\(\\log p(x;\\theta)\\)的下界，称为证据下界。公式中使用了Jensen不等式(即对于凹函数\\(g\\)，有\\(g(\\mathbb{E}[x])\\geq\\mathbb{E}[g(X)]\\))。在这里，\\(\\frac{p(x,z;\\theta)}{q(z)}\\)可视为\\(q(z)\\)的函数，记为\\(f(q(z))\\)，那么\\(f(q(z))\\)的期望即\\(\\mathbb{E}[f(q(z))]=\\sum_z q(z)f(q(z))=\\sum_z q(z)\\frac{p(x,z;\\theta)}{q(z)}\\)。而根据Jensen不等式，有\\(g(\\mathbb{E}[f(q(z))])\\geq\\mathbb{E}[g(f(q(z)))]\\Leftrightarrow g(\\sum_z q(z)\\frac{p(x,z;\\theta)}{q(z)})\\geq \\sum_z q(z)g(\\frac{p(x,z;\\theta)}{q(z)})\\)，在这里\\(g\\)就是对数函数。 根据Jensen不等式取等的条件：\\(\\frac{p(x,z;\\theta)}{q(z)}=c\\)，\\(c\\)为常数，有： \\[\\begin{align}\\sum_z p(x,z;\\theta)&amp;=c\\sum_z q(z)\\\\\\Leftrightarrow\\sum_z p(x,z;\\theta)&amp;=c\\cdot1\\end{align}\\] 因此： \\[\\begin{align}q(z)&amp;=\\frac{p(x,z;\\theta)}{\\sum_z p(x,z;\\theta)}\\\\&amp;=\\frac{p(x,z;\\theta)}{p(x;\\theta)}\\\\&amp;=p(z|x;\\theta)\\end{align}\\] 所以，当且仅当\\(q(z)=p(z|x;\\theta)\\)时，\\(\\log p(x;\\theta)=ELBO(q,x;\\theta)\\)。 于是最大化对数边际似然函数\\(\\log p(x;\\theta)\\)的过程可以分解为两个步骤： 先找到近似分布\\(q(z)\\)使得\\(\\log p(x;\\theta)=ELBO(q,x;\\theta)\\)； 再寻找参数\\(\\theta\\)最大化\\(ELBO(q,x;\\theta)\\)。 这就是期望最大化(Expectation-Maximum,EM)算法。 EM算法通过迭代的方法，不断重复直到收敛到某个局部最优解。在第\\(t\\)步更新时，E步和M步分别为： E步：固定参数\\(\\theta_t\\)，找到一个分布使\\(ELBO(q,x;\\theta_t)\\)最大，即等于\\(\\log p(x;\\theta_t)\\)：\\(q_{t+1}(z)=\\text{arg}_q \\max ELBO(q,x;\\theta_t)\\)； M步：固定\\(q_{t+1}(z)\\)，找到一组参数使得证据下界最大，即：\\(\\theta_{t+1}=\\text{arg}_\\theta\\max ELBO(q_{t+1},x;\\theta)\\)。 对数边际似然也可以通过信息论的视角来进行分解： \\[\\begin{align}\\log p(x;\\theta)&amp;=\\sum_z q(z)\\log p(x;\\theta)\\\\&amp;=\\sum_z q(z)(\\log p(x,z;\\theta)-\\log p(z|x;\\theta))\\\\&amp;=\\sum_z q(z)\\log\\frac{p(x,z;\\theta)}{q(z)}-\\sum_z q(z)\\log\\frac{p(z|x;\\theta)}{q(z)}\\\\&amp;=ELBO(q,x;\\theta)+D_{KL}(q(z)\\parallel p(z|x;\\theta))\\end{align}\\] 其中\\(D_{KL}(q(z)\\parallel p(z|x;\\theta))\\) Generative Model with Hidden Variable 假设一个生成模型包含不可观测的隐变量，其中可观测变量\\(x\\)为一个高维空间中的随机向量，而不可观测的隐变量\\(z\\)为一个相对低维空间中的随机向量。 这个生成模型的联合概率密度函数可以表达为： \\[p(x,z;\\theta)=p(x|z;\\theta)p(z;\\theta)\\] 其中\\(p(z;\\theta)\\)为隐变量\\(z\\)的先验概率分布；\\(p(x|z;\\theta)\\)为已知\\(z\\)条件下\\(x\\)的概率分布。通常情况下，我们可以假设\\(p(z;\\theta)\\)和\\(p(x|z;\\theta)\\)服从某种带参的分布族，其形式已知，而参数可以通过最大似然来进行估计。 给定一个样本\\(x\\)，其对数边际似然\\(\\log p(x;\\theta)\\)可以分解为： \\[\\log p(x;\\theta)=ELBO(q,x;\\theta,\\phi)+D_{KL}(q(z;\\phi)\\parallel p(z|x;\\theta))\\] 其中\\(q(z;\\phi)\\)为额外引入的变分密度函数，\\(ELBO(q,x;\\theta,\\phi)\\)为证据下界： \\[ELBO(q,x;\\theta,\\phi)=\\mathbb{E}_{z\\sim q(z;\\phi)}[\\log{\\frac{p(x,z;\\theta)}{q(z;\\phi)}}]\\] 最大化\\(\\log p(x;\\theta)\\)可以用EM算法来求解： E-step: 寻找一个密度函数\\(q(z;\\phi)\\)使其等于或接近于后验密度函数\\(p(z|x;\\theta)\\); M-step: 保持\\(q(z;\\phi)\\)固定，寻找\\(\\theta\\)来最大化\\(ELBO(q,x;\\theta,\\phi)\\)。 在EM算法的每次迭代中，理论上最优的\\(q(z;\\phi)\\)为隐变量的后验概率密度函数\\(p(z|x;\\theta)\\)： \\[p(z|x;\\theta)=\\frac{p(x|z;\\theta)p(z;\\theta)}{\\int_z p(x|z;\\theta)p(z;\\theta)\\text{d}z}\\] 后验密度函数\\(p(z|x;\\theta)\\)的计算是一个统计推断的问题，在一般情况下\\(p(x|z;\\theta)\\)也比较难以计算。 Variational Autoencoder 变分自编码器(Variational Autoencoder, VAE)的主要思想是利用神经网络来分别建模两个复杂的条件概率密度函数： 用神经网络来产生变分分布\\(q(z;\\phi)\\)，称为推断网络。推断网络的输入为\\(x\\)，输出为变分分布\\(q(z|x;\\phi)\\)； 用神经网络来产生概率分布\\(p(x|z;\\theta)\\)，称为生成网络。生成网络的输入为\\(z\\)，输出为概率分布\\(p(x|z;\\theta)\\)。 VAE的图模型如下图所示： Variational Network 假设\\(q(z|x;\\phi)\\)是服从对角化协方差的高斯分布： \\[q(z|x;\\phi)=\\mathcal{N}(z;\\mu_I,\\sigma^2_I I)\\] 其中\\(\\mu_I\\)和\\(\\sigma_I^2\\)是高斯分布的均值和方差，可以通过推断网络\\(f_I(x;\\phi)\\)来预测： \\[ \\left[\\begin{matrix}\\mu_I\\\\\\sigma_I\\end{matrix}\\right]=f_I(x;\\phi) \\] 推断网络\\(f_I(x;\\phi)\\)可以是一般的全连接网络或卷积网络，比如一个两层的神经网络： \\[\\begin{align}h&amp;=\\sigma(W^{(1)}x+b^{(1)})\\\\\\mu_I&amp;=W^{(2)}h+b^{(2)}\\\\\\sigma_I&amp;=\\text{softplus}(W^{(3)}h+b^{(3)})\\end{align}\\] 其中所有网络参数\\(\\{W^{(1)},W^{(2)},W^{(3)},b^{(1)},b^{(2)},b^{(3)}\\}\\)即对应了变分参数\\(\\phi\\)。 推断网络的目标是使得\\(q(z|x;\\phi)\\)来尽可能接近真实的后验\\(p(z|x;\\theta)\\)，需要找到变分参数\\(\\phi^*\\)来最小化两个分布的KL散度： \\[\\phi^*=\\text{arg}_\\phi\\min{D_{KL}(q(z|x;\\phi)\\parallel p(z|x;\\theta))}\\] 由于\\(p(z|x;\\theta)\\)未知，故KL散度无法直接计算，不过由于\\(D_{KL}(q(z|x;\\phi)\\parallel p(z|x;\\theta))=\\log p(x;\\theta)-ELBO(q,x;\\theta,\\phi)\\)，所以可以直接最大化证据下界，有： \\[\\phi^*=\\text{arg}_\\phi\\max{ELBO(q,x;\\theta,\\phi)}\\] Generative Network 生成模型的联合分布可以分解为两部分：隐变量\\(z\\)的先验分布\\(p(z;\\theta)\\)和条件概率分布\\(p(x|z;\\theta)\\)。为简单起见，一般假设隐变量\\(z\\)的先验分布为标准正态分布\\(\\mathcal{N}(z|0,I)\\)，隐变量每一维之间都是独立的。条件概率分布\\(p(x|z;\\theta)\\)可以通过生成网络来建模，我们同样用参数化的分布族来表示条件概率分布\\(p(x|z;\\theta)\\)，这些分布族的函数可以用生成网络计算得到。根据变量\\(x\\)的类型不同，可以假设\\(p(x|z;\\theta)\\)服从不同的分布族。如果\\(x\\in\\{0,1\\}^d\\)是\\(d\\)维的二值向量，可以假设\\(\\log p(x|z;\\theta)\\)服从多变量的伯努利分布，即： \\[\\begin{align}p(x|z;\\theta)&amp;=\\prod\\limits_{i=1}^d p(x_i|z;\\theta)\\\\&amp;=\\prod\\limits_{i=1}^d \\gamma_i^{x_i}(1-\\gamma_i)^{(1-x_i)}\\end{align}\\] 如果\\(x\\in\\mathbb{R}^d\\)是\\(d\\)维的连续向量，可以假设\\(p(x|z;\\theta)\\)服从对角化协方差的高斯分布，即： \\[p(x|z;\\theta)=\\mathcal{N}(x;\\mu_G,\\sigma_G^2 I)\\] 生成网络的目标是找到一组\\(\\theta^*\\)最大化证据下界\\(ELBO(q,x;\\theta,\\phi)\\)： \\[\\theta^*=\\text{arg}_\\theta\\max ELBO(q,x;\\theta,\\phi)\\] Model Combination 推断网络和生成网络的目标都是最大化证据下界因此总的目标函数为： \\[\\begin{align}\\max_{\\theta,\\phi}ELBO(q,x;\\theta,\\phi)&amp;=\\max_{\\theta,\\phi}\\mathbb{E}_{z\\sim q(z;\\phi)}[\\log\\frac{p(x|z;\\theta)p(z;\\theta)}{q(z;\\theta)}]\\\\&amp;=\\max_{\\theta,\\phi}\\mathbb{E}_{z\\sim q(z|x;\\phi)}[\\log p(x|z;\\theta)]-D_{KL}(q(z|x;\\phi)\\parallel p(z;\\theta))\\end{align}\\] 其中先验分布\\(p(z;\\theta)=\\mathcal{N}(z|0,I)\\)。 公式中\\(\\mathbb{E}_{z\\sim q(z|x;\\phi)}[\\log p(x|z;\\theta)]\\)一般通过采样的方式进行计算，最后取平均值。 Model Training 给定数据集\\(\\mathcal{D}\\)，包含\\(N\\)个从未知数据分布中抽取的独立同分布样本\\(x^{(1)},x^{(2)},\\cdots,x^{(N)}\\)。变分自编码器的目标函数为： \\[\\mathcal{J}(\\phi,\\theta|\\mathcal{D})=\\sum\\limits_{n=1}^N(\\frac{1}{M}\\sum\\limits_{m=1}^M\\log p(x^{(n)}|z^{(n,m)};\\theta)-D_{KL}(q(z|x^{(n)};\\phi)\\parallel\\mathcal{N}(z;0,I)))\\] 如果采用随机梯度下降法，每次从数据集中采一个样本\\(x\\)，然后根据\\(q(z|x;\\phi)\\)采一个隐变量\\(z\\)，则目标函数变为： \\[\\mathcal{J}(\\phi,\\theta|x)=\\log p(x|z;\\theta)-D_{KL}(q(z|x;\\phi)\\parallel\\mathcal{N}(z;0,I))\\] 假设\\(q(z|x;\\phi)\\)是正态分布，KL散度可直接算出： \\[D_{KL}(\\mathcal{N}(\\mu_1,\\Sigma_1)\\parallel\\mathcal(\\mu_2,\\Sigma_2))\\\\=\\frac{1}{2}(\\text{tr}(\\sigma_I^2 I)+\\mu_I^T\\mu_I-d-\\log(|\\sigma_I^2 I|))\\] 再参数化是将一个参数为\\(u\\)的函数\\(f(u)\\)，通过一个函数\\(u=g(v)\\)，转换为参数为\\(v\\)的函数\\(\\hat{f}(v)=f(g(v))\\)。在变分自编码器中，一个问题是如何求随机变量\\(z\\)关于\\(\\phi\\)的导数。但由于是采样的方式，无法直接刻画\\(z\\)和\\(\\phi\\)之间的函数关系，因此也无法计算导数。 如果\\(z\\sim q(z|x;\\phi)\\)的随机性独立于参数\\(\\phi\\)，我们可以通过再参数化的方法来计算导数。假设\\(q(z|x;\\phi)\\)为正态分布\\(\\mathcal{N}(\\mu_I,\\sigma^2_I I)\\)，其中\\(\\mu_I\\)和\\(\\sigma_I\\)是推断网络\\(f_I(x;\\phi)\\)的输出。我们可以通过下面的方式采样\\(z\\)： \\[z=\\mu_I+\\sigma_I\\odot \\varepsilon\\] 其中\\(\\varepsilon\\sim\\mathcal{N}(0,I)\\)。这样\\(z\\)和\\(\\mu_I,\\sigma_I\\)的关系从采样关系变为函数关系。 如果进一步假设\\(p(x|z;\\theta)\\)服从高斯分布\\(\\mathcal{N}(x|\\mu_G,I)\\)，其中\\(\\mu_G=f_G(z;\\theta)\\)是生成网络的输出，则目标函数可以简化为： \\[\\mathcal{J}(\\phi,\\theta|x)=-\\parallel x-\\mu_G\\parallel^2+D_{KL}(\\mathcal{N}(\\mu_I,\\sigma_I)\\parallel\\mathcal{N}(0,I))\\] 其中第一项可以近似看作是输入\\(x\\)的重构正确性，第二项可以看作是正则化项。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Tutorial","slug":"Research/Tutorial","permalink":"http://qfxiao.me/categories/Research/Tutorial/"}],"tags":[{"name":"Variational Inference","slug":"Variational-Inference","permalink":"http://qfxiao.me/tags/Variational-Inference/"},{"name":"VAE","slug":"VAE","permalink":"http://qfxiao.me/tags/VAE/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"}]},{"title":"Recurrent Neural Networks for Multivariate Time Series with Missing Values","slug":"Recurrent-Neural-Networks-for-Multivariate-Time-Series-with-Missing-Values","date":"2019-10-18T15:17:07.000Z","updated":"2020-06-25T08:25:06.176Z","comments":true,"path":"2019/10/18/Recurrent-Neural-Networks-for-Multivariate-Time-Series-with-Missing-Values/","link":"","permalink":"http://qfxiao.me/2019/10/18/Recurrent-Neural-Networks-for-Multivariate-Time-Series-with-Missing-Values/","excerpt":"","text":"Abstract 文中提出了一种可以处理带缺失值多为时间序列的GRU模型：GRU-D。本模型不仅可以捕捉时间序列中的长期依赖模式，并且还能利用时间序列中的缺失模式来达到更好的时间序列预测效果。 原文 Methodology Notations 记包含\\(D\\)个变量的多变量时间序列为\\(X=(x_1,x_2,\\cdots,x_T)^T\\in\\mathbb{R}^{T\\times D}\\)，其中对于每个\\(t\\in\\{1,2,\\cdots,T\\},x_t\\in\\mathbb{R}^D\\)表示时间序列在时间\\(t\\)的观测值，\\(x_t^d\\)表示\\(x_t\\)的第\\(d\\)个成分。记\\(s_t\\in\\mathbb{R}\\)为\\(t\\)时刻的时间戳，并假设第一个观测值的时间戳为\\(0\\)。对于包含缺失值的时间序列，我们用Masking Vector \\(m_t\\in\\{0,1\\}\\)进行标记，同时对每个\\(x_t^d\\)维护距离上一个观测值的Time Interval \\(\\delta_t^d\\in\\mathbb{R}\\)，公式如下： \\[ m_t^d=\\begin{cases}1, &amp;\\text{if }x_t^d\\text{ is observed}\\\\0, &amp;\\text{otherwise}\\end{cases} \\] \\[ \\delta_t^d=\\begin{cases}s_t-s_{t-1}+\\delta_{t-1}^d, &amp;t&gt;1,m_{t-1}^d=0\\\\s_t-s_{t-1}, &amp;t&gt;1, m_{t-1}^d=1\\\\0, &amp;t=1\\end{cases} \\] 下图是一些示例： 在本文中，我们主要关注时间序列的分类问题，即给定数据集\\(\\mathcal{D}=\\{(X_n,s_n,M_n)\\}_{n=1}^N\\)，我们要对每个样本的类别进行预测\\(l_n\\in\\{1,\\cdots,L\\}\\)。 GRU-RNN for Time Series Classification GRU是一种改进版本的RNN，其最大不同是加入了门控机制。GRU单元的结构如下图所示： GRU包含了重置门和更新门，其中重置门\\(R_t\\)负责控制上一时间的隐状态\\(h_{t-1}\\)有多少部分需要保留，而更新门则决定由\\(R_t\\)计算出来的候选隐状态\\(\\tilde{h}_t\\)有多少部分需要保留。最后当前时间的隐状态由\\(h_{t-1}\\)和\\(\\tilde{h}_t\\)共同算出。GRU的状态更新公式如下： \\[ \\begin{align} R_t&amp;=\\sigma(W_rx_t+U_rh_{t-1}+b_r)\\\\ Z_t&amp;=\\sigma(W_zx_t+U_zh_{t-1}+b_z)\\\\ \\tilde{h}_t&amp;=\\text{tanh}(Wx_t+U(R_t\\odot h_{t-1})+b)\\\\ h_t&amp;=(1-Z_t)\\odot h_{t-1}+Z_t\\odot \\tilde{h}_t \\end{align} \\] 文中提出了一些处理缺失值的简单方法： 直接用均值替代：\\(x_t^d\\leftarrow m_t^dx_t^d+(1-m_t^d)\\tilde{x}^d\\)，其中\\(\\tilde{x}^d=\\frac{\\sum_{n=1}^N\\sum_{t=1}^{T_n}m_{t,n}^d x_{t,n}^d}{\\sum_{n=1}^N\\sum_{t=1}^{T_n}m_{t,n}^d\\tilde{x}^d}\\)。这种方法称为GRU-Mean； 用上一个观测值替代：\\(x_t^d\\leftarrow m_t^d x_t^d+(1-m_t^d)x_{t^\\prime}^d\\)。这种方法称为GRU-Forward； 不填充，将是否缺失，距离上一个观测值的时间作为额外信息输入：\\(x_t^{(n)}\\leftarrow[x_t^{(n)};m_t^{(n)};\\delta_t^{(n)}]\\)。这种方法称为GRU-Simple。 GRU-D: Model with Trainable Decays 文中提出了时间序列缺失值的两个性质：一个是在上一个观测值距离很远的情况下缺失值倾向于接近一个默认的值，第二个是缺失值的影响会随着时间减弱。为了体现上述两点，文中提出了GPU-D模型，模型框架如下： 在模型中，Decay Rates被设定为一个带参数的函数和GRU一起训练： \\[ \\gamma_t=\\exp\\{-\\max(0,W_\\gamma\\delta_t+b_\\gamma)\\} \\] \\[ \\hat{x}_t^d=m_t^dx_t^d+(1-m_t^d)(\\gamma_{x_t}^dx_{t^\\prime}^d+(1-\\gamma_{x_t}^d)\\tilde{x}^d) \\] 其中\\(x_{t^\\prime}^d\\)是第\\(d\\)个变量的上一个观测值，\\(\\tilde{x}^d\\)是第\\(d\\)个变量的经验均值。这样\\(\\hat{x}_t^d\\)就代表经过Input Decay的输入。 文中提到只用Input Decay是不够的，除此之外作者还使用了Hidden State Decay，即对\\(h_{t-1}\\)进行Decay，公式如下： \\[ \\hat{h}_{t-1}=\\gamma_{h_t}\\odot h_{t-1} \\] 用Decay之后的\\(\\hat{x}_t\\)和\\(\\hat{h}_{t-1}\\)替换原始的GRU公式就得到了GRU-D模型： \\[ \\begin{align} R_t&amp;=\\sigma(W_r\\hat{x}_t-U_r\\hat{h}_{t-1}+V_rm_t+b_r)\\\\ Z_t&amp;=\\sigma(W_z\\hat{x}_t+U_z\\hat{h}_{t-1}+V_zm_t+b_z)\\\\ \\tilde{h}_t&amp;=\\text{tanh}(W\\hat{x}_t+U(R_t\\odot \\hat{h}_{t-1})+Vm_t+b)\\\\ h_t&amp;=(1-z_t)\\odot \\hat{h}_{t-1}+z_t\\odot\\tilde{h}_t \\end{align} \\] Experiments Baseline Imputation Methods 下图为文中比较中用到的Baseline： Baseline Prediction Methods 下图为文中用到的用来预测的Baseline： Results 文中用到的数据集如下： Gesture phase segmentation dataset (Gesture). PhysioNet Challenge 2012 dataset (PhysioNet). MIMIC-Ⅲ dataset (MIMIC-Ⅲ). 下图展示了不同方法在人工合成数据集上的表现： 下表展示了不同模型在预测任务表现的对比： 下表展示了不同方法在MIMIC-Ⅲ和PhysioNet数据集上的多任务表现： 下图分别展示了模型学到的Input Decay和Hidden State Decay：","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"RNN","slug":"Research/RNN","permalink":"http://qfxiao.me/categories/Research/RNN/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"RNN","slug":"RNN","permalink":"http://qfxiao.me/tags/RNN/"}]},{"title":"Robust Anomaly Detection for Multivariate Time Series through Stochastic Recurrent Neural Network","slug":"Robust-Anomaly-Detection-for-Multivariate-Time-Series-through-Stochastic-Recurrent-Neural-Network","date":"2019-10-18T15:00:57.000Z","updated":"2020-09-12T02:54:14.061Z","comments":true,"path":"2019/10/18/Robust-Anomaly-Detection-for-Multivariate-Time-Series-through-Stochastic-Recurrent-Neural-Network/","link":"","permalink":"http://qfxiao.me/2019/10/18/Robust-Anomaly-Detection-for-Multivariate-Time-Series-through-Stochastic-Recurrent-Neural-Network/","excerpt":"","text":"Abstract 本文提出了OmniAnomaly：一种针对多变量时间序列的随机循环神经网络异常检测算法。该模型运用了一系列技术来捕捉多变量时间序列的正常模式，并在检测阶段基于重构误差来检测异常，同时本文还提供了一定的理论解释。 原文 Contribution 提出了OmniAnomaly，一种基于随机循环神经网络的多变量时间序列异常检测算法； 提出了针对多变量时间序列异常检测的解释方法； 通过实验证明了OmniAnomaly中所用的关键技术的有效性，包括GRU，planar NF, stochastic variable connection和adjusted Peaks-Over-Threshold method； 通过大量的实验我们证明了OmniAnomaly的有效性； 发布了代码和数据集。 Background Linear Gaussian State Space Model 状态空间模型（State Space Model, SSM）的概念来自于控制理论，在这里我们主要讨论其在时间序列中的应用。其大概思想是我们认为时间序列在时刻\\(t\\)的观测值\\(z_t\\)是一个隐含状态\\(\\boldsymbol{l}_t\\)的条件分布\\(p(z_t|\\boldsymbol{l}_t)\\)，而这个隐含状态\\(\\boldsymbol{l}_t\\)刻画了时间序列的内在规律，同时隐含状态会随着时间更新，即服从条件分布\\(p(\\boldsymbol{l}_t|\\boldsymbol{l}_{t-1})\\)。 在线性状态空间模型（Linear State Space Model）中我们以如下的方式刻画隐含状态的更新： \\[ \\boldsymbol{l}_t=\\boldsymbol{F}_t\\boldsymbol{l}_{t-1}+\\boldsymbol{g}_t\\varepsilon_t, \\space\\space\\space\\varepsilon_t\\sim\\mathcal{N}(0,1) \\] \\(\\boldsymbol{F}_t\\)为确定的状态转移矩阵，而\\(\\boldsymbol{g}_t\\varepsilon_t\\)则表示了状态转移的随机性。 观测值\\(z_t\\)从隐含状态\\(\\boldsymbol{l}_t\\)计算而来： \\[ \\begin{align} z_t&amp;=y_t+\\sigma_t\\epsilon_t,\\\\ y_t&amp;=\\boldsymbol{a}_t^\\top\\boldsymbol{l}_{t-1}+b_t,\\\\ \\epsilon_t&amp;\\sim\\mathcal{N}(0,1) \\end{align} \\] 其中\\(\\boldsymbol{a}_t\\in\\mathbb{R}^L,\\sigma_t\\in \\mathbb{R},b_t\\in\\mathbb{R}\\)都是额外的参数。初始状态\\(\\boldsymbol{l}_0\\)则从一个独立的高斯分布得来，即\\(\\boldsymbol{l}_0\\sim N(\\boldsymbol\\mu_0,\\text{diag}(\\boldsymbol{\\sigma}_0^2))\\)。 令参数集合\\(\\Theta_t=(\\boldsymbol{\\mu}_0,\\boldsymbol{\\Sigma}_0,\\boldsymbol{F}_t,\\boldsymbol{g}_t,\\boldsymbol{a}_t,b_t,\\sigma_t),\\forall t&gt;0\\)，一般来说参数集合不会随着时间变化，即每个时刻\\(t\\)共享同样的参数\\(\\Theta_t=\\Theta,\\forall t&gt;0\\)。对参数的估计可以采用极大似然估计： \\[ \\begin{align} \\Theta^*_{1:T}&amp;=\\arg\\max_{\\Theta_{1:T}}p(z_{1:T}|\\Theta_{1:T}),\\\\ \\end{align} \\] 其中： \\[ \\begin{align} p(z_{1:T}|\\Theta_{1:T})&amp;=p(z_1|\\Theta_1)\\prod\\limits_{t=2}^T p(z_t|z_{1:t-1},\\Theta_{1:t})\\\\ &amp;=\\int p(\\boldsymbol{l}_0)\\left[\\prod\\limits_{t=1}^T p(z_t|\\boldsymbol{l}_t)p(\\boldsymbol{l}_t|\\boldsymbol{l}_{t-1})\\right]\\mathrm{d}\\boldsymbol{l}_{0:T} \\end{align} \\] Planar Normalizing Flow Normalizing Flows VAE采用一个变分分布\\(q_\\phi(z|x)\\)来近似真实的后验分布\\(p(z|x)\\)，并推导出\\(\\log p_\\theta(x)\\)的下界（称为ELBO）来作为优化目标函数： \\[ \\begin{align} \\log p_\\theta(x)&amp;=\\log \\int p_\\theta(x|z)p(z)\\mathrm{d}z\\\\ &amp;=\\log\\int\\frac{q_\\phi(z|x)}{q_\\phi(z|x)}p_\\theta(x|z)p(z)\\mathrm{d}z\\\\ &amp;\\geq-D_{KL}[q_\\phi(z|x)\\parallel p(z)]+\\mathbb{E}_q[\\log p_\\theta(x|z)] \\end{align} \\] \\(\\log p_\\theta(x)\\)与ELBO取等的条件是\\(D_{KL}[q_\\phi(z|x)\\parallel p(z)]\\)，表明变分分布完全匹配了真实的后验分布。但在实际应用中，真实的后验分布可能会非常复杂，而我们的变分分布通常是一个确定的较为简单的分布，如高斯分布。这样变分分布可能很难对真实后验分布得到一个很好的拟合。 一个解决方案是使用标准化流（Normalizing Flows）。标准化流是从一个相对简单的分布出发，执行一系列可逆的映射，将原始简单的分布转化为一个复杂的分布。 首先考虑一个光滑的、可逆的映射\\(f:\\mathbb{R}^d\\mapsto \\mathbb{R}^d\\)，记\\(g=f^{-1}\\)，那么\\(g\\circ f(\\mathbf{z})=\\mathbf{z}\\)。令\\(\\mathbf{z}^\\prime=f(\\mathbf{z})\\)，那么\\(\\mathbf{z}^\\prime\\)的分布为： \\[ q(\\mathbf{z}^\\prime)=q(\\mathbf{z})\\left|\\text{det}\\frac{\\partial f^{-1}}{\\partial \\mathbf{z}^\\prime}\\right|=q(z)\\left|\\text{det}\\frac{\\partial f}{\\partial \\mathbf{z}}\\right|^{-1} \\] 式中\\(q(\\mathbf{z}^\\prime)=q(z)\\left|\\text{det}\\frac{\\partial f}{\\partial \\mathbf{z}}\\right|^{-1}\\)说明了\\(\\mathbf{z}^\\prime\\)的分布等于\\(\\mathbf{z}\\)的分布乘上\\(f\\)的Jacobian矩阵的行列式的倒数。那么对于映射多次的情况： \\[ \\mathbf{z}_K=f_K\\circ\\cdots\\circ f_2\\circ f_1(\\mathbf{z}_0) \\] \\(\\mathbf{z}_K\\)的分布可以通过链式计算得到： \\[ \\ln q_K(\\mathbf{z}_K)=\\ln q_0(\\mathbf{z}_0)-\\sum\\limits_{k=1}^K\\ln\\left|\\text{det}\\frac{\\partial f_k}{\\partial \\mathbf{z}_{k-1}}\\right| \\] Planar Flows 考虑一个变换族： \\[ f(\\mathbf{z})=\\mathbf{z}+\\mathbf{u}h(\\mathbf{w}^\\top\\mathbf{z}+b) \\] 其中\\(\\lambda=\\{\\mathbf{w}\\in \\mathbb{R}^d,\\mathbf{u}\\in\\mathbb{R}^d,b\\in\\mathbb{R}\\}\\)为参数集合，\\(h(\\cdot)\\)为元素级的非线性函数（如各种激活函数）。令\\(\\psi(\\mathbf{z})=h^\\prime(\\mathbf{w}^\\top\\mathbf{z}+b)\\mathbf{w}\\)，则\\(f\\)的Jacobian矩阵行列式绝对值等于： \\[ \\left|\\text{det}\\frac{\\partial f}{\\partial \\mathbf{z}}\\right|=\\left|\\text{det}(\\mathbf{I}+\\mathbf{u}\\psi(\\mathbf{z})^\\top)\\right|=\\left|1+\\mathbf{u}^\\top\\psi(\\mathbf{z})\\right| \\] 但是\\(f\\)并不保证总是可逆的，如\\(h(x)=\\tanh(x)\\)时，\\(f\\)可逆的条件是\\(\\mathbf{w}^\\top \\mathbf{u}\\geq-1\\)。 下面讨论如何保证可逆的条件。考虑将\\(\\mathbf{z}\\)分解为\\(\\mathbf{z}=\\mathbf{z}_\\bot+\\mathbf{z}_\\parallel\\)，其中\\(\\mathbf{z}_\\bot\\)与\\(\\mathbf{w}\\)正交，\\(\\mathbf{z}_\\parallel\\)与\\(\\mathbf{w}\\)平行，那么： \\[ f(z)=\\mathbf{z}_\\bot+\\mathbf{z}_\\parallel+\\mathbf{u}h(\\mathbf{w}^\\top \\mathbf{z}_\\parallel +b) \\] 实际上得到\\(\\mathbf{z}_\\parallel\\)之后可以很容易的得到\\(\\mathbf{z}_\\bot\\)，令\\(\\mathbf{y}=f(\\mathbf{z})\\)，有： \\[ \\mathbf{z}_\\bot=\\mathbf{y}-\\mathbf{z}_\\parallel-\\mathbf{u}h(\\mathbf{w}^\\top\\mathbf{z}_\\parallel+b) \\] 而\\(\\mathbf{z}_\\parallel\\)与\\(\\mathbf{w}\\)平行，易知\\(\\mathbf{z}_\\parallel=\\alpha\\frac{\\mathbf{w}}{\\parallel\\mathbf{w}\\parallel^2}\\)，其中\\(\\alpha\\in\\mathbb{R}\\)。 对式(16)两边同时乘以\\(\\mathbf{w}^\\top\\)可得： \\[ \\mathbf{w}^\\top f(\\mathbf{z})=\\alpha+\\mathbf{w}^\\top\\mathbf{u} h(\\alpha+b) \\] 当\\(\\alpha+\\mathbf{w}^\\top\\mathbf{u} h(\\alpha+b)\\)对于\\(\\alpha\\)是非递减函数的时候，\\(f\\)是可逆的。因为\\(\\alpha+\\mathbf{w}^\\top\\mathbf{u} h(\\alpha+b)\\)是非递减函数时有\\(1+\\mathbf{w}^\\top\\mathbf{u}h^\\prime(\\alpha+b)\\geq 0\\equiv \\mathbf{w}^\\top \\mathbf{u}\\geq -\\frac{1}{h^\\prime(\\alpha + b)}\\)，而\\(0\\leq h^\\prime(\\alpha + b) \\leq 1\\)（\\(\\tanh\\)函数的性质），所以总是有\\(\\mathbf{w}^\\top \\mathbf{u}\\geq-1\\)。 对于任意一个\\(\\mathbf{u}\\)，我们可以通过特定的方式构造一个\\(\\hat{\\mathbf{u}}\\)使得\\(\\mathbf{w}^\\top\\hat{\\mathbf{u}}&gt;-1\\)，即令\\(\\hat{\\mathbf{u}}(\\mathbf{w},\\mathbf{u})=\\mathbf{u}+[m(\\mathbf{w}^\\top\\mathbf{u})-(\\mathbf{w}^\\top\\mathbf{u})]\\frac{\\mathbf{w}}{\\parallel\\mathbf{w}\\parallel^2}\\)，其中\\(m(x)=-1+\\log(1+e^x)\\)。 Methodology Problem Statement 本文针对的是多变量时间序列\\(x=\\{x_1,x_2,\\cdots,x_N\\}\\in R^{M\\times N}\\)，\\(N\\)为时间长度，其中某一时刻的观测值\\(x_t\\in R^M\\)为一个\\(M\\)维的向量。作者使用\\(x_{t-T:t}\\in R^{M\\times(T+1)}\\)来表示\\(t-T\\)到\\(t\\)之间的时间序列。 Overall Structure 算法的总体框架如下图所示： 预处理模块主要是对数据进行标准化以及窗口切分。训练模块则根据输入的数据对正常模式进行捕捉，输出异常分数。在线检测模块则会定期执行。 Network Architecture 模型的总体结构如下图所示： 在qnet中，首先GRU被用来建模样本的时间依赖关系，之后VAE将样本\\(\\mathbf{x}\\)映射到隐空间\\(\\mathbf{z}\\)。文中使用了Linear Gaussian State Space Model来建模隐变量之间的时间依赖关系。除此之外，作者还使用了Planar Normalizing Flow来将隐变量映射到复杂的非高斯分布。在pnet中，隐变量\\(\\mathbf{z}_{t-T:t}\\)被用来重建\\(\\mathbf{x}_{t-T:t}\\)，直观上来说，对样本的好的隐变量表示可以带来更好的重构效果。 从细节上来说，在时间\\(t\\)，qnet的输入为\\(\\mathbf{x}_t\\)和\\(\\mathbf{e}_{t-1}\\)，两者经过GRU Cell之后会产生\\(t\\)时间的\\(\\mathbf{e_t}\\)。\\(\\mathbf{e}_t\\)是GRU捕捉时间依赖性的关键，可以认为它包含了\\(\\mathbf{x}_{1:t}\\)的信息。之后\\(\\mathbf{e}_t\\)会和\\(\\mathbf{z}_{t-1}\\)进行拼接，进入标准的VAE变分网络结构，通过网络输出的参数\\(\\mu_{z_t},\\sigma_{z_t}\\)采样得到隐变量\\(\\mathbf{z}_t^0\\)，此时隐变量可以说捕捉了时间依赖性。 网络中涉及到的公式如下所示： \\[ \\begin{align} e_t&amp;=(1-c_t^e)\\circ\\text{tanh}(w^ex_t+u^e(r_t^e\\circ e_{t-1})+b^e)+c_t^e\\circ e_{t-1}\\\\ \\mu_{z_t}&amp;=w^{\\mu_z}h^\\phi([z_{t-1},e_t])+b^{\\mu_z}\\\\ \\sigma_{z_t}&amp;=\\text{softplus}(w^{\\sigma_z}h^\\phi([z_{t-1},e_t])+b^{\\sigma_z})+\\epsilon^{\\sigma_z} \\end{align} \\] 其中\\(r_t^e=\\text{sigmoid}(\\mathbf{w}^{r^e}\\mathbf{x}_t+\\mathbf{u}^{r^e}\\mathbf{e}_{t-1}+b^{r^e})\\)是GRU中的重置门，\\(c_t^e=\\text{sigmoid}(\\mathbf{w}^{c^e}\\mathbf{x}_t+\\mathbf{u}^{c^e}\\mathbf{e}_{t-1}+b^{c^e})\\)是GRU中的更新门。 此时\\(\\mathbf{z}_t^0\\)服从高斯分布，为了拟合复杂的后验分布，我们使用Planar Normalizing Flow来对\\(\\mathbf{z}_t^0\\)进行变换，最后得到经\\(K\\)次变换后的随机变量\\(\\mathbf{z}_t^K\\)。 在时间\\(t\\)，pnet试图通过\\(\\mathbf{z}_t^K\\)来重构\\(\\mathbf{x}_t\\)。首先\\(\\mathbf{z}\\)空间中的变量会根据Linear Gaussian State Space Model来进行“连接“，公式为\\(\\mathbf{z}_t=\\mathbf{O}_\\theta(\\mathbf{T}_\\theta\\mathbf{z}_{t-1}+\\mathbf{v}_t)+\\boldsymbol{\\epsilon}_t\\)，其中\\(\\mathbf{O}_\\theta\\)和\\(\\mathbf{T}_\\theta\\)为状态转移矩阵，\\(\\mathbf{v}_t\\)和\\(\\boldsymbol{\\epsilon}_t\\)为随机噪声。之后\\(\\mathbf{z}_t\\)和\\(\\mathbf{d}_{t-1}\\)会作为GRU的输入，产生\\(\\mathbf{d}_t\\)。之后\\(\\mathbf{d}_t\\)会经过标准VAE中的生成网络，通过网络输出的高斯分布参数\\(\\mu_{x_t},\\sigma_{x_t}\\)采样得到重构后的样本\\(\\mathbf{x}^\\prime_t\\)。pnet中涉及到的公式如下所示： \\[ \\begin{align} d_t&amp;=(1-c_t^d)\\circ\\text{tanh}(w^dz_t+u^d(r_t^d\\circ d_{t-1})+b^d)+c_t^d\\circ d_{t-1}\\\\ \\mu_{x_t}&amp;=w^{\\mu_x}h^\\theta(d_t)+b^{\\mu_x}\\\\ \\sigma_{x_t}&amp;=\\text{softplus}(w^{\\sigma_x}h^\\theta(d_t)+b^{\\sigma_x})+\\epsilon^{\\sigma_x} \\end{align} \\] 其中\\(r_t^d=\\text{sigmoid}(\\mathbf{w}^{r^d}\\mathbf{x}_t+\\mathbf{u}^{r^d}\\mathbf{d}_{t-1}+b^{r^d})\\)是GRU中的重置门，\\(c_t^d=\\text{sigmoid}(\\mathbf{w}^{c^d}\\mathbf{x}_t+\\mathbf{u}^{c^d}\\mathbf{d}_{t-1}+b^{c^d})\\)是GRU中的更新门。 Offline Model Training 和传统VAE类似，模型的训练可以通过优化ELBO来完成。记长度为\\(T+1\\)的输入序列为\\(\\mathbf{x}_{t-T:t}\\)，隐空间变量采样次数为\\(L\\)，第\\(l\\)个隐空间变量为\\(\\mathbf{l}^{(l)}_{t-T:t}\\)，损失函数可以写成如下形式： \\[ \\tilde{\\mathcal{L}}(\\mathbf{x}_{t-T:t})\\approx\\frac{1}{L}\\sum_{t=1}^L[\\log(p_\\theta(\\mathbf{x}_{t-T:t}|\\mathbf{z}_{t-T:t}^{(l)}))+\\log(p_\\theta(\\mathbf{z}_{t-T:t}^{(l)}))-\\log(q_\\phi(\\mathbf{z}_{t-T:t}^{(l)}|\\mathbf{x}_{t-T:t}))] \\] 第一项\\(\\log(p_\\theta(\\mathbf{x}_{t-T:t}|\\mathbf{z}_{t-T:t}^{(l)}))\\)可以看作是重构误差；第二项\\(\\log(p_\\theta(\\mathbf{z}_{t-T:t}))=\\sum_{i=t-T}^t \\log(p_\\theta(\\mathbf{z}_i|\\mathbf{z}_{i-1}))\\)通过Linear Gaussian State Space Model计算；第三项\\(-\\log(q_\\phi(\\mathbf{z}_{t-T:t}|\\mathbf{x}_{t-T:t}))=-\\sum_{i=t-T}^t\\log(q_\\phi(\\mathbf{z}_i|\\mathbf{z}_{i-1},\\mathbf{x}_{t-T:i}))\\)为隐变量\\(\\mathbf{z}\\)后验分布的估计，同时\\(\\mathbf{z}_i\\)是经Planar Normalizing Flow转换过的。 Online Detection 在训练好模型之后，就可以进行异常检测了。在时间\\(t\\)，我们通过根据长度为\\(T+1\\)的序列\\(\\mathbf{x}_{t-T:t}\\)来重构\\(\\mathbf{x}_t\\)，并根据重构概率\\(\\log(p_\\theta(\\mathbf{x}_t|\\mathbf{z}_{t-T:t}))\\)来判定异常。定义\\(\\mathbf{x}_t\\)对应的异常分数\\(S_t=\\log(p_\\theta(\\mathbf{x}_t|\\mathbf{z}_{t-T:t}))\\)，高异常分数代表样本\\(\\mathbf{x}_t\\)能够以大概率重构（因为模型是用正常样本训练，可以认为模型建模的是正常样本的分布，重构概率高就代表符合正常分布）。给定阈值之后便可根据异常分数来进行异常的判定。 Automatic Threshold Selection 在异常检测阶段，需要根据设定的阈值和每个样本的异常分数来判断该样本是否为异常，所以阈值的选择十分重要。文中用到了一种根据Extreme Value Theory自动选择阈值的算法。对于一个分布，其中的极端事件往往位于分布的末尾，而Extreme Value Theory第一定理给出不管原始分布如何，这些极端事件的分布服从一个带参的分布族。因此，可以在对数据分布未知的情况下估计极端事件的分布。 除了Extreme Value Theory第一定理之外，Extreme Value Theory第二定理给出随机变量大于特定阈值\\(t\\)的分布可以用Generalized Pareto Distribution来描述。作者使用了基于Extreme Value Theory第二定理的Peaks-Over-Threshold算法来进行阈值的选择。因为Extreme Value Theory第二定理给出随机变量大于特定阈值\\(t\\)的分布，而在本文的场景中我们需要刻画的异常点的分布应该是小于一个给定阈值的分布，所以需要修改一下公式。 对于给定的数据，模型会给出对应的异常分数序列\\(\\{S_1,S_2,\\cdots,S_{N^\\prime}\\}\\)，给定预先设定的阈值\\(th\\)，\\(S_i\\)极端部分（即小于\\(th\\)的部分）的分布符合Generalized Pareto Distribution，公式如下： \\[ \\bar{F}(s)=P(th-S&gt;s|S&lt;th)\\sim(1+\\frac{\\gamma s}{\\beta})^{-\\frac{1}{\\gamma}} \\] 其中\\(\\gamma\\)和\\(\\beta\\)为分布的形状参数，本文使用极大似然估计来对参数进行估计。设参数的估计值分别为\\(\\hat{\\gamma}\\)和\\(\\hat{\\beta}\\)，最终的阈值\\(th_F\\)由拟合得到的分布的分位数确定： \\[ th_F\\simeq th-\\frac{\\hat{\\beta}}{\\hat{\\gamma}}((\\frac{qN^\\prime}{N^\\prime_{th}})^{-\\hat{\\gamma}}-1) \\] 其中\\(q\\)为期望\\(S&lt;th\\)的概率，\\(N^\\prime\\)为观测值的数量，\\(N^\\prime_{th}\\)为\\(S_i&lt;th\\)的个数。 Anomaly Interpretation \\[ \\log(p_\\theta(\\mathbf{x}_t|\\mathbf{z}_{t-T:t}))=\\sum_{i=1}^M\\log(p_\\theta(x_t^i|\\mathbf{z}_{t-T:t})) \\] Experiments Datasets and Metrics Overall Performance Effects of Major Techniques Visualization on Z-Space Representations","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"VAE","slug":"VAE","permalink":"http://qfxiao.me/tags/VAE/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"RNN","slug":"RNN","permalink":"http://qfxiao.me/tags/RNN/"},{"name":"Flow-based Model","slug":"Flow-based-Model","permalink":"http://qfxiao.me/tags/Flow-based-Model/"}]},{"title":"GAIN: Missing Data Imputation using Generative Adversarial Nets","slug":"GAIN-Missing-Data-Imputation-using-Generative-Adversarial-Nets","date":"2019-10-16T12:19:10.000Z","updated":"2020-06-25T05:38:07.244Z","comments":true,"path":"2019/10/16/GAIN-Missing-Data-Imputation-using-Generative-Adversarial-Nets/","link":"","permalink":"http://qfxiao.me/2019/10/16/GAIN-Missing-Data-Imputation-using-Generative-Adversarial-Nets/","excerpt":"","text":"Abstract 本文基于GAN提出了一种时间序列缺失值填充（Time Series Imputation）的方法。其主要的思路为生成器\\(G\\)从隐空间\\(Z\\)生成完整的样本，而判别器\\(D\\)则输出样本中不同部分为真实的概率。除此之外，作者提出了使用Hint Vector来揭示原始数据中缺失部分的信息，来优化训练过程。 原文 Methodology Problem Formulation 考虑一个\\(d\\)维的空间\\(\\mathcal{X}=\\mathcal{X}_1\\times \\cdots\\times \\mathcal{X}_d\\)，设\\(\\mathbf{X}=(X_1,\\cdots,X_d)\\)维空间\\(\\mathcal{X}\\)上的随机向量（即理想的完整的时间序列），记其分布为\\(P(\\mathbf{X})\\)。设\\(\\mathbf{M}=(M_1,\\cdots,M_d)\\)为Mask向量表示\\(\\mathbf{X}\\)中被观察到的部分。（即标识时间序列哪些部分有缺失），取值为\\(\\{0,1\\}^d\\)。 对于每一个\\(i\\in\\{1,\\cdots,d\\}\\)，我们定义一个新空间\\(\\tilde{\\mathcal{X}}=\\mathcal{X}\\cup\\{*\\}\\)，其中\\(*\\)表示不属于任意\\(\\mathcal{X}_i\\)的一个点。令\\(\\tilde{\\mathcal{X}}=\\tilde{\\mathcal{X}_1}\\times\\cdots\\times\\tilde{\\mathcal{X}_d}\\)，同时定义一个新的随机变量（即我们观测到的含有缺失值的时间序列）\\(\\tilde{\\mathbf{X}}=(\\tilde{X}_1,\\cdots,\\tilde{X}_d)\\in \\tilde{\\mathcal{X}}\\)： \\[ \\tilde{X}_i=\\begin{cases}X_i,&amp;\\text{if } M_i=1\\\\*,&amp;\\text{otherwise}\\end{cases} \\] 假设数据集的形式为\\(\\mathcal{D}=\\{(\\tilde{x}^i,m^i)\\}^n_{i=1}\\)，我们的任务是从\\(P(\\mathbf{X}|\\tilde{\\mathbf{X}}=\\tilde{x}^i)\\)上采样来对缺失值进行填充。 Model Architecture 模型的架构如下图所示： Generator 生成器的输入有三项：\\(\\tilde{\\mathbf{X}}\\)，\\(\\mathbf{M}\\)和随机噪声\\(\\mathbf{Z}\\)，输出设为\\(\\bar{\\mathbf{X}}\\)。设生成器为映射\\(G: \\tilde{\\mathcal{X}}\\times\\{0,1\\}^d\\times[0,1]^d\\rightarrow \\mathcal{X}\\)，而\\(\\mathbf{Z}\\)为\\(d\\)维的高斯噪声。生成器的输出和填充后的时间序列定义为： \\[ \\begin{align} \\bar{\\mathbf{X}}&amp;=G(\\tilde{\\mathbf{X}},\\mathbf{M},(1-\\mathbf{M})\\odot\\mathbf{Z})\\\\ \\hat{\\mathbf{X}}&amp;=\\mathbf{M}\\odot\\tilde{\\mathbf{X}}+(1-\\mathbf{M})\\odot\\bar{\\mathbf{X}} \\end{align} \\] \\(\\bar{\\mathbf{X}}\\)即为生成器的直接输出，因为其实有些部分没有缺失，生成器还是会为每个部分输出值。 \\(\\hat{\\mathbf{X}}\\)为填充后的时间序列，对于缺失的部分采用生成器的输出进行填充。 Discriminator 和原始的GAN不同的是，我们不需要判断整个样本是真实的或者是生成的，而是需要判断样本的那些部分是真实的或者是生成的，所以判别器为映射\\(D: \\mathcal{X}\\rightarrow[0,1]^d\\)。判别器的具体目标函数将在后面讨论。 Hint Hint是一种提示机值，是一个和\\(\\mathbf{X}\\)相同维度的随机变量\\(\\mathbf{H}\\)，其分布依赖于\\(\\mathbf{M}\\)。\\(\\mathbf{H}\\)是由用户自己定义的，相当于一种不完整的\\(\\mathbf{M}\\)，用来作为判别器的额外输入。 Objective 我们训练判别器最大化正确预测\\(\\mathbf{M}\\)的概率，而生成器最小化判别器正确预测\\(\\mathbf{M}\\)的概率，目标函数如下： \\[ \\begin{align} V(D,G)=&amp;\\mathbb{E}_{\\hat{X},M,H}[\\mathbf{M}^T\\log D(\\hat{\\mathbf{X}},\\mathbf{H})\\\\&amp;+(1-\\mathbf{M})^T\\log(1-D(\\hat{\\mathbf{X}},\\mathbf{H}))] \\end{align} \\] 按照标准的GAN可以将优化函数写成以下的形式： \\[ \\min_G\\max_D V(D,G) \\] 在这里判别器的任务可以看作是一个二分类，而目标函数就是二值交叉熵的定义，因此可以写为： \\[ \\mathcal{L}(a,b)=\\sum\\limits_{i=1}^d[a_i\\log(b_i)+(1-a_i)\\log(1-b_i)] \\] \\(\\mathbf{M}\\)可以看作Ground Truth，记\\(\\hat{\\mathbf{M}}=D(\\hat{\\mathbf{X},\\mathbf{H}})\\)，即判别器输出的预测，因此优化函数可以简记为： \\[ \\min_G\\max_D\\mathbb{E}[\\mathcal{L}(\\mathbf{M},\\hat{\\mathbf{M}})] \\] GAIN Algorithm 下面讨论GAIN算法的训练流程。 本文通过理论讨论，给出了生成Hint Vector的一个方法，首先定义随机变量\\(\\mathbf{B}=(B_1,\\cdots,B_d)\\in\\{0,1\\}^d\\)，\\(\\mathbf{B}\\)通过从\\(\\{1,\\cdots,d\\}\\)随机均匀采样一个\\(k\\)，然后由下列公式得到： \\[ B_j=\\begin{cases}1, &amp;\\text{if }j\\neq k\\\\0, &amp;\\text{if }j=k\\end{cases} \\] 定义空间\\(\\mathcal{H}=\\{0,0.5,1\\}^d\\)，Hint Vector为\\(\\mathbf{H}=\\mathbf{B}\\odot\\mathbf{M}+0.5(1-\\mathbf{B})\\in\\mathcal{H}\\)。 判别器的训练过程如下：固定生成器\\(G\\)，对一个大小为\\(k_D\\)的mini-batch，独立同分布采样\\(k_D\\)个\\(z\\)和\\(b\\)，用来计算\\(\\mathbf{Z}\\)和\\(\\mathbf{B}\\)。判别器的损失函数定义如下： \\[ \\mathcal{L}_D(m,\\hat{m},b)=\\sum\\limits_{i:b_i=0}[m_i\\log(\\hat{m}_i)+(1-m_i)\\log(1-\\hat{m}_i)] \\] 判别器的优化函数为： \\[ \\min_D-\\sum\\limits_{j=1}^{k_D}\\mathcal{L}_D(m(j),\\hat{m}(j),b(j)) \\] 其中\\(\\hat{m}(j)=D(\\hat{x}(j),m(j))\\)。 在优化了判别器之后，需要优化生成器，对一个大小为\\(k_G\\)的mini-batch，生成器的损失函数包含两个部分，一个是在缺失部分的损失： \\[ \\mathcal{L}_G(m,\\hat{m},b)=-\\sum\\limits_{i:b_i=0}(1-m_i)\\log(\\hat{m}_i) \\] 一个是未缺失部分的损失： \\[ \\mathcal{L}_M(x,x^\\prime)=\\sum\\limits_{i=1}^d m_iL_M(x_i,x_i^\\prime) \\] 其中： \\[ L_M(x_i,x_i^\\prime)=\\begin{cases}(x_i^\\prime-x_i)^2, &amp;\\text{if }x_i\\text{ is continuours},\\\\-x_i\\log(x_i^\\prime), &amp;\\text{if }x_i\\text{ is binary}.\\end{cases} \\] 最终的优化函数为： \\[ \\min_G\\sum\\limits_{j=1}^{k_G}\\mathcal{L}_G(m(j),\\hat{m}(j),b(j))+\\alpha\\mathcal{L}_M(\\tilde{x}(j),\\hat{x}(j)) \\] 算法流程如下： Experiments 下表为在5个不同数据集上实验，与其他5种方法对比的结果： 上图为GAIN、MissForest和Autoencoder三种模型在不同缺失比例、样本数量、特征维度下的对比曲线图。 下表为使用不同模型对时间序列进行填充之后，使用逻辑回归进行回归任务的性能： 下图为GAIN、MissForest和Autoencoder三种模型在不同缺失比例下的AUROC曲线图： 下表展示的是作者对时间序列填充算法保持特征-标签关系的能力。作者分别用完整的数据和填充后的数据用逻辑回归模型进行训练，将两者的权重求绝对值和均方根的结果。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Time Series Imputation","slug":"Research/Time-Series-Imputation","permalink":"http://qfxiao.me/categories/Research/Time-Series-Imputation/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"GAN","slug":"GAN","permalink":"http://qfxiao.me/tags/GAN/"}]},{"title":"Anomaly Detection with Generative Adversarial Networks for Multivariate Time Series","slug":"Anomaly-Detection-with-Generative-Adversarial-Networks-for-Multivariate-Time-Series","date":"2019-09-22T14:32:18.000Z","updated":"2020-06-25T05:24:46.844Z","comments":true,"path":"2019/09/22/Anomaly-Detection-with-Generative-Adversarial-Networks-for-Multivariate-Time-Series/","link":"","permalink":"http://qfxiao.me/2019/09/22/Anomaly-Detection-with-Generative-Adversarial-Networks-for-Multivariate-Time-Series/","excerpt":"","text":"Introduction 这篇文章提出了一个基于GAN的时间序列异常检测模型。 原文 Contribution 提出了基于GAN的时间序列无监督异常检测模型 我们使用基于LSTM的GAN来对多变量时间序列进行建模 结合使用了Residual Loss和Discrimination Loss来进行异常的判断 Background Generative Adversarial Networks GANs In a Nutshell, an extremely simple explanation 我们想要从一个复杂的、高维的数据分布\\(p_r(x)\\)上采样得到我们想要的数据点，然而\\(p_r(x)\\)无法直接求得 代替方法：从一个简单的、已知的分布\\(p_z(z)\\)上采样，然后学习一个Transformation \\(G(z): z\\rightarrow x\\)来将\\(z\\)映射到\\(x\\) Training: Two-player Game Generator Network: 从随机分布\\(p_z(z)\\)采样\\(z\\)，通过映射生成样本\\(x\\)，这个生成的样本要尽量“真实”。怎么“真实”？优化生成器参数\\(\\theta_G\\)最大化判别器对生成样本的评分即可 Discriminator Network: 接受一个样本\\(x\\)，判断其是生成的样本还是真实的样本。在训练阶段，我们是知道一个样本\\(x\\)到底是生成的还是真实的，所以优化判别器参数\\(\\theta_D\\)最小化判别器对生成样本的评分，最大化对真实样本的评分（即最大化分辨真实样本的能力） 形式化的来讲，优化函数如下： \\[\\min\\limits_{\\theta_G}\\max\\limits_{\\theta_D}V(G,D)=\\mathbb{E}_{x\\sim p_{data}(x)\\log(\\underbrace{D_{\\theta{D}}(x)}_{判别器对真实样本的评分})}+\\mathbb{E}_{z\\sim p_z(z)}\\log(1-\\underbrace{D_{\\theta_d}(G_{\\theta_G}(z))}_{判别器对生成样本的评分})\\] 训练过程如下： Long Short Time Memory Networks Vanilla Recurrent Neural Networks 普通的神经网络： 概括的来讲，可以涵盖为一个公式\\(\\hat{\\mathbf{y}}=f(\\mathbf{x})\\)。对于一个样本\\(\\mathbf{x}\\)，通过多层神经网络映射，输出\\(\\mathbf{y}\\)。 对于RNN，我们处理的是序列数据，也就是说所有样本之间并不是相互独立的。对于一个序列中的一个样本\\(x_t\\in\\{x_1,x_2,\\cdots,x_n\\}\\)，将其输入到神经网络的时候，为了建模\\(x_t\\)之前的子序列对\\(x_t\\)的影响关系，需要将这个子序列的信息也输入到神经网络中，怎么做呢？为每一个样本点保存一个State。即定义\\(h_t=g(\\hat{y_t})=g(f(x_t))\\)，对于当前样本点，\\(\\hat{y_t}=f(x_t,h_{t-1})\\)。也就是说神经网络的输入不仅包含了当前样本点的特征，也包含了上一个样本点的“状态”(上一个样本点的“状态”又隐含了上上个样本点的“状态”...)，就像是为网络加上了短期记忆。 Gradient Flow of Vanilla RNN 下面来进行一些形式化的定义，假设在时刻\\(t\\)网络输入特征为\\(x_t\\)，输出隐含状态为\\(h_{t}\\)，其不仅和当前输入\\(x_t\\)有关，还和上一个隐含状态\\(h_{t-1}\\)有关： 当前时刻总的净输入\\(z_t=Uh_{t-1}+Wx_t+b\\) 当前时刻输出隐含状态\\(h_t=f(z_t)\\) 当前时刻输出\\(\\hat{y}_t=Vh_t\\) RNN的梯度更新公式(推导过程比较复杂)： \\[\\frac{\\partial{\\mathcal{L}}}{\\partial U}=\\sum\\limits_{t=1}^T\\sum\\limits_{k=1}^t \\delta_{t,k}\\mathbf{h}_{k-1}^T\\] \\[\\frac{\\partial{\\mathcal{L}}}{\\partial{W}}=\\sum\\limits_{t=1}^T\\sum\\limits_{k=1}^t \\delta_{t,k}x_k^T\\] \\[\\frac{\\partial\\mathcal{L}}{\\partial{b}}=\\sum\\limits_{t=1}^T\\sum\\limits_{k=1}^t\\delta_{t,k}\\] 其中\\(\\delta_{t,k}=\\frac{\\partial{\\mathcal{L}}}{\\partial{z_k}}=\\text{diag}(f^\\prime(z_k))U^T\\delta_{t,k+1}\\)定义为第\\(t\\)时刻的损失对第\\(k\\)时刻隐藏神经层的净输入\\(z_k\\)的导数，且\\(z_k=Uh_{k-1}+Wx_k+b,1\\leq k&lt;t\\)。 RNN的梯度流向如下图红箭头所示： RNN会遇到梯度消失和梯度爆炸的问题。根据前面的公式，\\(\\delta_{t,k}\\)实际上是递归定义的，展开得到： \\[\\delta_{t,k}=\\prod\\limits_{\\tau=k}^{t-1}(\\text{diag}(f^\\prime(z_\\tau))U^T)\\delta_{t,t}\\] 如果定义\\(\\gamma\\cong\\parallel\\text{diag}(f^\\prime(z_\\tau))U^T\\parallel\\)，那么\\(\\delta_{t,k}\\cong\\gamma^{t-k}\\delta_{t,t}\\)。在\\(t-k\\)很大时，\\(\\gamma&lt;1\\)会导致梯度消失，\\(\\gamma&gt;1\\)时会导致梯度爆炸。 Long Short Time Memory LSTM是一种解决RNN梯度消失问题的改进版本： 在LSTM中，维护了两个State，\\(c_t\\)和\\(h_t\\)。其中\\(c_t\\)由遗忘门\\(f\\)与上一个\\(c_{t-1}\\)相乘(代表继承上一个Cell的信息并加以一定程度的遗忘)，加上输出门\\(i\\)与Gate Gate \\(g\\)相乘(Gate Gate代表当前的候选状态，输出门\\(i\\)控制当前候选状态有多少信息需要保存)。最后，输出门\\(o\\)控制当前时刻的Cell State \\(c_t\\)有多少信息需要输出给外部状态\\(h_t\\)。 三个门的计算方式为： \\[i_t=\\sigma(W_ix_t+U_ih_{t-1}+b_i)\\] \\[f_t=\\sigma(W_fx_t+U_fh_{t-1}+b_f)\\] \\[o_t=\\sigma(W_ox_t+U_oh_{t-1}+b_o)\\] Methodology 总体框架图如Fig 1所示： GAN with LSTM-RNN 网络结构上生成器和判别器都是LSTM，优化函数和普通GAN一样： \\[\\min\\limits_G\\max\\limits_D V(D,G)=\\mathbb{E}_{x\\sim p_{data}(x)}[\\log D(x)]+\\mathbb{E}_{z\\sim p_z(z)}[\\log (1-D(G(z)))]\\] GAN-based Anomaly Score 在测试阶段，需要使用梯度优化寻找一个使得\\(G_{rnn}(z)\\)最接近\\(X^{test}\\)的\\(z^k\\)： \\[\\min\\limits_{Z^k}Error(X^{test},G_{rnn}(Z^k))=1-Similarity(X^{test},G_{rnn}(Z^k))\\] 本文定义了两种Anomaly Score，一种是Residual Loss： \\[Res(X^{test}_t)=\\sum\\limits_{i=1}^n|x^{test,i}_t-G_{rnn}(Z^{k,i}_t)|\\] 一种是Discrimination Loss，即判别器的输出\\(D_{rnn}(x_t^{test})\\)。 总的Anomaly Score： \\[S^{test}_t=\\lambda Res(X^{test}_t)+(1-\\lambda)D_{rnn}(x^{test}_t)\\] Anomaly Detection Framework 模型的算法流程如下： 由于本文是多变量时间序列预测，而且时间序列的长度有可能比较长，作者使用了滑动窗口和PCA来进行预处理。 Experiments","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"ALSR: An Adaptive Label Screening and Relearning Approach for Interval-Oriented Anomaly Detection","slug":"ALSR-An-adaptive-label-screening-and-relearning-approach-for-interval-oriented-anomaly-detection","date":"2019-09-22T14:29:18.000Z","updated":"2020-06-24T07:48:38.792Z","comments":true,"path":"2019/09/22/ALSR-An-adaptive-label-screening-and-relearning-approach-for-interval-oriented-anomaly-detection/","link":"","permalink":"http://qfxiao.me/2019/09/22/ALSR-An-adaptive-label-screening-and-relearning-approach-for-interval-oriented-anomaly-detection/","excerpt":"","text":"Introduction 本文针对面向区间的KPI异常检测提出了Label Screening方法和Relearning Algorithm. 原文 Contribution 提出了一种Label Screening方法来对区间内不同重要性进行过滤 提出了一种Relearning Algorithm来对FP和TP进行Relearning，在不减少Recall的条件下增大Precision Methodology Overall Structure 算法的整体框架如下： Label Screening Model 预训练的结果被分为\\(TP_{po},FP_{po},TN_{po},FN_{po}\\)四类，\\(TP_{po}\\)和\\(FN_{po}\\)可以被细分如下： \\[ \\begin{align}TP_{po}&amp;=TP_{po,withinT}+TP_{po,afterT}\\\\&amp;=TP_{po,withinT}+TP_{po,afterT,tpl}+TP_{po,after,fnl}\\end{align} \\] \\[ \\begin{align}FN_{po}&amp;=FN_{po,withinT}+FN_{po,afterT}\\\\&amp;=FN_{po,withinT,tpl}+FN_{po,,withinT,fnl}+FN_{po,afterT,tpl}+FN_{po,afterT,fnl}\\end{align} \\] 其中下标\\({}_{withinT}\\)代表在异常片段第一个点\\(T\\)距离内的所有点，下标\\({}_{afterT}\\)代表\\(T\\)距离之后。下标\\({}_{tpl}\\)和\\({}_{fnl}\\)分别代表在异常片段中，包含和不包含\\(TP_{po,withinT}\\)的点。 以TP为例，Point-based的TP包含了在T范围之内的（即在Interval-based的标准中也会被认为是TP的点）和T范围之外的点（即在Interval-based的标准中不认为是TP的点）。而在T范围之外的点又可以细分为该异常片段是否包含\\(TP_{po,withinT}\\)的点（即该点在Interval-based的标准中不会被判定为TP，但该异常片段有其点会被判定为TP）。 类似的，\\(TP_{io}\\)和\\(FN_{io}\\)可以被分解为： \\[ \\begin{align}TP_{io}&amp;=TP_{po,withinT}+TP_{po,afterT,tpl}+FN_{po,withinT,tpl}+FN_{po,afterT,tpl}\\\\&amp;=TP_{po}+FN_{po,withinT,tpl}+FN_{po,afterT,tpl}-TP_{po,afterT,fnl}\\end{align} \\] \\[ \\begin{align}FN_{io}&amp;=FN_{po,withinT,fnl}+FN_{po,afterT,fnl}+TP_{po,afterT,fnl}\\\\&amp;=FN_{po}+TP_{po,afterT,fnl}-FN_{po,withinT,tpl}-FN_{po,afterT,tpl}\\end{align} \\] 文中对该部分的分析可以分为以下几点： 在Interval-oriented的标准中，\\(FN_{po,tpl}\\)的点仍会被认为是\\(TP_{io}\\)，而\\(TP_{po,afterT}\\)（不带\\({}_{tpl}\\)）不会被认为是\\(TP_{io}\\)，所以最终\\(TP_{io}\\)由所有\\(TP_{po}\\)加上那些会被认为是\\(TP_{io}\\)的\\(FN_{po,tpl}\\)再去掉不带\\({}_{tpl}\\)的\\(TP_{po,afterT}\\)组成，即公式(6) 同时，根据公式(6)，如果\\(TP_{po}\\)变为\\(FN_{po,tpl}\\)，也不会对最终结果造成影响。但是根据公式(5)和公式(7)，\\(TP_{po,withinT}\\)变成\\(FN_{po,withinT,fnl}\\)会减小\\(TP_{io}\\)同时增大\\(FN_{io}\\) 文章指出，虽然\\(FN_{po,withinT,tpl}\\)和\\(FN_{po,afterT,tpl}\\)最后都会被认为是\\(TP_{io}\\)，但作者假设\\(FN_{po,withinT,tpl}\\)更难检测，所以应该保留，而\\(FN_{po,afterT,tpl}\\)应该削减 Label Screening方法去除了\\(FN_{po,afterT}\\)的点 Screened之后的训练集被用来训练DNN主模型，但Label Screening的预测结果也会被保留，和DNN主模型的结果进行组合 算法流程如下： Relearning Algorithm Relearning Model的输入是DNN主模型预测出来的异常，其中包括TP和FP。Relearning Model采用的是随机森林，其输入的样本通过采样得到： \\[ \\begin{align} \\text{relearning}\\space&amp;\\text{training set}=\\\\&amp; shuffle\\{4C\\ast\\text{randomof}(TP_{po})\\\\&amp;+C\\cdot\\text{randomof}(FP_{po})+C\\cdot\\text{randomof}(TN_{po})\\} \\end{align} \\] 其中\\(C\\)为常数。TN和FP都看作是负例(正常样本)，TP看作是正例。 Detection 对于一个滑动窗口\\(x_t=\\{x_{t-w+1},\\cdots,x_t\\}\\)，异常检测算法的目标是输出检测结果\\(y_t\\in\\{0,1\\}\\)来表示时间\\(t\\)是否发生异常。实际上算法输出的是\\(p_{y_t}\\in[0,1]\\)概率值来表示在时间\\(t\\)发生异常的概率。文中三个模型会得到三个输出：\\(y_{t,ls},y_{t,main},y_{t,re}\\)。最终结果为： \\[ y_t=y_{t,ls}\\space\\&amp;\\space y_{t,main}\\space\\&amp; \\space y_{t,re} \\] 在绘制PR曲线时，采用的公式为： \\[ \\begin{align} p_{y_t}(th)=&amp;(1-sig(p_{y_t,ls},th))\\cdot(p_{y_t,ls})\\\\ &amp;+sig(p_{y_t,ls},th)\\cdot(1-sig(p_{y_t,main},th))\\cdot p_{y_t,main}\\\\ &amp;+sig(p_{y_t,ls},th)\\cdot sig(p_{y_t,main},th)\\cdot p_{y_t,re}\\\\ \\end{align} \\] \\[ y_t(th)=sig(p_{y_t}(th),th) \\] 算法流程如下： Experiments Datasets 清华AIOps数据集，选取了25条KPI。 Preprocessing Missing Data. 去除。 Standardization. Minmax Standardization，Feature Extraction使用的是Standardization后的数据。 Feature Extraction. 使用了12种特征。 Group Feature Name Values The original values standardized Statistical Features Mean, Standard Deviation, Range, Difference... Fitting Features EWMA, AR Wavelet Features Db2 wavelet decomposition Results AUCPR F1 Remark 这篇文章的Label Screening方法实际上是在处理样本分类难易度的问题，将异常区间内容易的样本去除了 对于时间序列的异常检测问题，我们的目标一般是Point-based的异常标签，一个时间点的特征是有限的。如果用窗口的方式，以\\(\\{x_{t-w+1},\\cdots,x_t\\}\\)作为时间\\(t\\)的输入（当然每个\\(x_t\\)可以有多个Channel），然后把预测结果作为时间\\(t\\)的输出","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications","slug":"Unsupervised-Anomaly-Detection-via-Variational-Auto-Encoder-for-Seasonal-KPIs-in-Web-Applications","date":"2019-09-22T12:35:18.000Z","updated":"2020-06-25T09:11:13.347Z","comments":true,"path":"2019/09/22/Unsupervised-Anomaly-Detection-via-Variational-Auto-Encoder-for-Seasonal-KPIs-in-Web-Applications/","link":"","permalink":"http://qfxiao.me/2019/09/22/Unsupervised-Anomaly-Detection-via-Variational-Auto-Encoder-for-Seasonal-KPIs-in-Web-Applications/","excerpt":"","text":"Abstract 本文提出了Donut，一个基于VAE的无监督时间序列异常检测系统。 原文 Contribution Donut中使用到了三个技巧，包括改进后的ELBO、缺失数据注入和MCMC插值； 提出基于VAE的异常检测训练既需要正常样本也需要异常样本； 对Donut提出了在z-空间中基于KDE的理论解释。 Background Anomaly Detection 对于任意时间\\(t\\)，给定历史观察值\\(x_{t-T+1},\\cdots,x_t\\)，确定异常是否发生(记为\\(y_t=1\\))。通常来收异常检测算法给出的是发生异常的可能性，如\\(p(y_t=1|x_{t-T+1},\\cdots,x_t)\\)。 Methodology Problem Statement 本文的目的是基于深度生成网络开发具有理论解释性的无监督异常检测算法，并且在有标签的情况下能利用标签信息提升性能。本文基于VAE来构建模型。 Network Structure 算法的总体框架如下图所示： 一共包含了预处理、训练和检测三个部分。 下图为模型的概率图模型： 图中双实线的框为本文模型有别于传统VAE的地方，其余地方和VAE一样。先验概率\\(p_\\theta(z)\\)选为标准正态分布\\(\\mathcal{N}(0,I)\\)，后验概率\\(x\\)和\\(z\\)都是对角化高斯分布，即\\(p_\\theta(x|z)=\\mathcal{N}(\\mu_x,\\sigma_x^2 I),q_\\phi(z|x)=\\mathcal{N}(\\mu_z,\\sigma_z^2 I)\\)。如Figure 4所示，推断网络和生成网络中分别都有隐含层\\(f_\\phi(x)\\)和\\(f_\\theta(z)\\)对网络的输入进行特征抽取。高斯分布的参数即从这些抽取出来的特征上得到。均值通过线性层得到：\\(\\mu_x=W^T_{\\mu_x}f_\\theta(z)+b_{\\mu_x}, \\mu_z=W^T_{\\mu_z}f_\\theta(x)+b_{\\mu_z}\\)。标准差通过Soft Plus层加一个高斯噪声得到：\\(\\sigma_x=\\text{SoftPlus}[W^T_{\\sigma_x}f_\\theta(z)+b_{\\sigma_x}]+\\varepsilon，\\sigma_x=\\text{SoftPlus}[W^T_{\\sigma_z}f_\\theta(x)+b_{\\sigma_z}]+\\varepsilon\\)。 文中提到因为KPI的局部方差非常小，所以采用直接建模\\(\\sigma_x,\\sigma_z\\)的方式而不是采用对数。除此之外，为了理论上的解释性，文中的神经网络只使用了全连接层。 Training 训练可以直接采用经典的SGVB来优化ELBO： \\[ \\begin{align} \\log p_\\theta(x)&amp;\\geq\\log p_\\theta(x)-\\text{KL}[q_\\phi(z|x)\\parallel p_\\theta(z|x)]\\\\ &amp;=\\mathcal{L}\\\\ &amp;=\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x)+\\log p_\\theta(z|x)-\\log q_\\phi(z|x)]\\\\ &amp;=\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x,z)-\\log q_\\phi(z|x)]\\\\ &amp;=\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x|z)+\\log p_\\theta(z)-\\log q_\\phi(z|x)] \\end{align} \\] 但是在实际的训练过程中，训练数据需要保证都是正常样本，但实际上训练样本有可能会包含异常或者是缺失值。一种做法是用缺失值填充的算法来填充这些异常值和缺失值，但作者认为使用缺失值填充算法并不能很好的还原数据的正常模式，从而保证算法的有效性。在文中作者采用了修改ELBO的方法，并将其称之为Modified ELBO (M-ELBO)，公式如下： \\[ \\tilde{\\mathcal{L}}=\\mathbb{E}_{q_\\phi(z|x)}[\\sum\\limits_{w=1}^W{\\alpha_w\\log p_\\theta(x_w|z)+\\beta\\log p_\\theta(z)-\\log q_\\phi(z|x)}] \\] 其中\\(\\alpha_w\\)为指示标记，\\(\\alpha_w=1\\)代表不是异常也不是缺失。\\(\\beta\\)定义为\\(\\beta=\\frac{\\sum_{w=1}^W\\alpha_w}{W}\\)。 在M-ELBO中，异常或缺失值对应的\\(\\log p_\\theta(x_w|z)\\)的贡献会被排除，同时\\(\\log p_\\theta(z)\\)在乘以\\(\\beta\\)后会相应缩小。作者没有修改\\(\\log q_\\phi(z|x)\\)这一项的原因有二：一是\\(q_\\phi(z|x)\\)仅仅是从\\(x\\)到\\(z\\)的映射，并不需要考虑“正常模式”；二是\\(\\mathbb{E}_{q_\\phi(z|x)}[-\\log q_\\phi(z|x)]\\)就是\\(q_\\phi(z|x)\\)的熵，而这个在后面的理论分析中有特别的含义。 除此之外还有一种解决方法就是把所有包含异常值和缺失值的窗口去除，这种方法的性能在实验中会进行讨论。 在文中作者还使用了一种Missing Data Injection技术，即在每个Epoch随机的按照一个预设比例\\(\\lambda\\)将正常的数据设为缺失。作者认为这样有助于性能的提升。 Detection 在检测阶段，对于一个输入样本，我们需要模型输出其异常的概率。因为我们建模了\\(p_\\theta(x|z)\\)，一种方法是采样计算\\(p_\\theta(x)=\\mathbb{E}_{p_\\theta(z)}[p_\\theta(x|z)]\\)，但这种方法计算代价十分昂贵。其他的一些方案有计算\\(\\mathbb{E}_{q_\\phi(z|x)}[p_\\theta(x|z)]\\)或\\(\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x|z)]\\)，其中后者被称为\"Reconstruction Probability\"，作者便采用了这种方案。 同时，作者认为输入的检测样本的缺失值会对结果造成较大偏差，于是使用了一种MCMC-based Missing Data Imputation的方法来对检测样本的缺失值进行填充。具体做法是将测试样本分为已观测和缺失两部分\\(x=(x_o,x_m)\\)，然后使用训练好的VAE进行重构得到\\((x^\\prime_o,x^\\prime_m)\\)，然后用\\(x^\\prime_m\\)替换\\(x_m\\)，这样不断循环如下图所示： 作者使用了\\(L\\)个样本来计算Reconstruction Probability，虽然得到的输出是针对整个窗口每个点的，但作者只使用最后一个点。 Experiments Datasets 作者选择了三条KPI作为测试数据，分别记为\\(\\mathcal{A}\\)，\\(\\mathcal{B}\\)，\\(\\mathcal{C}\\)，其基本数据如下表所示： Metrics 因为异常检测类别的极不均衡性，传统的性能指标并不太合适（异常样本极少，且异常一般呈连续的片段）。作者认为在实际应用场景中运维人员需要尽量早的获知异常的发生，于是提出了新的评测机制。 如上图所示，第一行为真实的标签，第二行为预测的异常概率，第三行为预测的标签。第一行中异常片段被加粗表示，对于每一个异常片段的第一个位置\\({y}_{t^\\prime}\\)，如果预测的标签中存在\\(\\hat{y}_{t}\\)满足\\(t^\\prime&lt;t\\)且\\(|t-t^\\prime|\\)小于等于预设的阈值\\(T\\)，那么\\(y_{t^\\prime}\\)对应的整段异常都被认为正确检测，否则整段异常都认为没有被正确检测。然后在此基础上计算F1-score，AUC等指标作为评测手段。 Results Overall Performance 下图展示了不同方法在不同数据集上的表现： Effects of Donut Techniques 为了探究Donut中所做的各种改进的实际作用，作者做了大量对比实验，结果如下图所示： M-ELBO 从图中可以看出M-ELBO对性能提升最大。作者在文中提到一开始并没期望M-ELBO能带来性能的提升，只是希望它能够Work。这表明在VAE的训练中，只使用正常样本是不够的，也需要加入非正常的信息； Missing Data Injection 该技巧的主要作用是增强M-ELBO的效果。从结果上来看作用并不是十分的显著，只是在一些情况下获得了少量的提升； MCMC Imputation 作者认为虽然该技巧只在一部分情况下显著提升了性能，但总体来说值得使用。 Impact of K 该部分作者探究了隐变量\\(z\\)的维度\\(K\\)对性能的影响，结果如下图： 从图上来看，对数据集\\(\\mathcal{A}\\)，\\(\\mathcal{B}\\)，\\(\\mathcal{C}\\)最佳的\\(K\\)分别是\\(5\\)，\\(4\\)和\\(3\\)，但是设定较大的\\(K\\)并不会对性能有严重的损害。作者还发现对于较为平滑的KPI需要较大的\\(K\\)。 Analysis KDE Interpretation 在这一节作者对Reconstruction Probability的意义进行了深入的探讨。首先作者对\\(q_\\phi(z|x)\\)进行了可视化，在图中作者将时间维度用颜色来表示。如Figure 11(a) 所示，\\(z\\)几乎是按照\\(x\\)对应的时间呈一个连续的流形分布，作者将这种现象称为Time Gradient。即使Donut没有显式的用到时间信息，不过因为实验用到的数据基本是平滑的，所以说相邻的\\(x\\)会比较相似，因此经过映射后的\\(z\\)也会比较相似。作者据此提出Donut的一个优势便是对于没有见过的后验分布\\(q_\\phi(z|x)\\)，只要其位于训练过的两个后验之间，也会产生合理的分布。 对于异常的样本\\(x\\)，假设其对应的正常模式为\\(\\tilde{x}\\)，作者认为\\(q_\\phi(z|x)\\)会在某种程度上对正常的\\(q_\\phi(z|\\tilde{x})\\)进行近似。因为模型是用正常样本进行训练的，隐变量\\(z\\)的维度通常来说小于样本\\(x\\)，这就导致\\(z\\)只会保留一部分主要的信息。对于异常样本，其异常模式在编码时就被丢掉了。作者还指出如果\\(x\\)包含的异常太多，那么模型将难以对\\(x\\)进行还原。 基于上述讨论，作者对使用\\(\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x|z)]\\)作为Reconstruction Probability的意义进行了阐释。设输入样本为\\(x\\)，如果其包含异常，假设其对应的正常样本为\\(\\tilde{x}\\)，那么\\(q_\\phi(z|x)\\)部分地和\\(q_\\phi(z|\\tilde{x})\\)相似。如果\\(x\\)和\\(\\tilde{x}\\)相似程度高，那么\\(\\log p_\\theta(x|z)\\)就会很大（其中\\(z\\sim q_\\phi(z|\\tilde{x})\\)）。\\(\\log p_\\theta(x|z)\\)类似于一个密度估计器，代表\\(x\\)在多大程度上与\\(\\tilde{x}\\)接近，\\(\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x|z)]\\)相当于对每一个\\(z\\)对应的\\(\\log p_\\theta(x|z)\\)乘以一个权重\\(q_\\phi(z|x)\\)然后相加。于是作者提出了Reconstruction Probability的KDE Interpretation:在Donut模型中，Reconstruction Probability \\(\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x|z)]\\)可以看作是以\\(q_\\phi(z|x)\\)为权重，\\(\\log p_\\theta(x|z)\\)为核的核密度估计 (Kernel Density Estimation)。 三维可视化如下图所示： 作者还对直接计算\\(p_\\theta(x)=\\mathbb{E}_{p_\\theta(z)}[p_\\theta(x|z)]\\)进行了质疑，因为这种方法直接求\\(x\\)的先验，仅仅考虑了\\(x\\)的总体模式，而忽略了\\(x\\)的个体模式。 Find Good Posteriors for Abnormal \\(x\\) 通过上面的讨论我们知道了Donut通过找到\\(x\\)的正常后验来估计\\(x\\)在多大程度上与\\(\\tilde{x}\\)相似，在这一节作者讨论了文中使用的不同技巧对找到\\(x\\)的后验的作用。对于Missing Data Injection作者认为该技巧增强了M-ELBO的效果。对于MCMC Imputation，作者认为该技巧主要是在检测阶段通过不断迭代提供了更好的后验，如下图所示： 作者认为，虽然对于包含大量异常的样本，Donut不能很好的还原，但在运维场景中，只要对大段异常的开始阶段进行准确预测即可。 Causes of Time Gradient 在这一节作者讨论了Time Gradient出现的原因。首先假设\\(x\\)都是正常点，这时\\(x\\)的ELBO为： \\[ \\begin{align} \\mathcal{L}(x)&amp;=\\mathbb{E}_{q_\\phi(z|x)}[\\log p_\\theta(x|z)+\\log p_\\theta(z)-\\log q_\\phi(z|x)]\\\\ &amp;=\\mathbb{E}[\\log p_\\theta(x|z)]+\\mathbb{E}[\\log p_\\theta(z)]+\\text{H}[z|x] \\end{align} \\] 第一项表明在\\(z\\sim q_\\phi(z|x)\\)下尽可能重构\\(x\\)。第二项表明\\(q_\\phi(z|x)\\)尽量与\\(z\\)的先验\\(\\mathcal{N}(0,I)\\)接近。第三项为\\(q_\\phi(z|x)\\)的熵，表明\\(q_\\phi(z|x)\\)应尽量分散。然而第二项又限制了这种分散的区域，如 Figure 11(c) 所示。同时考虑这三项的话，第一项使得\\(z\\)不能自由地分散，对于不相似的\\(x\\)其对应的\\(z\\)也是不相似的，因为要最大化\\(x\\)的重构概率。然而对于相似的\\(x\\)来说，其对应的\\(q_\\phi(z|x)\\)会出现很多重复的部分。当达到平衡时，Time Gradient就出现了。 在训练过程中，当\\(x\\)越不相似，\\(q_\\phi(z|x)\\)就会相距越远，如上图所示。然而在一开始，参数经过随机初始化，\\(q_\\phi(z|x)\\)都是随机散乱的，如 Figure 11(b) 所示。随着训练的进行，\\(q_\\phi(z|x)\\)将会不断优化。由于KPI数据往往是光滑的，那么在时间上相距越远的样本就会越不相似，对应的\\(q_\\phi(z|x)\\)也会相距更远。这也说明了，训练结束后，时间上相距越远的，\\(q_\\phi(z|x)\\)也会相距越远，反之亦然。同时这也表明学习率的设置对本模型的稳定性有至关重要的作用。 Sub-Optimal Equilibrium 上面我们讨论了随着训练进行\\(q_\\phi(z|x)\\)的演变，作者提出在训练过程中可能会遇到模型收敛到次优的情况，如下图所示： 第一行展示的是收敛到最优的情况，第二行展示的是收敛到次优的情况。从第二行的第一个图（Step 100）来看，紫色的点开始穿过绿色的点，随着训练的进行，紫色的点开始将绿色的点推开。到Step 5000的时候，绿色的点已经被分成了两半。下图展示了对应的训练误差和验证误差： 这样的现象会导致在两半绿色区域之间的测试样本会被识别为紫色，从而降低性能。作者提出在\\(K\\)较大的时候这种现象不容易发生，但这时训练的收敛又会成为一个问题。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"VAE","slug":"VAE","permalink":"http://qfxiao.me/tags/VAE/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"}]},{"title":"Time-Series Anomaly Detection Service at Microsoft","slug":"Time-Series-Anomaly-Detection-Service-at-Microsoft","date":"2019-09-22T12:33:18.000Z","updated":"2020-06-25T08:59:23.758Z","comments":true,"path":"2019/09/22/Time-Series-Anomaly-Detection-Service-at-Microsoft/","link":"","permalink":"http://qfxiao.me/2019/09/22/Time-Series-Anomaly-Detection-Service-at-Microsoft/","excerpt":"","text":"Abstract 本文借鉴计算机视觉中的显著性检测，提出了一种基于Spectral Residual的时间序列异常检测算法。 原文 这篇文章还提出了几个时间序列异常检测落地的难点： Lack of Labels. 在实际生产环境中会产生大量的KPI，而很难对每个KPI进行人工标注。 Generalization. 不同KPI所表现出来的模式也不尽相同，如Figure 1所示。现有方法很难在所有模式的KPI上都表现良好。 Efficiency. 在实际场景中，会产生大量的时间序列数据，同时对异常检测算法的时间效率有要求。 Contribution 将Visual Saliency Detection的方法引入了时间序列异常检测。 结合Spectral Residual和CNN提高了异常检测的效果。 算法具有良好的时间效率和通用性。 Background Spectral Residual SR(Spectral Residual)算法主要包含三个步骤： 通过傅里叶变换得到log amplitude spectrum； 计算spectral residual； 通过傅里叶逆变换回到时间域。 更形式化的表述为如下： 给定一个序列\\(\\mathbb{x}\\)，则有： \\[A(f)=Amplitude(\\mathscr{F}(\\mathbb{x}))\\] \\[P(f)=Phrase(\\mathscr{F}(\\mathbb{x}))\\] \\[L(f)=\\log(A(f))\\] \\[AL(F)=h_1(f)\\cdot L(f)\\] \\[R(f)=L(f)-AL(f)\\] \\[S(\\mathbb{x})=\\parallel\\mathscr{F}^{-1}(\\exp(R(f)+iP(f)))\\parallel\\] 其中\\(\\mathscr{F}\\)和\\(\\mathscr{F}^{-1}\\)分别表示傅里叶变换和傅里叶逆变换；\\(\\mathbb{x}\\in \\mathbb{R}^{n\\times 1}\\)表示输入序列；\\(A(f)\\)为幅度谱，\\(P(f)\\)为相位谱，\\(L(f)\\)为对数幅度谱，\\(AL(F)\\)为均值滤波后的对数幅度谱；\\(R(f)\\)为spectral residual；\\(S(\\mathbb{x})\\)称为saliency map。Figure 4为文中给出的Saliency Map示意图。 Methodology Problem Definition 给定一系列实数值\\(\\mathbb{x}=x_1,x_2,\\cdots,x_n\\)，时间序列异常检测的任务是产生一个输出序列\\(\\mathbb{y}=y_1,y_2,\\cdots,y_n\\)其中\\(y_i\\in\\{0,1\\}\\)表示\\(x_i\\)是否为异常点。 SR 对于给定序列\\(\\mathbb{x}\\)，计算Saliency Map \\(S(\\mathbb{x})\\)，输出序列\\(O(\\mathbb{x})\\)定义为： \\[O(x_i)=\\begin{cases}1,\\quad \\text{if}\\frac{S(x_i)-\\overline{S(x_i)}}{\\overline{S(x_i)}}&gt;\\tau\\\\\\\\0,\\quad \\text{otherwise}\\end{cases}\\] 其中\\(S(x_i)\\)为\\(x_i\\)对应的Saliency Map的值，\\(\\overline{S(x_i)}\\)为\\(x_i\\)附近Saliency Map局部均值。 在实际操作中，FFT是在一个滑动窗口中进行的，文中提到SR方法在点位于窗口中央时效果更好，所以在进行测试的时候，按照如下方法对当前点\\(x_n\\)(也就是当前序列最后一个点)之后的点进行预测： \\[\\overline{g}=\\frac{1}{m}\\sum_{i=1}^m g(x_n,x_{n-i})\\] \\[x_{n+1}=x_{n-m+1}+\\overline{g}\\cdot m\\] 其中\\(g(x_i,x_j)\\)代表\\(x_i\\)和\\(x_j\\)两点构成的直线的梯度；\\(\\overline{g}\\)代表所处理的点的平均梯度；\\(m\\)为所处理的点的数量。在本文中设置\\(m=5\\)。文中发现第一个预测的值很重要，所以直接把\\(x_{n+1}\\)赋值\\(k\\)次添加到序列的末尾。 SR-CNN 本文提到，仅仅使用一个阈值来进行异常的判断太过简单，于是提出使用一个判别模型来进行异常的判断。由于训练数据没有标签，所以使用如下的公式人工加入异常： \\[x=(\\overline{x}+mean)(1+var)\\cdot r+x\\] 其中\\(\\overline{x}\\)所处理的点的局部均值；\\(mean\\)和\\(var\\)为当前滑动窗口点的均值和方差；\\(r\\sim \\mathcal{N}(0,1)\\)为服从标准正态分布的噪声。 对于判别模型使用的是CNN，主要包含两个1维卷积层(kernel size等于窗口大小\\(w\\))和两个全连接层。两个卷积层的channel size分别为\\(w\\)和\\(2w\\)。 Experiments Datasets 所用数据集包含清华AIOps竞赛数据、Yahoo和Microsoft的KPI数据。 Evaluation Metrics 算法准确率方面用了precision，recall和\\(F_1\\)-score。 由于在实际场景中KPI的异常往往是以一段一段的形式出现，且并不要求某一个时间点出现异常算法就马上检测出来，只要检测出来的时间在一定的容忍范围内即可。本文使用了一些调整的手段，如Figure 6。对于某一段异常，设段首的异常位于时间点\\(t_{truth}\\)，预测为异常的结果中时间在\\(t_{truth}\\)之后且距\\(t_{truth}\\)最近的时间点设为\\(t_{predict}\\)，那么对于一个预先设定的容忍范围\\(k\\)，只要\\(t_{predict}-t_{truth}\\leq k+1\\)那么在预测结果中整段异常就会重置为\\(1\\)，否则全部重置为\\(0\\)。 Results 实验部分使用了两种训练方式，一种是cold-start，即把所有数据都用来测试，另一种是把数据分为训练测试两部分，在训练集上训练，最后在测试集上进行测试。两种方法适用的baseline不同，最后结果如Table 2和Table 3所示： 在SR的参数设置上，\\(h_q(f)\\)中的\\(q\\)为3，局部平均所用的点数目\\(z\\)为21，阈值\\(\\tau\\)为3，估计点的数量\\(k\\)为5，滑动窗口的大小\\(w\\)在KPI、Yahoo、Microsoft三个数据集上分别为1440、64和30。SR-CNN的\\(q\\)，\\(z\\)，\\(k\\)，\\(w\\)设置与SR相同。 Additional Experiments with DNN 文中还对有监督的情况进行了测试，具体做法是从时间序列提取特征，然后将Saliency Map也作为特征引入，构造一个有监督的Neural Network进行测试。 提取的特征如Table 5所示： 神经网络的结构为两层全连接层，并添加了Dropout Ratio为0.5的Dropout Layer。两个Layer使用了\\(L_1=L_2=0.0001\\)的正则化。同时为了处理样本不平衡的情况使用了过采样来使正负样本的比例为\\(1:2\\)。结构如Figure 7所示： 训练测试集的情况如Table 6所示，最终结果如Table 7所示，P-R曲线如Figure 8所示。可以看到使用了SR特征的DNN效果由于没有使用SR特征的DNN。","categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"Spectral","slug":"Spectral","permalink":"http://qfxiao.me/tags/Spectral/"}]}],"categories":[{"name":"Research","slug":"Research","permalink":"http://qfxiao.me/categories/Research/"},{"name":"Self-supervised Learning","slug":"Research/Self-supervised-Learning","permalink":"http://qfxiao.me/categories/Research/Self-supervised-Learning/"},{"name":"Technical Notes","slug":"Technical-Notes","permalink":"http://qfxiao.me/categories/Technical-Notes/"},{"name":"Machine Learning","slug":"Technical-Notes/Machine-Learning","permalink":"http://qfxiao.me/categories/Technical-Notes/Machine-Learning/"},{"name":"Representation Learning","slug":"Research/Representation-Learning","permalink":"http://qfxiao.me/categories/Research/Representation-Learning/"},{"name":"Anomaly Detection","slug":"Research/Anomaly-Detection","permalink":"http://qfxiao.me/categories/Research/Anomaly-Detection/"},{"name":"Notes","slug":"Research/Notes","permalink":"http://qfxiao.me/categories/Research/Notes/"},{"name":"Time Series Modeling","slug":"Research/Time-Series-Modeling","permalink":"http://qfxiao.me/categories/Research/Time-Series-Modeling/"},{"name":"Misc","slug":"Technical-Notes/Misc","permalink":"http://qfxiao.me/categories/Technical-Notes/Misc/"},{"name":"Misc","slug":"Research/Misc","permalink":"http://qfxiao.me/categories/Research/Misc/"},{"name":"Tutorial","slug":"Research/Tutorial","permalink":"http://qfxiao.me/categories/Research/Tutorial/"},{"name":"RNN","slug":"Research/RNN","permalink":"http://qfxiao.me/categories/Research/RNN/"},{"name":"Time Series Imputation","slug":"Research/Time-Series-Imputation","permalink":"http://qfxiao.me/categories/Research/Time-Series-Imputation/"}],"tags":[{"name":"Representation Learning","slug":"Representation-Learning","permalink":"http://qfxiao.me/tags/Representation-Learning/"},{"name":"Self-supervised Learning","slug":"Self-supervised-Learning","permalink":"http://qfxiao.me/tags/Self-supervised-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://qfxiao.me/tags/Deep-Learning/"},{"name":"Contrastive Learning","slug":"Contrastive-Learning","permalink":"http://qfxiao.me/tags/Contrastive-Learning/"},{"name":"Overfitting","slug":"Overfitting","permalink":"http://qfxiao.me/tags/Overfitting/"},{"name":"Bias","slug":"Bias","permalink":"http://qfxiao.me/tags/Bias/"},{"name":"Variance","slug":"Variance","permalink":"http://qfxiao.me/tags/Variance/"},{"name":"ID3","slug":"ID3","permalink":"http://qfxiao.me/tags/ID3/"},{"name":"C4.5","slug":"C4-5","permalink":"http://qfxiao.me/tags/C4-5/"},{"name":"CART","slug":"CART","permalink":"http://qfxiao.me/tags/CART/"},{"name":"SVM","slug":"SVM","permalink":"http://qfxiao.me/tags/SVM/"},{"name":"GBDT","slug":"GBDT","permalink":"http://qfxiao.me/tags/GBDT/"},{"name":"XGBoost","slug":"XGBoost","permalink":"http://qfxiao.me/tags/XGBoost/"},{"name":"Anomaly Detection","slug":"Anomaly-Detection","permalink":"http://qfxiao.me/tags/Anomaly-Detection/"},{"name":"Self-Supervised Learning","slug":"Self-Supervised-Learning","permalink":"http://qfxiao.me/tags/Self-Supervised-Learning/"},{"name":"Statistics","slug":"Statistics","permalink":"http://qfxiao.me/tags/Statistics/"},{"name":"Probability","slug":"Probability","permalink":"http://qfxiao.me/tags/Probability/"},{"name":"Time Series","slug":"Time-Series","permalink":"http://qfxiao.me/tags/Time-Series/"},{"name":"Shapelet","slug":"Shapelet","permalink":"http://qfxiao.me/tags/Shapelet/"},{"name":"GAN","slug":"GAN","permalink":"http://qfxiao.me/tags/GAN/"},{"name":"Novelty Detection","slug":"Novelty-Detection","permalink":"http://qfxiao.me/tags/Novelty-Detection/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://qfxiao.me/tags/Pytorch/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://qfxiao.me/tags/Tensorflow/"},{"name":"Docker","slug":"Docker","permalink":"http://qfxiao.me/tags/Docker/"},{"name":"Transfer Learning","slug":"Transfer-Learning","permalink":"http://qfxiao.me/tags/Transfer-Learning/"},{"name":"Geant4","slug":"Geant4","permalink":"http://qfxiao.me/tags/Geant4/"},{"name":"VAE","slug":"VAE","permalink":"http://qfxiao.me/tags/VAE/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://qfxiao.me/tags/Machine-Learning/"},{"name":"Variational Inference","slug":"Variational-Inference","permalink":"http://qfxiao.me/tags/Variational-Inference/"},{"name":"RNN","slug":"RNN","permalink":"http://qfxiao.me/tags/RNN/"},{"name":"Flow-based Model","slug":"Flow-based-Model","permalink":"http://qfxiao.me/tags/Flow-based-Model/"},{"name":"Spectral","slug":"Spectral","permalink":"http://qfxiao.me/tags/Spectral/"}]}